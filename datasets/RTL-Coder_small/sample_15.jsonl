{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a simple logic circuit. The circuit has three inputs and three outputs as follows:\n\n- Input 1 (a): a single-bit input\n- Input 2 (b): a single-bit input\n- Input 3 (c): a single-bit input\n- Output 1 (x): a single-bit output\n- Output 2 (y): a single-bit output\n- Output 3 (z): a single-bit output\n\nThe logic circuit is defined as follows:\n- If input `a` is high, then output `x` should be high and output `y` should be low.\n- If input `a` is low and input `b` is high, then output `y` should be high and output `x` should be low.\n- If both inputs `a` and `b` are low and input `c` is high, then output `z` should be high and outputs `x` and `y` should be low.\n- In all other cases, all outputs should be low.\n\nImplement this logic circuit as a Verilog module named `logic_circuit` that takes the inputs and outputs described above. Use the code snippet below as a starting point. Your task is to complete the module by filling in the missing logic.\n\n```verilog\nmodule logic_circuit(\n    input a,\n    input b,\n    input c,\n    output x,\n    output y,\n    output z\n    );\n\n    // Your code here\n\nendmodule\n```\n\n", "output": "module logic_circuit(\n    input a,\n    input b,\n    input c,\n    output x,\n    output y,\n    output z\n    );\n\n    assign x = a;\n    assign y = (a == 1'b0 && b == 1'b1);\n    assign z = (a == 1'b0 && b == 1'b0 && c == 1'b1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-input NAND gate. The module should be named `nand4` and should have the following input and output ports:\n\n- `input a`\n- `input b`\n- `input c`\n- `input d`\n- `output y`\n\nThe module should implement the following logic:\n\n```\ny = ~(a & b & c & d)\n```\n\nYour implementation should be contained within a single module of no more than 200 lines of verilog code.\n\n", "output": "module nand4 (\n    input a,\n    input b,\n    input c,\n    input d,\n    output y\n);\n\n    wire temp;\n\n    assign temp = a & b & c & d;\n    assign y = ~temp;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a JK flip-flop with the given truth table. The module should have inputs for J, K, and a clock signal (clk), and an output for Q. The output should be updated on the positive edge of the clock signal. The truth table is as follows: \n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nTo implement this module, use always block triggered by the positive edge of the clock. Inside the always block, use a case statement to handle the different combinations of J and K inputs and update the output Q accordingly.", "output": "module jk_flip_flop (\n  input J,\n  input K,\n  input clk,\n  output reg Q\n);\n  \n  always @(posedge clk) begin\n    case ({J,K})\n      2'b00: Q <= Q;\n      2'b01: Q <= 1'b0;\n      2'b10: Q <= 1'b1;\n      2'b11: Q <= ~Q;\n    endcase\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit binary number and outputs the 2's complement of that number. The module should be named \"twos_complement\" and should have the following input and output ports:\n\n- input [3:0] num_in: a 4-bit binary number\n- output [3:0] num_out: the 2's complement of the input number\n\nThe module should implement the following algorithm to compute the 2's complement of num_in:\n\n1. Invert all the bits of num_in\n2. Add 1 to the inverted number\n\nYour task is to write the verilog code for the \"twos_complement\" module that implements this algorithm.\n\n", "output": "module twos_complement(\n    input [3:0] num_in,\n    output [3:0] num_out\n);\n\n    wire [3:0] inverted_num;\n    wire [3:0] one = 4'b0001;\n    \n    assign inverted_num = ~num_in;\n    assign num_out = inverted_num + one;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes two 4-bit inputs (A and B) and outputs a 4-bit result (Y). The output Y should be the sum of the inputs A and B. If the sum is greater than 15, the output should be truncated to the least significant 4 bits. Your module should be named \"add4bit\" and should have the following ports:\n- A: 4-bit input\n- B: 4-bit input\n- Y: 4-bit output\n\n", "output": "module add4bit (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Y\n);\n\nalways @* begin\n    Y = A + B;\n    if (Y > 15) begin\n        Y = Y[3:0];\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in two inputs, `c_in` and `d_in`, and outputs `out1`. The `out1` output should be the result of a bitwise XOR operation between `temp` and `d_in`. The `temp` signal should be the result of a bitwise AND operation between `c_in` and `d_in`.\n\nWrite a Verilog module that implements the above functionality. Your module should be named `xor_and` and should have the following ports:\n- `c_in`: input bit\n- `d_in`: input bit\n- `out1`: output bit\n\n", "output": "module xor_and(\n        c_in,\n        d_in,\n        out1\n    );\n\n    // SIGNAL DECLARATIONS\n    input c_in;\n    input d_in;\n    output out1;\n    wire out1;\n    wire temp;\n\n    assign temp = c_in & d_in;\n    assign out1 = temp ^ d_in;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in 5 inputs and produces 1 output. The inputs are A1, A2, A3, A4, and B1. The output is Y. The module should be named \"logic_gate\". \n\nThe inputs are binary values, either 0 or 1. The output should be the result of the following logic expression: \n\nY = (A1 AND A2 AND A3 AND A4) OR B1\n\nYou should implement the module using Verilog syntax. \n\n", "output": "module logic_gate (\n    input A1,\n    input A2,\n    input A3,\n    input A4,\n    input B1,\n    output Y\n);\n\n    assign Y = (A1 & A2 & A3 & A4) | B1;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module in Verilog that can perform a bitwise XOR operation on two input signals `A` and `B`. The output signal `X` should be equal to `1` when `A` and `B` are different, and `0` when they are the same. The module should have the following interface:\n\n```\nmodule bitwise_xor (\n    input A,\n    input B,\n    output X\n);\n```\n\nYou should assume that the input signals `A` and `B` are single-bit signals. The output signal `X` should also be a single-bit signal.\n\nYour implementation should use only combinational logic and should be contained within a single module that is no more than 200 lines of Verilog code. You may use any of the standard Verilog operators (e.g., `&`, `|`, `^`, `~`) as well as any other standard Verilog constructs (e.g., `if`, `case`, `always`, `assign`). However, you should not use any Verilog constructs that rely on sequential logic (e.g., `reg`, `always @(posedge clk)`, etc.).\n\n", "output": "module bitwise_xor (\n    input A,\n    input B,\n    output X\n);\n    assign X = A ^ B;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit binary up counter with synchronous reset functionality. The counter should increment on the rising edge of the clock signal and reset to 0 on the rising edge of the reset signal. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: a clock signal\n- `RST`: a synchronous reset signal\n\nOutputs:\n- `Q`: a 4-bit output representing the current count value\n\nYou should use the following module template:\n\n```\nmodule up_counter_4bit_sync_reset (\n  input CLK,\n  input RST,\n  output reg [3:0] Q\n);\n\n  // your code here\n\nendmodule\n```\n\nPlease write the verilog code for the up_counter_4bit_sync_reset module.\n\n\n", "output": "module up_counter_4bit_sync_reset (\n  input CLK,\n  input RST,\n  output reg [3:0] Q\n);\n\n  always @(posedge CLK) begin\n    if (RST) begin\n      Q <= 4'b0000;\n    end else begin\n      Q <= Q + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary-to-Gray code converter. The module should have the following interface:\n\n```\nmodule binary_to_gray(\n    input  [3:0] binary,\n    output [3:0] gray\n);\n```\n\nThe `binary` input is a 4-bit binary number, and the `gray` output should be the corresponding 4-bit Gray code. The module should use combinational logic to convert the binary input to the Gray code output.\n\nYou may assume that the binary input is always a valid binary number (i.e., it does not exceed 15 in decimal).\n\n", "output": "module binary_to_gray(\n    input  [3:0] binary,\n    output [3:0] gray\n);\n    assign gray[0] = binary[0];\n    assign gray[1] = binary[0] ^ binary[1];\n    assign gray[2] = binary[1] ^ binary[2];\n    assign gray[3] = binary[2] ^ binary[3];\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in a 4-bit input and outputs a 2-bit output. The output should be the sum of the two most significant bits of the input and the two least significant bits of the input. If the sum is greater than or equal to 2, the output should be 2. Otherwise, the output should be the sum.\n\nDesign a module that implements this functionality. Your module should be named `sum2bits` and should have the following interface:\n\n```verilog\nmodule sum2bits (\n    input [3:0] in,\n    output reg [1:0] out\n);\n```\n\nYou can assume that the input will always be a valid 4-bit binary number.\n\n", "output": "module sum2bits (\n    input [3:0] in,\n    output reg [1:0] out\n);\n\n    always @(*) begin\n        if (in[3:2] + in[1:0] >= 2) begin\n            out = 2;\n        end else begin\n            out = in[3:2] + in[1:0];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 2-to-1 multiplexer. The module should have two input signals, `A` and `B`, and a select signal `S` that selects which input should be passed to the output `Y`. The module should be named `mux_2to1`.\n\nDeclare the module inputs and outputs as follows:\n- `A` and `B` are 1-bit inputs\n- `S` is a 1-bit input\n- `Y` is a 1-bit output\n\nYou should implement the multiplexer using a conditional statement. If `S` is 0, `A` should be passed to `Y`. If `S` is 1, `B` should be passed to `Y`.\n\n", "output": "module mux_2to1 (\n    A,\n    B,\n    S,\n    Y\n);\n\n    input A, B, S;\n    output Y;\n\n    assign Y = (S == 0) ? A : B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog code for a 4-bit synchronous up-counter with asynchronous reset functionality. The counter should increment on the rising edge of the clock signal and reset to zero on the falling edge of the reset signal. The counter should also have an asynchronous reset input that resets the counter to zero when active. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` (1-bit): clock signal\n- `reset` (1-bit): asynchronous reset signal (active low)\n\nOutputs:\n- `count` (4-bit): the counter output\n\nDefine a verilog module that implements the above specification.\n\n", "output": "module up_counter(\n  output reg [3:0] count,\n  input clk,\n  input reset\n);\n\n  always @(posedge clk or negedge reset) begin\n    if(!reset) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a digital circuit that implements a 2-input AND gate. The module should have the following inputs and outputs:\n\nInputs:\n- A_N (1-bit): input A, inverted\n- B (1-bit): input B\n- VPWR (1-bit): power supply voltage\n- VGND (1-bit): ground voltage\n- VPB (1-bit): voltage for input B\n- VNB (1-bit): negative voltage for input B\n\nOutputs:\n- X (1-bit): output of the AND gate\n\nYour task is to design a Verilog module that implements this AND gate. The module should be named `my_and2` and should be defined in a file named `my_and2.v`. You should assume that the inputs and outputs are connected to appropriate power and ground sources.\n\nYour module should be defined using the following template:\n\n```\nmodule my_and2 (\n    // inputs\n    input A_N,\n    input B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    \n    // outputs\n    output X\n);\n\n    // your code here\n\nendmodule\n```\n\nYour module should implement an AND gate that follows the following truth table:\n\n| A | B | X |\n|:-:|:-:|:-:|\n| 0 | 0 | 0 |\n| 0 | 1 | 0 |\n| 1 | 0 | 0 |\n| 1 | 1 | 1 |\n\n", "output": "module my_and2 (\n    // inputs\n    input A_N,\n    input B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    \n    // outputs\n    output X\n);\n\n    // Implement AND gate\n    assign X = ~(A_N | ~B);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit counter which counts up on the positive edge of a clock signal. The counter should have a synchronous reset input which sets the counter to 0 when asserted. Additionally, the module should have an enable signal which, when high, allows the counter to increment, and when low, stops the counter from incrementing.\n\nYour module should be named `counter` and should have the following ports:\n- `clk` (input): a clock signal\n- `reset` (input): a synchronous reset signal\n- `en` (input): an enable signal\n- `count` (output): a 4-bit output representing the current count value\n\nAssume that the clock signal has a frequency of 50 MHz.\n\n", "output": "module counter (\n  input clk,\n  input reset,\n  input en,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) count <= 4'b0;\n    else if (en) count <= count + 1;\n  end\n  \nendmodule"}
