{"instruction": "\n\nYou have been tasked with designing a module for a circuit that will control the power supply to a set of components. The module will take in several input signals and output a single signal to control the power supply. The module should be designed to be as power-efficient as possible, minimizing power consumption when the components are not in use.\n\nThe inputs to the module are as follows:\n- `A`: a single-bit input signal representing whether the components are in use (`1`) or not (`0`).\n- `SLEEP_B`: a single-bit input signal representing the sleep state of the system. When `SLEEP_B` is `1`, the system is in sleep mode and the power supply should be turned off regardless of the value of `A`.\n- `VPWR`: a single-bit input signal representing the power supply voltage.\n- `KAGND`: a single-bit input signal representing the ground voltage.\n- `VPB`: a single-bit input signal representing the voltage of the positive power supply rail.\n- `VNB`: a single-bit input signal representing the voltage of the negative power supply rail.\n\nThe output of the module is as follows:\n- `X`: a single-bit output signal representing the control signal for the power supply. When `X` is `1`, the power supply should be turned on. When `X` is `0`, the power supply should be turned off.\n\nDesign the `power_control` module in Verilog, which should be solvable by only one module within 200 lines of Verilog code.\n\n", "output": "module power_control (\n    X,\n    A,\n    SLEEP_B,\n    VPWR,\n    KAGND,\n    VPB,\n    VNB\n);\n\n    output X;\n    input A, SLEEP_B, VPWR, KAGND, VPB, VNB;\n\n    wire should_power_on = A & ~SLEEP_B;\n\n    assign X = should_power_on & VPWR & KAGND & VPB & VNB;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with creating a verilog module that takes in a 32 MHz clock signal and outputs a 40 MHz clock signal. You are given a testbench with a clock generator and a test sequence. Your module should be able to pass this test sequence. \n\nThe module should have the following inputs and outputs:\n- Input: CLK_IN1 (32 MHz clock signal)\n- Output: CLK_OUT (40 MHz clock signal)\n\nThe module should meet the following specifications:\n- The output clock signal should have a 50% duty cycle.\n- The output clock signal should have a 100 ps delay from the input clock signal.\n- The module should be able to pass the provided test sequence.\n\nYou can assume that all inputs and outputs are synchronous to the positive edge of the clock signal.\n\nWrite the verilog code for this module that meets the given specifications.\n\n", "output": "module clk32to40 (\n  input CLK_IN1,\n  output reg CLK_OUT\n);\n\n  // Clock to Q delay of 100ps\n  localparam  TCQ              = 100;\n\n  reg [1:0] counter = 2'b00;\n  reg reset = 1'b0;\n\n  always @(posedge CLK_IN1) begin\n    counter <= counter + 1;\n    if (counter == 2'b01) begin\n      CLK_OUT <= 1'b1;\n    end else if (counter == 2'b10) begin\n      CLK_OUT <= 1'b0;\n    end\n  end\n\n  always @(posedge CLK_IN1) begin\n    if (reset == 1'b1) begin\n      counter <= 2'b00;\n    end else if (counter == 2'b11) begin\n      reset <= 1'b1;\n    end else begin\n      reset <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module to implement a simple counter that counts the number of consecutive clock cycles where the input signal 'in' is high. The counter should reset to zero if the 'reset' signal is high. The output signal 'p' should be high when the counter reaches a count of 5. The module should have the following ports:\n\n- clk: input clock signal\n- reset: input reset signal\n- in: input signal to be counted\n- p: output signal indicating when the count has reached 5\n\nWrite a verilog module that implements this counter.\n\n", "output": "module counter(input clk, input reset, input in, output p);\n\treg [2:0] count;\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tcount <= 0;\n\t\telse begin\n\t\t\tif(in)\n\t\t\t\tcount <= count + 1;\n\t\t\telse\n\t\t\t\tcount <= 0;\n\t\tend\n\tend\n\tassign p = (count == 5);\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a synchronous reset level-sensitive D-type flip-flop with an asynchronous set and clear. The module should have the following inputs and outputs:\n- `input clk`: the clock input\n- `input rst`: the asynchronous reset input (active low)\n- `input set`: the asynchronous set input (active high)\n- `input clr`: the asynchronous clear input (active high)\n- `input d`: the data input\n- `output q`: the output\n\nThe flip-flop should operate as follows:\n- When `rst` is asserted, `q` should be set to 0 regardless of the values of `set`, `clr`, and `d`.\n- When `rst` is deasserted and `set` is asserted, `q` should be set to 1 regardless of the values of `clr` and `d`.\n- When `rst` is deasserted and `clr` is asserted, `q` should be set to 0 regardless of the values of `set` and `d`.\n- When `rst` is deasserted and neither `set` nor `clr` is asserted, `q` should follow the value of `d` on the rising edge of `clk`.\n\nYou should implement the module in Verilog within 200 lines of code.\n\n", "output": "module dff_rst_set_clr (\n  input clk, rst, set, clr, d,\n  output reg q\n);\n\nalways @(posedge clk or negedge rst) begin\n  if (~rst) begin\n    q <= 1'b0;\n  end else if (set) begin\n    q <= 1'b1;\n  end else if (clr) begin\n    q <= 1'b0;\n  end else begin\n    q <= d;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4:1 MUX (multiplexer) with the following interface:\n\n```\nmodule mux4to1 (\n    input  [3:0] data_in,\n    input  [1:0] sel,\n    output reg     data_out\n);\n```\n\nThe `data_in` input is a 4-bit vector that contains the data inputs to the MUX. The `sel` input is a 2-bit vector that contains the select lines for the MUX. The `data_out` output is a single bit that contains the selected data output.\n\nImplement this module using basic verilog constructs such as `if-else` statements and wire assignments. Do not use any built-in verilog constructs or modules for a MUX.\n\n", "output": "module mux4to1 (\n    input  [3:0] data_in,\n    input  [1:0] sel,\n    output reg     data_out\n);\n\n    wire [3:0] sel_inv;\n    assign sel_inv = ~sel;\n\n    always @ (*) begin\n        if (sel == 2'b00) begin\n            data_out = data_in[0];\n        end else if (sel == 2'b01) begin\n            data_out = data_in[1];\n        end else if (sel == 2'b10) begin\n            data_out = data_in[2];\n        end else if (sel == 2'b11) begin\n            data_out = data_in[3];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 7 inputs and produces 1 output. The module is named `seven_input_one_output` and it should be able to handle the following inputs:\n\n1. `a`: a 1-bit input signal\n2. `b`: a 1-bit input signal\n3. `c`: a 1-bit input signal\n4. `d`: a 1-bit input signal\n5. `e`: a 1-bit input signal\n6. `f`: a 1-bit input signal\n7. `g`: a 1-bit input signal\n\nThe module should also produce the following output:\n\n1. `x`: a 1-bit output signal\n\nThe module should be designed such that if the input signals `a`, `b`, `c`, `d`, `e`, `f`, and `g` are all high, then the output signal `x` should also be high. Otherwise, the output signal `x` should be low.\n\nDesign this module and provide the code for it.\n\n", "output": "module seven_input_one_output (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    input f,\n    input g,\n    output x\n);\n\n    assign x = (a & b & c & d & e & f & g);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder with carry-in and carry-out functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `reset`: a synchronous reset signal that resets the output to 0 when high\n- `a`: a 4-bit input signal\n- `b`: a 4-bit input signal\n- `cin`: a carry-in signal\n\nOutputs:\n- `sum`: a 4-bit output signal that represents the sum of `a`, `b`, and `cin`\n- `cout`: a carry-out signal that represents the carry-out from the most significant bit of the sum\n\nAssume that the module will be used in a larger design and that you cannot use any Verilog libraries or pre-defined modules.\n\n", "output": "module adder_4bit_cin_cout(\n    input clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    reg [3:0] temp_sum;\n    reg temp_cout;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            temp_sum <= 4'b0000;\n            temp_cout <= 1'b0;\n        end else begin\n            temp_sum <= a + b + cin;\n            temp_cout <= temp_sum[4];\n        end\n    end\n    \n    assign sum = temp_sum;\n    assign cout = temp_cout;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 5 input signals and outputs a single signal. The five input signals are A1, A2, A3, A4, and B1. The output signal is Y. The module should be named \"my_module\".\n\nThe module should operate as follows:\n- If A1, A2, A3, A4, and B1 are all high (1), Y should be high (1).\n- If A1, A2, A3, A4, and B1 are all low (0), Y should be low (0).\n- If any of A1, A2, A3, or A4 are low (0), regardless of the value of B1, Y should be low (0).\n\nYou should write the complete code for the module \"my_module\" in Verilog.\n\n", "output": "module my_module (\n    output Y,\n    input A1,\n    input A2,\n    input A3,\n    input A4,\n    input B1\n);\n\n    assign Y = (A1 & A2 & A3 & A4 & B1);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in a 4-bit binary-coded decimal (BCD) input and outputs a 7-bit value that represents the BCD value in 7-segment display format. The 7-bit output should be in the format of \"abcdefg\", where each bit represents a segment of the 7-segment display. The segments are labeled as follows:\n\n```\n  a\nf   b\n  g\ne   c\n  d\n```\n\nThe mapping of BCD values to 7-segment display segments is as follows:\n\n```\nBCD    abcdefg\n0      1000000\n1      1111001\n2      0100100\n3      0110000\n4      0011001\n5      0010010\n6      0000010\n7      1111000\n8      0000000\n9      0011000\n```\n\nDesign a module `bcd7seg` that implements this functionality. The module should have the following ports:\n\n- `input [3:0] bcd`: a 4-bit binary-coded decimal input\n- `output reg [6:0] seg`: a 7-bit output representing the BCD value in 7-segment display format\n\nEnsure that the module is synthesizable and can be simulated using a testbench.\n\n", "output": "module bcd7seg (\n  input      [3:0] bcd,\n  output reg [6:0] seg\n);\n\nalways @(*) begin\n  case(bcd)\n    4'h0   : seg = 7'b1000000;\n    4'h1   : seg = 7'b1111001;\n    4'h2   : seg = 7'b0100100;\n    4'h3   : seg = 7'b0110000;\n    4'h4   : seg = 7'b0011001;\n    4'h5   : seg = 7'b0010010;\n    4'h6   : seg = 7'b0000010;\n    4'h7   : seg = 7'b1111000;\n    4'h8   : seg = 7'b0000000;\n    4'h9   : seg = 7'b0011000;\n    default: seg = 7'bXXXXXXX;\n  endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 8-bit priority encoder. The circuit should have eight inputs, D[7:0], and three outputs, EN[2:0]. If only D[7] is high, EN should be equal to 100. If only D[6] is high, EN should be equal to 010. If only D[5] is high, EN should be equal to 001. If D[7] and D[6] are high, EN should be equal to 110. If D[7] and D[5] are high, EN should be equal to 101. If D[6] and D[5] are high, EN should be equal to 011. If D[7], D[6], and D[5] are high, EN should be equal to 111. If none of the inputs are high, EN should be equal to 000.", "output": "module priority_encoder (\n    input [7:0] D,\n    output [2:0] EN\n);\n\n    assign EN = (D[7]) ? 3'b100 :\n                (D[6]) ? 3'b010 :\n                (D[5]) ? 3'b001 :\n                (D[7:6]) ? 3'b110 :\n                (D[7:5]) ? 3'b101 :\n                (D[6:5]) ? 3'b011 :\n                (D[7:5]) ? 3'b111 :\n                3'b000;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a T flip-flop. A T flip-flop is a type of clocked sequential logic circuit that changes state on the rising or falling edge of a clock signal when the T input is asserted. When T is 0, the flip-flop holds its previous state. When T is 1, the flip-flop toggles its state. The output Q of the T flip-flop should be initially set to 0.", "output": "module t_ff (\n  input clk,\n  input reset,\n  input t,\n  output reg q\n);\n\nalways @(posedge clk, negedge reset) begin\n  if (!reset) begin\n    q <= 1'b0;\n  end else begin\n    if (t) begin\n      q <= ~q;\n    end\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-stage clock delay buffer, named `clkdlybuf4s`. The module should have two input ports, `CLK` and `RST`, and one output port, `CLK_OUT`. The `CLK` input is a standard clock signal, while the `RST` input is an active-high reset signal. When `RST` is asserted, the output `CLK_OUT` should be immediately set to 0. When `RST` is deasserted, `CLK_OUT` should be delayed by 4 clock cycles from the `CLK` input. The module should be designed such that it can be easily instantiated multiple times to provide longer delays.\n\nYou are required to create a Verilog module that meets the above specifications. Your code should be within 200 lines of Verilog code, and should be written in a modular and readable fashion.\n\n", "output": "module clkdlybuf4s (\n    input CLK, RST,\n    output reg CLK_OUT\n);\n\n    parameter DELAY_CYCLES = 4;\n    reg [DELAY_CYCLES-1:0] delay_reg;\n    integer i;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CLK_OUT <= 0;\n            delay_reg <= 0;\n        end else begin\n            delay_reg[0] <= CLK;\n            for (i = 1; i < DELAY_CYCLES; i = i+1) begin\n                delay_reg[i] <= delay_reg[i-1];\n            end\n            CLK_OUT <= delay_reg[DELAY_CYCLES-1];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder with a carry-in input. The module should have four inputs: `A`, `B`, `Cin`, and `Clk`, and two outputs: `Sum` and `Cout`. The module should use a synchronous design approach where the output is updated on the rising edge of the clock signal. \n\nIn addition, the module should have a reset input, `Rst`, which when asserted, sets the output `Sum` to 0 and the `Cout` to 0. The module should also have an enable input, `En`, which when deasserted, should hold the output `Sum` and `Cout` to their current values.\n\nYou are given the following skeleton code to start with:\n\n```\nmodule adder_4bit(Cin, A, B, Clk, En, Rst, Sum, Cout);\n  input Cin, A, B, Clk, En, Rst;\n  output [3:0] Sum;\n  output Cout;\n\n  // Your code here\n\nendmodule\n```\n\nPlease complete the module and ensure that it meets the requirements specified above. \n\n", "output": "module adder_4bit(Cin, A, B, Clk, En, Rst, Sum, Cout);\n  input Cin, A, B, Clk, En, Rst;\n  output [3:0] Sum;\n  output Cout;\n\n  reg [3:0] Sum_reg;\n  reg Cout_reg;\n\n  always @(posedge Clk) begin\n    if (Rst) begin\n      Sum_reg <= 4'b0000;\n      Cout_reg <= 1'b0;\n    end else if (En) begin\n      {Cout_reg, Sum_reg} <= Cin + A + B + Sum_reg;\n    end\n  end\n\n  assign Sum = Sum_reg;\n  assign Cout = Cout_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-bit up/down counter with an enable input. The counter should be able to count up or down depending on the enable input. When the enable input is high, the counter should increment by one on the positive edge of the clock signal. When the enable input is low, the counter should decrement by one on the negative edge of the clock signal. The counter should have a synchronous reset input that sets the counter to zero when activated.", "output": "module up_down_counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg [2:0] count\n);\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      count <= 3'b0;\n    end else if (enable == 1) begin\n      count <= count + 1;\n    end else begin\n      count <= count - 1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Create a module that generates a pulse every 5 cycles of a clock signal. The module should have one input port for the clock signal and one output port for the pulse signal. The pulse signal should be high for one cycle and low for the next 4 cycles. In addition, the module should include a counter that keeps track of the number of pulses generated and resets back to zero after every 20 pulses.", "output": "module pulse_generator(\n  input clk,\n  output reg pulse\n);\n\n  reg [4:0] counter = 0;\n\n  always @(posedge clk) begin\n    if (counter == 4'b10000) begin\n      counter <= 0;\n      pulse <= 1;\n    end else if (counter == 4'b00000) begin\n      pulse <= 0;\n      counter <= counter + 1;\n    end else begin\n      pulse <= 0;\n      counter <= counter + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a 4-bit binary counter that counts up on the rising edge of a clock signal. The module should include a synchronous reset input that sets the counter to 0 when asserted. The module should also include an output signal that goes high when the counter reaches the maximum count value (15) and remains high until the next clock cycle. \n\nDesign the module and provide the Verilog code for it.\n\n", "output": "module binary_counter (\n    input clk,\n    input reset,\n    output reg[3:0] count,\n    output reg max_count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n        max_count <= 1'b0;\n    end else begin\n        if (count == 4'b1111) begin\n            count <= 4'b0000;\n            max_count <= 1'b1;\n        end else begin\n            count <= count + 1;\n            max_count <= 1'b0;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 2-to-1 multiplexer (MUX) with an enable input. The output of the MUX should be the input from the first input port when the enable input is low, and the input from the second input port when the enable input is high.", "output": "module mux_2to1_enable (\n  input enable,\n  input [7:0] in1,\n  input [7:0] in2,\n  output reg [7:0] out\n);\n\n  always @(*) begin\n    if (enable == 1'b0) begin\n      out = in1;\n    end else begin\n      out = in2;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\nYou have been tasked with designing a module that takes in three input signals, A, B, and C_N, and outputs a signal X. The module should implement a logical OR operation between the three input signals, such that if any of the inputs is high, the output X is also high. You are given a code snippet for the sky130_fd_sc_lp__or3b_4 module, which implements a 3-input OR gate using the sky130_fd_sc_lp__or3b library element. You need to use this code snippet as a starting point to create your own module that implements the same functionality, but with the following additional requirements:\n\n1. Your module should be named my_or3b_4.\n2. Your module should be implemented using only basic logic gates (AND, OR, NOT) and should not use the sky130_fd_sc_lp__or3b library element.\n3. Your module should have the same input and output signals as the sky130_fd_sc_lp__or3b_4 module: input signals A, B, and C_N, and output signal X.\n4. Your module should be synthesizable and should meet the timing requirements of the target hardware.\n\nCreate a Verilog module my_or3b_4 that implements the above requirements.\n\n", "output": "module my_or3b_4 (\n    input A,\n    input B,\n    input C_N,\n    output X\n);\n\n    wire AB, AB_C_N, A_C_N, B_C_N;\n\n    assign AB = A | B;\n    assign AB_C_N = AB | C_N;\n    assign A_C_N = A | C_N;\n    assign B_C_N = B | C_N;\n\n    assign X = AB_C_N & A_C_N & B_C_N;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in two 1-bit inputs, `d0` and `d1`, and outputs a 1-bit value, `y`. The module should also have three control inputs: a clock signal `clk`, a clock enable signal `ce`, and a clear signal `clr`.\n\nInside the module, there are three wires: `d0_1_24`, `d1_1_27`, and `fully_2_1_bit`. `d0_1_24` is assigned to `d0`, `d1_1_27` is assigned to `d1`, and `fully_2_1_bit` is assigned to the logical AND of `d0_1_24` and `d1_1_27`. Finally, `y` is assigned to `fully_2_1_bit`.\n\nYour task is to write the Verilog code for the module that satisfies the requirements above. The module should be self-contained and solvable by only one module within 200 lines of Verilog code.\n\n", "output": "module sysgen_logical_2d2e86ecb2 (\n  input [(1 - 1):0] d0,\n  input [(1 - 1):0] d1,\n  output [(1 - 1):0] y,\n  input clk,\n  input ce,\n  input clr);\n  reg [(1 - 1):0] d0_1_24;\n  reg [(1 - 1):0] d1_1_27;\n  wire fully_2_1_bit;\n  \n  always @(posedge clk) begin\n    if (ce) begin\n      d0_1_24 <= d0;\n      d1_1_27 <= d1;\n    end\n  end\n  \n  assign fully_2_1_bit = d0_1_24 & d1_1_27;\n  assign y = fully_2_1_bit;\n  \n  initial begin\n    d0_1_24 = 1'b0;\n    d1_1_27 = 1'b0;\n  end\n  \n  always @(posedge clk) begin\n    if (clr) begin\n      d0_1_24 <= 1'b0;\n      d1_1_27 <= 1'b0;\n    end\n  end\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in five inputs, A1, A2, A3, B1, and B2, and outputs a single value X. The module should be named \"my_module\". The inputs and output are all single-bit values. The module should implement the following logic:\n\n- X should be the output of an OR gate that takes in the outputs of two AND gates.\n- The first AND gate should take in A1, A2, and A3 as inputs.\n- The second AND gate should take in B1 and B2 as inputs.\n\nYour task is to implement this module in Verilog within 200 lines of code. You should also write a brief explanation of how your module works.\n\n", "output": "module my_module (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire and0_out;\n    wire and1_out;\n    wire or0_out_X;\n\n    and and0 (and0_out, A1, A2, A3);\n    and and1 (and1_out, B1, B2);\n    or or0 (or0_out_X, and0_out, and1_out);\n    buf buf0 (X, or0_out_X);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in four input signals A1, A2, A3, and B1, and produces a single output signal X. The module should be named \"logic_gate\" and should not exceed 200 lines of code. \n\nThe module should implement the following logic:\n- Perform an AND operation between signals A1, A2, and A3. Store the output in a local signal called \"and0_out\".\n- Perform an OR operation between the output of the AND operation and signal B1. Store the output in a local signal called \"or0_out_X\".\n- Assign the value of \"or0_out_X\" to the output signal X.\n\nYour task is to implement the \"logic_gate\" module in verilog, adhering to the above specifications. \n\n", "output": "module logic_gate (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Local signals\n    wire and0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , A3, A1, A2     );\n    or  or0  (or0_out_X, and0_out, B1   );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a clock gating circuit. The circuit should have the following inputs and outputs:\n- CLK: a clock input signal.\n- EN: an enable input signal.\n- TE: a trigger enable input signal.\n- ENCLK: an output signal that is high when both the enable input and trigger enable input are high, and low otherwise.\n\nYour clock gating circuit should use a D flip-flop as a basic building block. The circuit should also use a two-stage gating approach, where the first stage is a simple AND gate, and the second stage is a D flip-flop.\n\nYour Verilog module should be named \"clock_gate\" and should have the following interface:\n```\nmodule clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n```\nYou should assume that all input signals are synchronous to the same clock signal, and that the input signals are guaranteed to be stable before the rising edge of the clock.\n\n", "output": "module clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  wire AND_out;\n  wire D_flipflop_out;\n\n  // First stage: AND gate\n  assign AND_out = EN & TE;\n\n  // Second stage: D flip-flop\n  always @(posedge CLK) begin\n    if (EN) begin\n      D_flipflop_out <= AND_out;\n    end\n  end\n\n  // Output\n  assign ENCLK = D_flipflop_out;\n\nendmodule"}
{"instruction": "\n\nYou are asked to design a verilog module to implement a 4-bit magnitude comparator. The module should have two 4-bit inputs A and B, and three outputs: EQ, GT, and LT. EQ should be high if A is equal to B, GT should be high if A is greater than B, and LT should be high if A is less than B. You should implement this module using behavioral modeling (i.e., using an always block to describe the module's behavior).\n\n", "output": "module magnitude_comparator(A, B, EQ, GT, LT);\ninput [3:0] A, B;\noutput EQ, GT, LT;\n\nreg EQ, GT, LT;\n\nalways @(*) begin\n    if (A == B) begin\n        EQ = 1;\n        GT = 0;\n        LT = 0;\n    end\n    else if (A > B) begin\n        EQ = 0;\n        GT = 1;\n        LT = 0;\n    end\n    else begin\n        EQ = 0;\n        GT = 0;\n        LT = 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary counter with parallel load. The module should have the following inputs and outputs:\n\nInputs:\n- `clock`: a single bit input representing the clock signal\n- `load`: a single bit input representing the load signal\n- `data_in`: a 4-bit input representing the data to be loaded into the counter when `load` is high\n\nOutputs:\n- `count`: a 4-bit output representing the current count value of the counter\n\nThe counter should increment on every rising edge of the `clock` signal, unless the `load` signal is high, in which case the counter should load the value of `data_in`. The counter should wrap around to 0 when it reaches the maximum count value of 15.\n\nWrite the verilog code for the counter module.\n\n", "output": "module binary_counter (\n    clock,\n    load,\n    data_in,\n    count\n);\n\ninput clock;\ninput load;\ninput [3:0] data_in;\noutput reg [3:0] count;\n\nalways @(posedge clock) begin\n    if (load) begin\n        count <= data_in;\n    end else if (count == 4'b1111) begin\n        count <= 4'b0000;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will output messages to the console using different Verilog system tasks. The module should have an 8-bit input signal `data_in`, which will be used to control the messages outputted to the console. The module should output the following messages to the console based on the value of `data_in`:\n\n- If `data_in` is 0, output a message using the `$display` task that says \"Hello, world!\"\n- If `data_in` is 1, output a message using the `$fwrite` task that says \"This is a message written using $fwrite at time %t\" where `%t` is the current simulation time.\n- If `data_in` is 2, output a message using the `$fdisplay` task that says \"This is a message written using $fdisplay at time %t\" where `%t` is the current simulation time.\n- If `data_in` is any other value, output a message using the `$error` task that says \"Invalid input value\".\n\nYour module should have a single 8-bit input `data_in` and no output.\n\n", "output": "module console_output(\n    input [7:0] data_in\n);\n\n   initial begin\n      case(data_in)\n        8'b00000000: $display(\"Hello, world!\");\n        8'b00000001: $fwrite(1, \"This is a message written using $fwrite at time %t\", $time);\n        8'b00000010: $fdisplay(1, \"This is a message written using $fdisplay at time %t\", $time);\n        default: $error(\"Invalid input value\");\n      endcase\n   end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary to Gray code converter. The module should take in a 4-bit binary input and output the corresponding 4-bit Gray code. The module should have the following interface:\n\nInputs:\n- `in` : 4-bit binary input\n\nOutputs:\n- `out` : 4-bit Gray code output\n\nYou should name your module `binToGray`.\n\n", "output": "module binToGray(\n    input [3:0] in,\n    output [3:0] out\n);\n\n    assign out[0] = in[0];\n    assign out[1] = in[0] ^ in[1];\n    assign out[2] = in[1] ^ in[2];\n    assign out[3] = in[2] ^ in[3];\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that implements a D flip-flop with set and reset functionality. The module should have four inputs: D (data), C (clock), R (reset), and S (set), and one output: Q (output). When the clock signal is high, the module should store the value of D in Q. If R is high, Q should be reset to 0, and if S is high, Q should be set to 1. If both R and S are high, the behavior of the module is undefined.\n\nYou are required to implement this functionality using Verilog and provide the code for the module. Assume that all inputs are synchronous to the rising edge of the clock signal.\n\n", "output": "module dffsr(D, Q, C, R, S);\n    input D, C, R, S;\n    output Q;\n\n    reg Q;\n\n    always @(posedge C) begin\n        if (R == 1'b1 && S == 1'b1) begin\n            // Undefined behavior\n        end else if (R == 1'b1) begin\n            Q <= 1'b0;\n        end else if (S == 1'b1) begin\n            Q <= 1'b1;\n        end else begin\n            Q <= D;\n        end\n    end\nendmodule"}
{"instruction": "\n\nWrite a verilog module that implements a 4-bit adder-subtractor with two inputs (A and B) and two control signals (C0 and C1). The module should output the result of A+B if C0=0 and C1=0, A-B if C0=1 and C1=0, and A+B+1 if C0=0 and C1=1. If C0=1 and C1=1, the module should output A-B-1. The module should have the following interface:\n\nInputs:\n- `clk`: the clock signal\n- `reset`: the reset signal, active high\n- `A`: a 4-bit input signal\n- `B`: a 4-bit input signal\n- `C0`: a control signal\n- `C1`: a control signal\n\nOutputs:\n- `result`: a 4-bit output signal representing the result of the operation\n\nAssume that the input signals A and B are valid on the rising edge of the clock signal, and that the output signal result is valid on the next rising edge of the clock signal.\n\n", "output": "module addsub4bit(\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    input C0,\n    input C1,\n    output reg [3:0] result\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        result <= 4'b0;\n    end else begin\n        case ({C1, C0})\n            2'b00: result <= A + B;\n            2'b01: result <= A + B + 1;\n            2'b10: result <= A - B;\n            2'b11: result <= A - B - 1;\n        endcase\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that can perform a simple arithmetic operation on two 4-bit inputs. The module should take in two 4-bit inputs, a 2-bit control signal, and output a 4-bit result. The control signal determines the type of operation to be performed (addition or subtraction). \n\nThe module should implement the following truth table: \n\n| Control | Input 1 | Input 2 | Output |\n|---------|---------|---------|--------|\n| 00      | 0000    | 0000    | 0000   |\n| 00      | 0000    | 0001    | 1111   |\n| 00      | 0001    | 0000    | 1111   |\n| 00      | 0001    | 0001    | 1110   |\n| 01      | 0000    | 0000    | 0000   |\n| 01      | 0000    | 0001    | 1111   |\n| 01      | 0001    | 0000    | 0001   |\n| 01      | 0001    | 0001    | 0000   |\n\nImplement the module within 200 lines of Verilog code.\n\n", "output": "module arithmetic_module(input [3:0] a, b, input [1:0] control, output reg [3:0] out);\n\nalways @(*) begin\n    case(control)\n        2'b00: out = a + b; // addition\n        2'b01: out = a - b; // subtraction\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a clock signal, a data input, and a reset signal, and outputs the data input after a delay of one clock cycle. The data input should be stored in a flip-flop and then passed through a combinational logic block before being outputted.\n\nDesign a Verilog module that meets the following requirements:\n\n- The module should be named `delay_module`.\n- The module should have the following inputs:\n  - `clk`: a 1-bit clock signal\n  - `din`: a 1-bit data input\n  - `reset_n`: a 1-bit active-low reset signal\n- The module should have the following output:\n  - `dout`: a 1-bit data output\n- The module should have a delay of one clock cycle between the input and output.\n- The module should use a flip-flop to store the input data.\n- The module should use a combinational logic block to process the data before outputting it.\n- The module should reset the flip-flop to 0 when the reset signal is asserted.\n\nWrite a Verilog module that meets these requirements.\n\n", "output": "module delay_module (\n    input clk,\n    input din,\n    input reset_n,\n    output dout\n);\n\n    wire [0:0] wire_dffpipe3_q;\n    wire [0:0] wire_comb;\n\n    usb_system_sdram_clk_dffpipe_l2c dffpipe3 (\n        .clock(clk),\n        .clrn(reset_n),\n        .d(din),\n        .q(wire_dffpipe3_q)\n    );\n\n    assign wire_comb = wire_dffpipe3_q;\n\n    assign dout = wire_comb;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that calculates the sum of two 4-bit binary numbers. The module should have two 4-bit input ports, A and B, and one 4-bit output port, S. The module should also have a 1-bit input port, CIN, which represents the carry-in bit. The module should output a 1-bit carry-out, COUT. The module should use only combinational logic and should not use any sequential elements such as flip-flops or registers. \n\nYou should write the Verilog code for the module, named adder_4bit, which implements the above requirements. \n\n", "output": "module adder_4bit(\n  input [3:0] A,\n  input [3:0] B,\n  input CIN,\n  output [3:0] S,\n  output COUT\n);\n\n  assign {COUT, S} = A + B + CIN;\n  \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a 4-to-2 priority encoder using a case statement. A priority encoder is a combinational circuit that takes multiple inputs and outputs the position of the highest priority input that is active. For example, a 4-bit priority encoder given the input 4'b0110 would output 2'b10, because bit[2] is the highest priority bit that is high. If none of the inputs are high, output 2'b00. Use a case statement to implement the priority encoder.", "output": "module priority_encoder_4to2 (\n  input [3:0] data,\n  output reg [1:0] priority\n);\n\n  always @(*) begin\n    case (data)\n      4'b0001: priority = 2'b00;\n      4'b0010: priority = 2'b01;\n      4'b0100: priority = 2'b10;\n      4'b1000: priority = 2'b11;\n      default: priority = 2'b00;\n    endcase\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 2-to-1 multiplexer. The module should have two input signals, A and B, and one output signal, Y. Additionally, there should be a select signal, S, which determines which input signal is passed to the output. If S is 0, then A should be passed to Y. If S is 1, then B should be passed to Y. \n\nDesign the module and ensure that it compiles without errors.\n\n", "output": "module mux_2to1(\n    input A,\n    input B,\n    input S,\n    output Y\n);\n\nassign Y = (S == 1) ? B : A;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 3-input AND gate. The module should have the following inputs and outputs:\n\n- `input a, b, c`: the three input signals to the AND gate\n- `output y`: the output signal of the AND gate\n\nYour module should be named `three_input_and` and should be implemented using basic logic gates (AND, OR, NOT). You are not allowed to use any built-in verilog operators or functions.\n\nWrite the verilog code for the `three_input_and` module.\n\n", "output": "module three_input_and (\n    input a,\n    input b,\n    input c,\n    output reg y\n);\n\n    wire ab;\n    wire abc;\n    \n    assign ab = a & b;\n    assign abc = ab & c;\n    \n    always @(abc) begin\n        y = abc;\n    end\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that implements a D-latch with an enable gate and an asynchronous reset. The module should have the following inputs and outputs:\n- `D`: the data input\n- `GATE_N`: the enable gate (active low)\n- `RESET_B`: the asynchronous reset (active low)\n- `Q`: the output\n\nThe D-latch should be transparent when the enable gate is high and should latch the input value when the enable gate goes low. The output should hold its value when the enable gate is high and should update with the input value when the enable gate goes low. The module should also have an asynchronous reset that sets the output to 0 when activated.\n\nDesign a module that satisfies these requirements. Your module should be self-contained and should not rely on any external modules or libraries. Your module should be written in Verilog and should be no longer than 200 lines.\n\n", "output": "module dlatch_enable_reset (\n    input D,\n    input GATE_N,\n    input RESET_B,\n    output reg Q\n);\n\nalways @ (posedge GATE_N or negedge RESET_B) begin\n    if (!RESET_B) begin\n        Q <= 0;\n    end else if (!GATE_N) begin\n        Q <= D;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock divider. \nA clock divider is a digital circuit that takes in an input clock signal and outputs a lower frequency clock signal by dividing the input clock frequency. \nYour module should have the following inputs and outputs:\n\nInputs: \n- clk_in: the input clock signal\n- rst: a synchronous reset signal\n\nOutputs: \n- clk_out: the output clock signal which has a lower frequency than clk_in\n\nThe module should also have the following parameters:\n\n- div_factor: the factor by which the input clock frequency is to be divided. This is an integer value.\n\nYour module should implement the following functionality:\n\n- The module should output a clock signal that has a frequency equal to the input clock signal divided by the div_factor.\n- The module should be synchronous with the input clock signal, i.e., the output clock signal should change state only when the input clock signal changes state.\n- The module should have a synchronous reset input, rst, which when asserted should reset the output clock signal to its initial state.\n\nTo implement the clock divider, you should use Verilog code to define the output clock signal as a function of the input clock signal and the div_factor. \nYou should then use this function to generate the output clock signal. \nYou should also use the rst signal to reset the output clock signal when it is asserted.", "output": "module clock_divider (\n  input clk_in, \n  input rst,\n  output reg clk_out\n);\n\nparameter div_factor = 2;\n\nalways @(posedge clk_in, posedge rst) begin\n  if (rst) begin\n    clk_out <= 0;\n  end else begin\n    clk_out <= ~clk_out; // toggle the output clock signal\n  end\nend\n\nassign clk_out = clk_out & ((div_factor/2)-1'b1); // determine the frequency of the output clock signal\n\nendmodule"}
{"instruction": "\n\nYou are tasked to implement a verilog module that performs a 3-bit-to-1-bit multiplexer. The module should have the following interface:\n\nInputs:\n- `reset`: a synchronous reset signal.\n- `clk`: a clock signal.\n- `sel`: a 3-bit selection signal.\n- `in0`, `in1`, `in2`: 1-bit input signals.\n\nOutputs:\n- `out`: a 1-bit output signal.\n\nThe module should output the value of `in0`, `in1`, or `in2` depending on the value of the `sel` signal. If `sel` is `000`, `out` should be equal to `in0`. If `sel` is `001`, `out` should be equal to `in1`. If `sel` is `010`, `out` should be equal to `in2`.\n\nYou should use the following template for your module:\n\n```\nmodule mux3to1(\n    reset,\n    clk,\n    sel,\n    in0,\n    in1,\n    in2,\n    out);\n\n// Inputs\ninput reset;\ninput clk;\ninput [2:0] sel;\ninput in0;\ninput in1;\ninput in2;\n\n// Outputs\noutput out;\n\n// Your code here\n\nendmodule\n```\n\n", "output": "module mux3to1(\n    reset,\n    clk,\n    sel,\n    in0,\n    in1,\n    in2,\n    out);\n\n// Inputs\ninput reset;\ninput clk;\ninput [2:0] sel;\ninput in0;\ninput in1;\ninput in2;\n\n// Outputs\noutput out;\n\nreg out;\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        out <= 1'b0;\n    end else begin\n        case (sel)\n            3'b000: out <= in0;\n            3'b001: out <= in1;\n            3'b010: out <= in2;\n            default: out <= 1'b0;\n        endcase\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a bitwise addition between two 4-bit numbers and a carry-in bit, producing a 4-bit sum and a carry-out bit. The module should be named \"adder\" and should have the following inputs and outputs:\n\nInputs:\n- a (4-bit unsigned integer): the first input number to be added\n- b (4-bit unsigned integer): the second input number to be added\n- cin (1-bit unsigned integer): the carry-in bit\n\nOutputs:\n- sum (4-bit unsigned integer): the sum of the two input numbers and the carry-in bit\n- cout (1-bit unsigned integer): the carry-out bit\n\nThe module should be implemented using only combinational logic and should follow the following truth table:\n\n| a | b | cin | sum | cout |\n|---|---|-----|-----|------|\n| 0 | 0 |  0  |  0  |   0   |\n| 0 | 0 |  1  |  1  |   0   |\n| 0 | 1 |  0  |  1  |   0   |\n| 0 | 1 |  1  |  0  |   1   |\n| 1 | 0 |  0  |  1  |   0   |\n| 1 | 0 |  1  |  0  |   1   |\n| 1 | 1 |  0  |  0  |   1   |\n| 1 | 1 |  1  |  1  |   1   |\n\nWrite the Verilog code for the \"adder\" module that implements the above truth table.\n\n", "output": "module adder (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  assign sum = a + b + cin;\n  assign cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module that implements a 2-bit comparator. The module should have two input ports, A and B, and one output port, EQ, which should be high if and only if A and B are equal. The module should be named \"two_bit_comparator\".\n\nPlease implement the module using the following guidelines:\n\n- The inputs A and B are 2-bit vectors.\n- The output EQ is a single bit.\n- The module should use only combinational logic.\n- You are not allowed to use any built-in verilog operators (such as ==, !=, etc.) or any other pre-built modules.\n- You may use any combinational logic gates (and, or, xor, etc.) and any other combinational modules you create yourself.\n\n", "output": "module two_bit_comparator (\n    input [1:0] A,\n    input [1:0] B,\n    output EQ\n);\n\n    wire eq1, eq2, eq3;\n\n    // Check if A[1] == B[1]\n    xor x1(eq1, A[1], B[1]);\n\n    // Check if A[0] == B[0]\n    xor x2(eq2, A[0], B[0]);\n\n    // Check if A == B\n    and a1(eq3, eq1, eq2);\n\n    // Set output EQ to 1 if A == B, 0 otherwise\n    assign EQ = eq3;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a Boolean function with three inputs (a, b, c) and one output (y). The function should be defined as follows:\n- If the input rsb is 0, the output should always be 0.\n- If all three inputs (a, b, c) are 1, the output should be 1.\n- If all three inputs (a, b, c) are 0, the output should be 0.\n- For all other input combinations, the output should be 0.\n\nYou should implement the Boolean function in a module named \"th33r_ref\". The module should have the following ports:\n- y: output, single bit\n- a, b, c: inputs, single bit each\n- rsb: input, single bit\n\nYour implementation should be contained within 200 lines of Verilog code. \n\n", "output": "module th33r_ref (y,a,b,c,rsb);\n output y;\n input a;\n input b;\n input c;\n input rsb;\n\n reg yi;\n\n  always @(a or b or c or rsb) begin\n   if (rsb == 0)begin\n      yi <=  0;\n   end else   if (((a) & (b) & (c))) \n    begin\n      yi <=  1;\n    end\n    else if (((a==0) & (b==0) & (c==0))) \n    begin\n      yi <=  0;\n    end\n    else\n    begin\n      yi <= 0;\n    end\n   end\n  assign #1 y = yi; \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes three inputs, `atm_valid`, `dtm_valid`, and `itm_valid`, and produces a two-bit output, `compute_input_tm_cnt`. The output is determined based on the following rules:\n- If all inputs are invalid (0), the output should be 0\n- If only `atm_valid` is valid (1), the output should be 1\n- If only `dtm_valid` is valid (10 in binary), the output should be 1\n- If only `itm_valid` is valid (100 in binary), the output should be 1\n- If `atm_valid` and `dtm_valid` are valid (11 in binary), the output should be 2\n- If `atm_valid` and `itm_valid` are valid (101 in binary), the output should be 2\n- If `dtm_valid` and `itm_valid` are valid (110 in binary), the output should be 2\n- If all inputs are valid (111 in binary), the output should be 3\n\nYou need to implement this logic in a Verilog module with the following interface:\n\n```\nmodule compute_input_tm_cnt (\n  input atm_valid,\n  input dtm_valid,\n  input itm_valid,\n  output [1:0] compute_input_tm_cnt\n);\n```\n\nYour implementation should be contained within 200 lines of Verilog code.\n\n", "output": "module compute_input_tm_cnt (\n  input atm_valid,\n  input dtm_valid,\n  input itm_valid,\n  output [1:0] compute_input_tm_cnt\n);\n\n  always @(*) begin\n    case ({itm_valid, atm_valid, dtm_valid})\n      3'b000: compute_input_tm_cnt = 2'b00;\n      3'b001: compute_input_tm_cnt = 2'b01;\n      3'b010: compute_input_tm_cnt = 2'b01;\n      3'b011: compute_input_tm_cnt = 2'b10;\n      3'b100: compute_input_tm_cnt = 2'b01;\n      3'b101: compute_input_tm_cnt = 2'b10;\n      3'b110: compute_input_tm_cnt = 2'b10;\n      3'b111: compute_input_tm_cnt = 2'b11;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nWrite a verilog module for a 4-to-1 multiplexer with an enable signal. The module should have the following inputs and outputs:\n\nInputs:\n- `in0`, `in1`, `in2`, `in3`: 4-bit input data lines\n- `sel`: 2-bit selection line\n- `en`: 1-bit enable signal\n\nOutputs:\n- `out`: 4-bit output data line\n\nThe module should behave as follows:\n- When `en` is 0, `out` should be all zeros.\n- When `en` is 1 and `sel` is 00, `out` should be equal to `in0`.\n- When `en` is 1 and `sel` is 01, `out` should be equal to `in1`.\n- When `en` is 1 and `sel` is 10, `out` should be equal to `in2`.\n- When `en` is 1 and `sel` is 11, `out` should be equal to `in3`.\n\n", "output": "module mux4to1_en(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    input en,\n    output [3:0] out\n);\n\nwire [3:0] mux1, mux2;\n\nassign mux1 = (sel[0] == 0) ? in0 : in1;\nassign mux2 = (sel[0] == 0) ? in2 : in3;\n\nassign out = (en == 1) ? ((sel[1] == 0) ? mux1 : mux2) : 4'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in three inputs A1, A2, and B1_N and produces a single output Y. The module should be named \"my_module\" and should be written in Verilog.\n\nThe module should implement the following logical function:\n- If A1 and A2 are both high, Y should be high.\n- If A1 is low and A2 is high, Y should be high.\n- If A1 is high and A2 is low, Y should be high.\n- If A1 and A2 are both low, Y should be low.\n\nIn addition, the module should include the following:\n- The input B1_N should be an active-low signal.\n- The module should be designed to operate on a voltage supply of 1V.\n- The module should be designed to operate on a clock signal of 100MHz.\n\nYour task is to write the Verilog code for the \"my_module\" module that meets the above specifications.\n\n", "output": "module my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = (~A1 & A2) | (A1 & ~A2) | (~A1 & ~A2 & ~B1_N);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a Verilog module for a 4-bit binary counter with asynchronous reset functionality. The module should have the following input and output ports:\n\nInput Ports:\n- clk: the clock signal\n- rst: the asynchronous reset signal\n\nOutput Ports:\n- out: the 4-bit output of the counter\n\nThe counter should increment on every rising edge of the clock signal and reset to 0 on the assertion of the reset signal. You are required to use behavioral Verilog for this design.\n\nWrite a Verilog module that implements the above requirements.\n\n", "output": "module binary_counter (\n    clk,\n    rst,\n    out\n);\n\ninput clk, rst;\noutput reg [3:0] out;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 4'b0;\n    end else begin\n        out <= out + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in two 4-bit binary inputs, A and B, and outputs the 4-bit binary value of A XOR B. Your module should be named \"xor_4bit\" and should have the following ports:\n\n- A (4-bit input)\n- B (4-bit input)\n- Y (4-bit output)\n\nYour module should use only basic logic gates (AND, OR, NOT, XOR) and should not use any pre-defined modules or operators. \n\nWrite the verilog code for the \"xor_4bit\" module.\n\n", "output": "module xor_4bit(\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] Y\n);\n\n  wire w1, w2, w3, w4, w5, w6, w7;\n\n  xor x1(w1, A[0], B[0]);\n  xor x2(w2, A[1], B[1]);\n  xor x3(w3, A[2], B[2]);\n  xor x4(w4, A[3], B[3]);\n\n  and a1(w5, w1, w2);\n  and a2(w6, w3, w4);\n  and a3(w7, w5, w6);\n\n  xor x5(Y[0], A[0], B[0]);\n  xor x6(Y[1], A[1], B[1]);\n  xor x7(Y[2], A[2], B[2]);\n  xor x8(Y[3], A[3], B[3]);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit up-counter with asynchronous reset. The module should have two inputs: `clk` and `rst`. The `clk` input is a clock signal and the `rst` input is an asynchronous reset signal. The module should have one output: `count`. The `count` output is a 4-bit signal that should increment on each rising edge of the `clk` signal, and reset to zero on a high signal of the `rst` input. You are not allowed to use any pre-defined counter modules or built-in functions.\n\nDesign the verilog module for the 4-bit up-counter with asynchronous reset.\n\n", "output": "module up_counter_async_reset(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk, posedge rst) begin\n    if (rst) begin\n        count <= 4'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 8-bit register with a specific behavior. The module should be named `r_TX_BUF_OBJ7_BYTE_0` and should have the following inputs and outputs:\n\n- `reset`: a synchronous reset signal that resets the register to `0` when asserted.\n- `wenb`: a write enable signal that indicates when new data should be written to the register. When `wenb` is high, the input `in_data` should be written to the register.\n- `in_data`: an 8-bit input signal that contains the data to be written to the register.\n- `clk`: the clock signal.\n\nThe module should have one output:\n\n- `reg_0x6C`: an 8-bit output signal that contains the current value of the register.\n\nThe register should have the following behavior:\n\n- When `reset` is asserted, the register should be reset to `0`.\n- When `wenb` is asserted, the value of `in_data` should be written to the register.\n- When `wenb` is not asserted, the register should retain its current value.\n\nImplement the `r_TX_BUF_OBJ7_BYTE_0` module that satisfies the above requirements.\n\n", "output": "module r_TX_BUF_OBJ7_BYTE_0(output reg [7:0] reg_0x6C, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==0) begin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x6C<=in_data;\n\t\t\telse\n\t\t\t\treg_0x6C<=reg_0x6C;\n\t\tend\n\t\telse\n\t\t\treg_0x6C<=8'h00;\n\tend\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a finite state machine (FSM) for a 3-bit binary counter. The counter should increment its value on each positive edge of the clock signal and reset to 0 when it reaches its maximum value.", "output": "module fsm_3bit_binary_counter (\n  input clk,\n  input reset,\n  output reg [2:0] count\n);\n\n  reg [2:0] next_count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      next_count <= 3'b000;\n    end else if (count == 3'b111) begin\n      next_count <= 3'b000;\n    end else begin\n      next_count <= count + 3'b001;\n    end\n  end\n\n  always @(posedge clk) begin\n    count <= next_count;\n  end\n\nendmodule\n"}
{"instruction": "\nYou are tasked with designing a module that implements a 2-to-1 multiplexer using the following interface:\n\n```\nmodule mux_2to1 (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n```\n\nThe module should take two input signals, `a` and `b`, and a select signal `sel`. If `sel` is high, the output should be equal to `a`. If `sel` is low, the output should be equal to `b`.\n\nYou should implement this module using only combinational logic, and you are not allowed to use any built-in Verilog operators or functions (e.g. `if`, `case`, `?:`, etc.). You may use any gates or modules from the Skywater 130 library.\n\n", "output": "module mux_2to1 (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    wire not_sel;\n    wire and_a;\n    wire and_b;\n    wire or_ab;\n\n    not not_gate (not_sel, sel);\n    and and_gate_a (and_a, a, not_sel);\n    and and_gate_b (and_b, b, sel);\n    or or_gate (or_ab, and_a, and_b);\n    not not_gate_out (out, or_ab);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a simple shift register with a parallel load input. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock input\n- `rst`: an asynchronous reset input\n- `load`: a parallel load input\n- `in`: a serial input\n\nOutputs:\n- `out`: the serial output\n\nThe shift register should have a length of 8 bits and should shift the input `in` in on every rising edge of `clk`. When `load` is high, the contents of the shift register should be replaced with the value of `load`. When `rst` is asserted, the shift register should be cleared to all zeros.\n\nWrite the verilog code for the shift register module.\n\n", "output": "module shift_register(clk, rst, load, in, out);\n\n  input clk, rst, load, in;\n  output reg [7:0] out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      out <= 8'b0;\n    end\n    else if (load) begin\n      out <= in;\n    end\n    else begin\n      out <= {out[6:0], in};\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit ripple-carry adder with carry-in and carry-out ports. The module should have three inputs (A, B, and CIN) and two outputs (SUM and COUT). The module should implement the addition of A and B, with the carry-in value specified by CIN. The output SUM should be the 4-bit sum of A, B, and CIN. The output COUT should be the carry-out value of the addition.", "output": "module ripple_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output reg [3:0] SUM,\n    output reg COUT\n);\n\n    always @(*) begin\n        SUM = A + B + CIN;\n        COUT = (A[3] & B[3]) | (A[3] & CIN) | (B[3] & CIN);\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a D flip-flop with asynchronous set and reset. The module should have the following inputs and outputs:\n\nInputs:\n- D: Data input\n- CLK: Clock input\n- SET: Asynchronous set input\n- RESET: Asynchronous reset input\n\nOutputs:\n- Q: Output\n- NOT_Q: Complementary output\n\nThe module should behave as follows:\n- When SET is asserted, Q should be set to 1 and NOT_Q should be set to 0, regardless of the value of D or CLK.\n- When RESET is asserted, Q should be set to 0 and NOT_Q should be set to 1, regardless of the value of D or CLK.\n- When both SET and RESET are de-asserted, the flip-flop should behave as a standard D flip-flop, i.e., Q should follow the value of D on the rising edge of CLK and NOT_Q should be the complement of Q.\n\nWrite the Verilog code for the module that implements the above behavior.\n\n", "output": "module dff_async_set_reset (\n    input D,\n    input CLK,\n    input SET,\n    input RESET,\n    output Q,\n    output NOT_Q\n);\n\nreg Q;\nreg NOT_Q;\n\nalways @(posedge CLK, negedge SET, negedge RESET) begin\n    if (SET == 0 && RESET == 1) begin\n        Q <= 1;\n        NOT_Q <= 0;\n    end else if (SET == 1 && RESET == 0) begin\n        Q <= 0;\n        NOT_Q <= 1;\n    end else begin\n        Q <= D;\n        NOT_Q <= ~D;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit binary up counter with synchronous clear functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock input\n- `clr`: a synchronous clear input\n\nOutputs:\n- `Q`: a 4-bit output representing the count value\n\nThe counter should increment by 1 on each rising edge of the clock input. When the clear input is asserted, the counter should be reset to 0.\n\nWrite a Verilog module that implements the above counter with synchronous clear functionality.\n\n", "output": "module up_counter_sync_clr (\n    input  wire        clk,\n    input  wire        clr,\n    output reg  [3:0]  Q\n);\n\n    always @(posedge clk) begin\n        if (clr) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been given a Verilog code snippet for a digital circuit module named `sky130_fd_sc_hd__clkdlybuf4s18_1`. This module has one input port named `A` and one output port named `X`. The module also has four supply signals named `VPWR`, `VGND`, `VPB`, and `VNB`. The module is instantiated from another module named `sky130_fd_sc_hd__clkdlybuf4s18`. The `sky130_fd_sc_hd__clkdlybuf4s18` module is a clock delay buffer that is used to delay the clock signal by a certain amount of time. \n\nYour task is to write another Verilog module named `divider` that takes the output of `sky130_fd_sc_hd__clkdlybuf4s18_1` module as its input. The `divider` module should have two output ports named `Y` and `Z`. The output port `Y` should output `1` every 10 clock cycles of the input signal, and `0` otherwise. The output port `Z` should output `1` every 20 clock cycles of the input signal, and `0` otherwise. You should assume that the input signal frequency is 100 MHz.\n\n", "output": "module divider (\n    Y,\n    Z,\n    X\n);\n\n    output Y;\n    output Z;\n    input X;\n\n    reg [31:0] counter_1;\n    reg [31:0] counter_2;\n\n    always @(posedge X) begin\n        counter_1 <= counter_1 + 1;\n        counter_2 <= counter_2 + 1;\n\n        if (counter_1 == 10) begin\n            Y <= 1;\n            counter_1 <= 0;\n        end else begin\n            Y <= 0;\n        end\n\n        if (counter_2 == 20) begin\n            Z <= 1;\n            counter_2 <= 0;\n        end else begin\n            Z <= 0;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with asynchronous active-low reset and asynchronous active-high clear. The module should have the following ports:\n\n- `din`: a single-bit input that represents the data to be stored in the flip-flop.\n- `clk`: a single-bit input that represents the clock signal.\n- `reset`: a single-bit input that represents the asynchronous active-low reset signal. When this signal is asserted, the flip-flop should be reset to 0.\n- `clear`: a single-bit input that represents the asynchronous active-high clear signal. When this signal is asserted, the flip-flop should be cleared to 1.\n- `q`: a single-bit output that represents the current value stored in the flip-flop.\n\nYour implementation should be done using only combinational logic and D flip-flops. You should use the provided code snippet as a starting point to implement the module.\n\nWrite a Verilog module that implements the above requirements. Your module should be named `dff_async_ns_cl_r1`.\n\n", "output": "module dff_async_ns_cl_r1 (\n  input din,\n  input clk,\n  input reset,\n  input clear,\n  output reg q\n);\n\n  // D flip-flop with asynchronous active-low reset\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      q <= 1'b0;\n    end else begin\n      q <= din;\n    end\n  end\n\n  // Clear logic\n  always @(*) begin\n    if (clear) begin\n      q <= 1'b1;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 3-bit counter with asynchronous reset and enable signals. The module should have the following inputs and outputs:\n\nInputs:\n- clk: the clock signal\n- reset: the asynchronous reset signal (active low)\n- enable: the enable signal (active high)\n\nOutputs:\n- count: the 3-bit counter output\n\nThe counter should increment on the rising edge of the clock signal when the enable signal is high. When the reset signal is low, the counter should be cleared to zero.\n\nWrite the verilog code for this module.\n\n", "output": "module counter_3bit(\n\tinput clk,\n\tinput reset,\n\tinput enable,\n\toutput reg [2:0] count\n);\n\n\talways @(posedge clk or negedge reset) begin\n\t\tif(!reset) begin\n\t\t\tcount <= 3'b0;\n\t\tend else if(enable) begin\n\t\t\tcount <= count + 1;\n\t\tend\n\tend\n\nendmodule"}
{"instruction": "\n\nYou have been given a code snippet for a Verilog testbench module, `error2_tb`, which instantiates a module `error2`. The `error2` module has two ports: `clk` and `leds`. The `clk` port is a single-bit input that is used to drive the clock signal for the `error2` module, while the `leds` port is a 2-bit output that controls two LEDs.\n\nYour task is to complete the design of the `error2` module, which should be able to generate a simple LED blinking pattern. Specifically, the LEDs should alternate between being on and off every 500ms. You can assume that the clock frequency is 1MHz.\n\nPlease write the Verilog code for the `error2` module.\n\n", "output": "module error2 (\n  input clk,\n  output reg [1:0] leds\n);\n\nreg [19:0] counter = 0;\n\nalways @(posedge clk) begin\n  counter <= counter + 1;\n  if (counter == 1000000) begin\n    counter <= 0;\n    leds <= ~leds;\n  end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a one-shot pulse generator, also known as a monostable multivibrator. \nA one-shot pulse generator produces a single pulse output in response to a trigger input. The pulse width of the output can be adjusted by changing the values of the components in the circuit.\nYour module should have the following inputs and outputs:\n\nInputs: \n- trigger: a single-bit input signal that triggers the pulse generation\n- pulse_width: a parameter that sets the width of the output pulse (in time units)\n\nOutputs: \n- pulse: a single-bit output signal that generates the pulse\n\nYour module should implement the following functionality:\n- When the trigger input goes high, the pulse output should go high and stay high for the duration of the pulse width parameter.\n- After the pulse width has elapsed, the pulse output should go low again.\n\nTo implement the one-shot pulse generator, you should use Verilog code to define a counter that counts up to the pulse width parameter and generates a pulse when it reaches the end. \nYou should then use this counter in conjunction with the trigger input to generate the output pulse. \nFinally, you should use the pulse output to drive any downstream logic that requires a single pulse input.", "output": "module one_shot (\n  input trigger,\n  output pulse\n);\n\n  parameter pulse_width = 10; // pulse width in time units\n  \n  reg [7:0] count; // 8-bit counter to count up to pulse_width\n  \n  always @(posedge trigger) begin\n    count <= 0; // reset counter on trigger\n    pulse <= 1; // set pulse high on trigger\n  end\n  \n  always @(posedge clk) begin\n    if (count < pulse_width) begin\n      count <= count + 1; // increment counter\n    end else begin\n      pulse <= 0; // set pulse low after pulse_width\n    end\n  end\n  \nendmodule"}
{"instruction": "Design a module that implements a NOR gate using only NAND gates. A NOR gate is an OR gate with its output inverted. The module should have two inputs and one output. The output should be the result of performing the NOR operation on the two input values using only NAND gates.", "output": "module nor_using_nand( \n    input a, \n    input b, \n    output out );\n\n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n\n    // Implementing NOR using NAND gates\n    nand nand1( .a(a), .b(a), .out(nand1_out) );\n    nand nand2( .a(b), .b(b), .out(nand2_out) );\n    nand nand3( .a(nand1_out), .b(nand2_out), .out(out) );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two inputs and outputs their logical AND. However, you must implement this module using only 200 lines of Verilog code.\n\nYour module should be named \"and2\", and should have the following ports:\n\n- `input i0`: The first input bit\n- `input i1`: The second input bit\n- `output o`: The output bit, which should be the logical AND of the two input bits\n\nYour module should be designed using only basic gates, such as AND, OR, NOT, and XOR gates. You are not allowed to use any pre-existing modules or submodules beyond the basic gates.\n\nYour module should be written in Verilog and should include a header with your name and the date.\n\n", "output": "module and2 (output o, input i0, i1);\n\n  // Intermediate wires\n  wire w0;\n  wire w1;\n  wire w2;\n\n  // AND gate\n  and a0 (w0, i0, i1);\n\n  // NOT gate\n  not n0 (w1, i0);\n\n  // NOT gate\n  not n1 (w2, i1);\n\n  // AND gate\n  and a1 (o, w1, w2);\n\n  // End of module\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital circuit using Verilog. The circuit should have four voltage supply signals: VPWR, VGND, VPB, and VNB. The module should be named \"power_supply\" and should include the following ports:\n\n- VPWR: a 1-bit input signal representing the voltage supply for the positive power rail.\n- VGND: a 1-bit input signal representing the voltage supply for the ground.\n- VPB: a 1-bit output signal representing the voltage supply for the positive battery terminal.\n- VNB: a 1-bit output signal representing the voltage supply for the negative battery terminal.\n\nThe circuit should ensure that VPB is always at a higher voltage potential than VNB. In addition, the circuit should be designed in such a way that VPWR and VGND can be connected to external power sources, while VPB and VNB are connected to a battery.\n\nYou are required to write a Verilog module that implements the above circuit requirements. Your module should be self-contained and should not rely on any external modules.\n\n", "output": "module power_supply (\n    input VPWR,\n    input VGND,\n    output VPB,\n    output VNB\n);\n\n    // Define voltage levels\n    parameter VDD = 1;\n    parameter VSS = 0;\n    parameter VBAT = 1.5;\n\n    // Define internal signals\n    wire VBATP;\n    wire VBATN;\n\n    // Connect voltage supplies\n    assign VBATP = VPWR ? VBAT : VSS;\n    assign VBATN = VGND ? VBAT : VSS;\n\n    // Ensure VPB is higher than VNB\n    assign VPB = VBATP;\n    assign VNB = VBATN;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder with carry-in and carry-out functionality. The module should have two 4-bit input ports, A and B, and a single bit input port, Cin, representing the carry-in. The module should also have two 4-bit output ports, Sum and Cout, representing the sum of A and B and the carry-out, respectively.\n\nTo implement this functionality, you should use a combination of full adders and gates. You may assume that the full adder module is already provided for you and has the following interface:\n\n```\nmodule FullAdder ( input A, input B, input Cin, output S, output Cout );\n```\n\nYou should also assume that any necessary wires and/or reg variables have already been declared for you.\n\nYour module should be named \"Adder4\" and should have the following interface:\n\n```\nmodule Adder4 ( input [3:0] A, input [3:0] B, input Cin, output [3:0] Sum, output Cout );\n```\n\nYou should ensure that your module meets the following requirements:\n\n1. The module should correctly compute the sum of A and B, taking into account the carry-in, and output the result on the Sum port.\n\n2. The module should correctly compute the carry-out of the addition and output the result on the Cout port.\n\n3. The module should be implemented using only the FullAdder module and gates.\n\n", "output": "module Adder4 ( input [3:0] A, input [3:0] B, input Cin, output [3:0] Sum, output Cout );\n\n  wire [3:0] S;\n  wire C1, C2, C3;\n\n  FullAdder FA0 ( .A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(C1) );\n  FullAdder FA1 ( .A(A[1]), .B(B[1]), .Cin(C1), .S(S[1]), .Cout(C2) );\n  FullAdder FA2 ( .A(A[2]), .B(B[2]), .Cin(C2), .S(S[2]), .Cout(C3) );\n  FullAdder FA3 ( .A(A[3]), .B(B[3]), .Cin(C3), .S(S[3]), .Cout(Cout) );\n\n  assign Sum = S;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a voltage level shifter. \nA voltage level shifter is a circuit that converts signals from one voltage level to another. \nFor example, a 3.3-volt signal might need to be converted to a 5-volt signal in order to interface with another device that operates at a different voltage level.\n\nYour module should have the following inputs and outputs:\n\nInputs: a set of n input signals (in1, in2, ..., inn) and a voltage reference signal (vref)\nOutputs: a set of m output signals (out1, out2, ..., outm)\n\nYour module should also have the following parameters:\n\nn: the number of input signals\nm: the number of output signals\nvlow: the low voltage level of the input signals\nvhigh: the high voltage level of the input signals\nvreflow: the low voltage level of the reference signal\nvrefhigh: the high voltage level of the reference signal\n\nYour module should implement the following functionality:\n\nFor each input signal, compare its voltage level to the voltage level of the reference signal.\nIf the input signal voltage level is lower than the reference signal voltage level, the output signal should be set to vlow.\nIf the input signal voltage level is higher than the reference signal voltage level, the output signal should be set to vhigh.\nIf the input signal voltage level is equal to the reference signal voltage level, the output signal should be set to vreflow.\nTo implement the voltage level shifter, you should use Verilog code to compare the input signals to the reference signal and set the output signals accordingly. \nYou should also ensure that the output signals are connected to the correct voltage level.", "output": "module voltage_level_shifter (\n  input [n-1:0] in,\n  input vref,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 4; // number of output signals\nparameter vlow = 0; // low voltage level of input signals\nparameter vhigh = 1; // high voltage level of input signals\nparameter vreflow = 0; // low voltage level of reference signal\nparameter vrefhigh = 1; // high voltage level of reference signal\n\n  assign out = (in < vref) ? vlow : ((in > vref) ? vhigh : vreflow);\n\nendmodule"}
{"instruction": "\nYou are tasked with creating a Verilog module that takes in a single input `i` and outputs a single bit `oa`. However, there is a catch - the module cannot be longer than 200 lines of Verilog code. \n\nThe Verilog module should perform the following operations:\n\n1. Assign a value of 1'b1 to the input `i`.\n2. Assign the value of `i` to the output `oa`.\n\nYour task is to write a Verilog module that meets these requirements and is no longer than 200 lines of code.\n\n", "output": "module a (input i, output oa);\n   // verilator lint_off ASSIGNIN\n   assign i = 1'b1;\n   assign oa = i;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a circuit for 4-bit binary to gray code conversion. The module should have two ports, a 4-bit input signal and a 4-bit output signal. The module should convert the binary input signal to its equivalent gray code and output it through the output port. The gray code output should be generated using the XOR operation between the input signal and its right-shifted value. Ensure that the module works correctly for all possible input values.", "output": "module binary_to_gray (\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0] ^ 0;\n  assign gray[1] = binary[1] ^ binary[0];\n  assign gray[2] = binary[2] ^ binary[1];\n  assign gray[3] = binary[3] ^ binary[2];\n\nendmodule\n"}
{"instruction": "\n\nWrite a Verilog module that implements a 4-bit binary counter with asynchronous reset and load. The counter should increment on each rising edge of the clock signal and reset to 0 when the asynchronous reset input is asserted. Additionally, the counter should load a new value from the input data bus when the load input is asserted, and continue counting from that value.\n\nThe module should have the following inputs and outputs:\n\n- `clk`: the clock signal (1-bit input)\n- `rst`: the asynchronous reset signal (1-bit input)\n- `load`: the load signal (1-bit input)\n- `data`: the input data bus for loading a new value (4-bit input)\n- `count`: the 4-bit output representing the current count value\n\nAssume that the module is used in a larger system and that the inputs will be held constant for a sufficient amount of time for the counter to reach its maximum value.\n\n", "output": "module binary_counter(clk, rst, load, data, count);\n\n  input clk, rst, load;\n  input [3:0] data;\n  output [3:0] count;\n\n  reg [3:0] count;\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      count <= 4'b0;\n    end else if (load) begin\n      count <= data;\n    end else begin\n      count <= count + 4'b1;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary counter. The counter should have a clock input, a reset input, and a 4-bit output. The counter should increment on each rising edge of the clock signal, and reset to 0 on the rising edge of the reset signal. \n\nWrite a Verilog module that implements this counter and name it \"binary_counter\". \n\n", "output": "module binary_counter (\n  input clock,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clock) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module with 4 inputs and 4 outputs that implements a 2-to-4 decoder. The module should take in a 2-bit input and produce a 4-bit output where only one bit is high at a time, based on the input value. \n\nTo implement the decoder, you can use if-else or case statements to determine the output based on the input value. You can also use bitwise operators to set the appropriate bit in the output.", "output": "module decoder_2to4 (\n  input [1:0] in,\n  output [3:0] out\n);\n\n  assign out[0] = (in == 2'b00) ? 1'b1 : 1'b0;\n  assign out[1] = (in == 2'b01) ? 1'b1 : 1'b0;\n  assign out[2] = (in == 2'b10) ? 1'b1 : 1'b0;\n  assign out[3] = (in == 2'b11) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a simple 4-bit counter with an asynchronous reset signal. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `reset`: an asynchronous reset signal\n\nOutputs:\n- `q`: a 4-bit output representing the current count value\n\nThe counter should increment on the rising edge of the clock signal, and should reset to 0 on the assertion of the reset signal. Your module should be synthesizable and should not use any built-in primitives or instantiations.\n\nWrite a verilog module that implements this counter.\n\n", "output": "module counter(clk, reset, q);\n    input clk, reset;\n    output reg [3:0] q;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end\n        else begin\n            q <= q + 1;\n        end\n    end\nendmodule"}
{"instruction": "\n\nWrite a Verilog module for a 4-bit counter that counts up from 0 to 15 and then resets back to 0. The module should have a clock input and a reset input. The counter value should be output as a 4-bit binary number. \n\nYou should use the following inputs and outputs:\n- `input clk`: the clock input\n- `input rst`: the reset input\n- `output reg [3:0] count`: the 4-bit binary counter output\n\nAssume that the input clock frequency is 10MHz.\n\n", "output": "module counter(clk, rst, count);\n\ninput clk, rst;\noutput reg [3:0] count;\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        count <= 4'b0000;\n    end else begin\n        if(count == 4'b1111) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 4'b0001;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are given a verilog module called `sky130_fd_sc_ls__o21a_1` that has three input signals `A1`, `A2`, and `B1`, and one output signal `X`. The module also has four voltage supply signals `VPWR`, `VGND`, `VPB`, and `VNB`. The module instantiates another verilog module called `sky130_fd_sc_ls__o21a` and connects its four input and output signals to the signals of the same names in `sky130_fd_sc_ls__o21a_1`. Your task is to write the verilog code for the `sky130_fd_sc_ls__o21a` module. \n\nThe `sky130_fd_sc_ls__o21a` module has four input signals `A1`, `A2`, `B1`, and `EN`, and one output signal `X`. The module implements the following logic: if `EN` is high, then `X` is `A1 AND A2 AND B1`; if `EN` is low, then `X` is always low.\n\nWrite the verilog code for the `sky130_fd_sc_ls__o21a` module.\n\n", "output": "module sky130_fd_sc_ls__o21a (\n    X ,\n    A1,\n    A2,\n    B1,\n    EN\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  EN;\n\n    assign X = EN ? (A1 & A2 & B1) : 1'b0;\n\nendmodule"}
{"instruction": "\nYou are tasked with creating a Verilog module for a binary D flip-flop with set functionality. The module should have one data input (D), two outputs (Q and Q_N), one set input (SET_B), one clock input (CLK), and four power inputs (VPB, VPWR, VGND, and VNB). The module should be named \"binary_dff_set\".\n\nThe D input should be a single bit and should represent the data input to the flip-flop. The Q output should also be a single bit and should represent the output of the flip-flop. The Q_N output should also be a single bit and should represent the complement of the output of the flip-flop.\n\nThe SET_B input should be a single bit and should represent the set input to the flip-flop. When SET_B is high, the Q output should be set to 1 and the Q_N output should be set to 0, regardless of the value of D.\n\nThe CLK input should be a single bit and should represent the clock input to the flip-flop. The flip-flop should be positive-edge triggered, meaning that the output should only change on the rising edge of the clock input.\n\nThe power inputs should be single-bit inputs that represent the power supply voltages and grounds for the flip-flop. VPB should be the power supply voltage for the input buffer, VPWR should be the power supply voltage for the flip-flop circuitry, VGND should be the ground for the flip-flop circuitry, and VNB should be the negative power supply voltage for the input buffer.\n\n", "output": "module binary_dff_set (\n    input  D    ,\n    output Q    ,\n    output Q_N  ,\n    input  SET_B,\n    input  CLK  ,\n    input  VPB  ,\n    input  VPWR ,\n    input  VGND ,\n    input  VNB\n);\n\n    wire D_buf;\n    bufif1 buf (D_buf, D, 1'b0, VPB);\n\n    reg Q_reg;\n    always @(posedge CLK) begin\n        if (SET_B) begin\n            Q_reg <= 1'b1;\n        end else begin\n            Q_reg <= D_buf;\n        end\n    end\n\n    assign Q = Q_reg;\n    assign Q_N = ~Q_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that performs the function of a 3-input AND gate. The module should have 3 input ports and 1 output port. The output should be high only when all 3 inputs are high, and low otherwise. You are not allowed to use any built-in verilog operators or functions to implement this module.\n\nDesign a verilog module that performs this function and name it \"my_and3\". The module should have the following port declaration:\n\n```\nmodule my_and3 (output o, input i0, i1, i2);\n```\n\n", "output": "module my_and3 (output o, input i0, i1, i2);\n    wire n1, n2, n3;\n    tkg_nand3 nand1 (n1, i0, i1, i2);\n    tkg_nand3 nand2 (n2, n1, n1, n1);\n    tkg_nand3 nand3 (o, n2, n2, n2);\nendmodule"}
{"instruction": "\n\nIn this problem, you are given a module called \"Test_Line\" which has one input called \"address\", one input called \"clock\", and one output called \"q\". The \"address\" input is a single bit, the \"clock\" input is a clock signal, and the \"q\" output is an 8-bit vector. Your task is to implement the logic for this module such that the output \"q\" is generated based on the following rules:\n\n1. When the \"address\" input is 0, the output \"q\" should be equal to 0.\n2. When the \"address\" input is 1, the output \"q\" should be equal to the value of \"address\" shifted left by 7 bits.\n\nYou need to implement this logic in a single module without using any other modules.\n\n", "output": "module Test_Line (\n    input [0:0] address,\n    input clock,\n    output reg [7:0] q\n);\n\nalways @(posedge clock) begin\n    if (address == 0) begin\n        q <= 0;\n    end else begin\n        q <= {address, 7'b0};\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a full adder operation. The module should take in three inputs: A, B, and CI (carry in), and output two values: SUM (the sum of A, B, and CI) and COUT_N (the carry out). Your module should be implemented within 200 lines of Verilog code.\n\nYour module should be named `full_adder` and should have the following interface:\n\n```\nmodule full_adder (\n    input A,\n    input B,\n    input CI,\n    output reg SUM,\n    output reg COUT_N\n);\n```\n\nYour module should implement the following logic:\n\n- The SUM output should be the result of adding A, B, and CI together.\n- The COUT_N output should be the carry out of the addition operation. \n\nYou should assume that A, B, and CI are single bit inputs (i.e., they are either 0 or 1).\n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input CI,\n    output reg SUM,\n    output reg COUT_N\n);\n\n    wire xor0_out_SUM;\n    wire a_b;\n    wire a_ci;\n    wire b_ci;\n    wire or0_out_coutn;\n\n    xor xor0 (xor0_out_SUM, A, B, CI);\n    buf buf0 (SUM, xor0_out_SUM);\n    nor nor0 (a_b, A, B);\n    nor nor1 (a_ci, A, CI);\n    nor nor2 (b_ci, B, CI);\n    or or0 (or0_out_coutn, a_b, a_ci, b_ci);\n    buf buf1 (COUT_N, or0_out_coutn);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a shift register with a parallel load functionality. The shift register should have a configurable number of bits and should be able to be loaded with a given data value in parallel. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `load`: a control signal that enables parallel loading of the shift register\n- `data_in`: the data to be loaded into the shift register in parallel\n- `shift`: a control signal that enables shifting of the shift register\n\nOutputs:\n- `data_out`: the output of the shift register\n\nYou should use the following template for your module:\n\n```\nmodule shift_register #(parameter WIDTH = 8) (\n    input clk,\n    input load,\n    input [WIDTH-1:0] data_in,\n    input shift,\n    output reg [WIDTH-1:0] data_out\n);\n\n// your code here\n\nendmodule\n```\n\nYour task is to complete the module by implementing the shift register with parallel load functionality. The shift register should shift the data in the `data_out` output every clock cycle when the `shift` signal is high. When the `load` signal is high, the shift register should load the data in `data_in` into the shift register in parallel, i.e., the data should appear in `data_out` on the next clock cycle.\n\n", "output": "module shift_register #(parameter WIDTH = 8) (\n    input clk,\n    input load,\n    input [WIDTH-1:0] data_in,\n    input shift,\n    output reg [WIDTH-1:0] data_out\n);\n\nreg [WIDTH-1:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data_in;\n    end else if (shift) begin\n        shift_reg <= {shift_reg[WIDTH-2:0], shift_reg[WIDTH-1]};\n    end\nend\n\nassign data_out = shift_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-byte transmit buffer object. The module should include a single 8-bit register (reg_0x61) that can be written to and read from. The module should have four input signals: reset, wenb, in_data, and clk. The reset input should be active-low and should reset the register to 0x00 when low. The wenb input should be active-high and should enable writing to the register when high. The in_data input should be the data that will be written to the register. The clk input should be the clock signal for the module.\n\nThe module should implement the following behavior:\n- On reset, the register should be set to 0x00.\n- When wenb is high, the in_data input should be written to the register.\n- When wenb is low, the register should retain its current value.\n\nWrite a Verilog module that implements the above behavior.\n\n", "output": "module r_TX_BUF_OBJ4_BYTE_1(output reg [7:0] reg_0x61, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==0) begin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x61<=in_data;\n\t\t\telse\n\t\t\t\treg_0x61<=reg_0x61;\n\t\tend\n\t\telse\n\t\t\treg_0x61<=8'h00;\n\tend\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in 4 inputs and produces 1 output. The input signals are named `in1`, `in2`, `in3`, and `in4`, and they are all 1-bit wide. The output signal is named `out` and it is also 1-bit wide. \n\nThe `out` signal should be 1 if and only if the input signals are all 0. Otherwise, the output should be 0.\n\nYou should implement this functionality using a `case` statement with non-constant case expressions. The case expressions should be based on the values of the input signals and should not use any constants.\n\nYou should name your module `all_zeroes`.\n\n", "output": "module all_zeroes(\n    input in1, in2, in3, in4,\n    output out\n);\n\n    reg out_reg;\n\n    always @(*) begin\n        case ({in1, in2, in3, in4})\n            {1'b0, 1'b0, 1'b0, 1'b0}: out_reg = 1'b1;\n            default: out_reg = 1'b0;\n        endcase\n    end\n\n    assign out = out_reg;\n\nendmodule"}
{"instruction": "\nYou have been tasked to design a verilog module that takes in two 8-bit inputs (A and B) and a carry-in signal (CI) and outputs a 9-bit sum (SUM) and a carry-out signal (COUT_N). The module should be named `adder_8bit`.\n\nThe module should have the following behavior:\n- If CI is high, the module should add A, B, and 1 and output the 9-bit sum and a carry-out signal.\n- If CI is low, the module should add A and B and output the 9-bit sum and a carry-out signal.\n\nThe module should have the following interface:\n- Two 8-bit inputs: A and B.\n- One input: CI.\n- One 9-bit output: SUM.\n- One output: COUT_N.\n\n", "output": "module adder_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    input CI,\n    output [8:0] SUM,\n    output COUT_N\n);\n\n    wire [7:0] temp_sum;\n    wire temp_carry;\n\n    // Add A and B\n    assign temp_sum = A + B;\n\n    // If CI is high, add 1 to the sum\n    assign temp_sum = (CI == 1'b1) ? temp_sum + 1 : temp_sum;\n\n    // Check if there is a carry-out\n    assign temp_carry = (CI == 1'b1) ? (temp_sum[8] | A[7] | B[7]) : (temp_sum[8] & A[7] & B[7]);\n\n    // Output the sum and carry-out\n    assign SUM = temp_sum;\n    assign COUT_N = ~temp_carry;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-to-1 multiplexer using the Verilog hardware description language. The module should have four input ports (A, B, C, D) and two select lines (S0, S1). The output of the module should be the selected input based on the values of S0 and S1, according to the following truth table:\n\n| S1 | S0 | Output |\n|----|----|--------|\n| 0  | 0  | A      |\n| 0  | 1  | B      |\n| 1  | 0  | C      |\n| 1  | 1  | D      |\n\nYour module should be named `mux4` and should be defined in a file named `mux4.v`. The module should be synthesizable and should not use any non-synthesizable constructs.\n\n", "output": "module mux4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output reg Y\n);\n\nalways @(*) begin\n    case ({S1, S0})\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module to implement a 4-bit adder with carry-in and carry-out functionality. The module should have four inputs (A, B, Cin) and two outputs (Sum, Cout). The adder should be implemented using structural verilog, with full adder modules instantiated as necessary.\n\nYour task is to complete the verilog module for the 4-bit adder with carry-in and carry-out functionality. You are given the following code snippet to work with:\n\n```\nmodule four_bit_adder(input [3:0] A, input [3:0] B, input Cin, output [3:0] Sum, output Cout);\n\n// Your code here\n\nendmodule\n```\n\nYour implementation should include:\n- Instantiation of four full adder modules to implement the 4-bit addition.\n- Appropriate wiring of the full adder modules to handle carry-in and carry-out functionality.\n- Properly assigning the output signals Sum and Cout.\n\nYou can assume that the full adder module has already been defined and is available for use.\n\n", "output": "module full_adder(input a, input b, input cin, output sum, output cout);\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule four_bit_adder(input [3:0] A, input [3:0] B, input Cin, output [3:0] Sum, output Cout);\n\nwire c1, c2, c3;\nfull_adder fa1(A[0], B[0], Cin, Sum[0], c1);\nfull_adder fa2(A[1], B[1], c1, Sum[1], c2);\nfull_adder fa3(A[2], B[2], c2, Sum[2], c3);\nfull_adder fa4(A[3], B[3], c3, Sum[3], Cout);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in two 5-bit input vectors, `in1` and `in2`, and a single-bit input signal, `choose`. The module should output a 5-bit vector, `out`, which is determined by the value of `choose`.\n\nWhen `choose` is 0, `out` should be equal to `in1`, and when `choose` is 1, `out` should be equal to `in2`. If `choose` is any other value, `out` should be set to all zeros.\n\nYou are required to implement this module within 200 lines of Verilog code.\n\n", "output": "module select2_5(\n    input [4:0] in1,\n    input [4:0] in2,\n    input choose,\n    output reg [4:0] out\n);\n\n    always@(in1 or in2 or choose)\n    case(choose)\n        1'b0: out = in1;\n        1'b1: out = in2;\n        default: out = 5'b0;\n    endcase\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Here is a Karnaugh map for a 4-bit input function F(A,B,C,D).\n\nCD\\ AB | 00 | 01 | 11 | 10 |\n   -------|----|----|----|----|\n    00  |  0 |  1 |  1 |  0 |\n    01  |  1 |  0 |  0 |  1 |\n    11  |  1 |  0 |  0 |  1 |\n    10  |  0 |  1 |  1 |  0 |\n\nImplement this combinational function using Verilog. The module name is karnaugh_map_4bit, which has four inputs A, B, C, and D, and one output F. You should use the Karnaugh map to simplify the Boolean expression of the function F(A,B,C,D) and then implement it using logic gates. The output F should be a reg type. Remember to declare the inputs and output in the module definition, and you may also need to declare parameters if needed.", "output": "module karnaugh_map_4bit(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @(*)\n  begin\n    case({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0011: F = 1'b0;\n      4'b0010: F = 1'b1;\n      4'b0110: F = 1'b0;\n      4'b0111: F = 1'b1;\n      4'b1111: F = 1'b0;\n      4'b1110: F = 1'b1;\n      4'b0100: F = 1'b1;\n      4'b0101: F = 1'b0;\n      4'b1101: F = 1'b1;\n      4'b1100: F = 1'b0;\n      4'b1000: F = 1'b0;\n      4'b1001: F = 1'b1;\n      4'b1011: F = 1'b0;\n      4'b1010: F = 1'b1;\n      default: F = 1'b0;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple calculator that performs basic arithmetic operations: addition, subtraction, multiplication, and division. The calculator should have two input registers, A and B, and one output register, C. The module should have a control input, op, which determines which operation to perform. The possible values of op are:\n\n- 2'b00: addition (C = A + B)\n- 2'b01: subtraction (C = A - B)\n- 2'b10: multiplication (C = A * B)\n- 2'b11: division (C = A / B)\n\nThe module should also have a reset input, which sets all registers to 0, and an enable input, which allows the module to perform calculations when active.\n\nYour task is to implement this calculator module in Verilog, ensuring that it is correct and efficient. Your code should be written in a single module with no more than 200 lines of code.\n\n", "output": "module calculator (\n  input clk,\n  input reset,\n  input enable,\n  input [1:0] op,\n  input [31:0] A,\n  input [31:0] B,\n  output reg [31:0] C\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      C <= 0;\n    end else if (enable) begin\n      case (op)\n        2'b00: C <= A + B;\n        2'b01: C <= A - B;\n        2'b10: C <= A * B;\n        2'b11: C <= A / B;\n        default: C <= 0;\n      endcase\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module for a 4-bit binary counter with an asynchronous reset input. The module should have the following ports:\n- `clk`: a clock input\n- `rst`: an asynchronous reset input\n- `en`: an enable input\n- `out`: a 4-bit output representing the current count value\n\nThe counter should start at 0 and increment on every positive edge of the clock input, as long as the enable input is high. When the asynchronous reset input is asserted, the counter should immediately reset to 0 and remain there until the reset input is deasserted.\n\nYour task is to write the verilog code for this module.\n\n", "output": "module binary_counter(clk, rst, en, out);\n    input clk, rst, en;\n    output [3:0] out;\n    \n    reg [3:0] count;\n    \n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n            count <= 4'd0;\n        else if (en)\n            count <= count + 1;\n    end\n    \n    assign out = count;\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that implements a 4-input AND gate with the following input and output ports:\n\n- `input [3:0] A`: 4-bit input bus\n- `output Y`: 1-bit output\n\nThe module should be named `AND4_W9`. You are required to use only AND gates and NOT gates in your implementation.\n\nWrite the verilog code for the `AND4_W9` module.\n\n", "output": "module AND4_W9 (\n  input [3:0] A,\n  output Y\n);\n\n  wire n1, n2, n3;\n  \n  assign n1 = ~(A[0] & A[1]);\n  assign n2 = ~(A[2] & A[3]);\n  assign n3 = ~(n1 & n2);\n  \n  assign Y = ~n3;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit synchronous counter with asynchronous reset and load functionality. The counter should increment on the rising edge of the clock signal. When the load signal is high, the counter should load the value of the input data. When the reset signal is high, the counter should reset to 0. The module should have the following ports:\n\n- `data_in`: a 4-bit input that is loaded into the counter when the load signal is high.\n- `load`: a 1-bit input that enables loading of `data_in` into the counter.\n- `reset`: a 1-bit input that resets the counter to 0.\n- `clock`: a 1-bit input that serves as the clock signal.\n- `count_out`: a 4-bit output that represents the current value of the counter.\n\nYou are allowed to use any verilog constructs or modules, except for pre-defined counters or memory modules.\n\n", "output": "module sync_counter (\n    data_in,\n    load,\n    reset,\n    clock,\n    count_out\n);\n\n    input [3:0] data_in;\n    input load, reset, clock;\n    output reg [3:0] count_out;\n\n    always @(posedge clock) begin\n        if (reset) begin\n            count_out <= 4'b0;\n        end else if (load) begin\n            count_out <= data_in;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a circuit that takes in four inputs, A1, A2, B1, and B2, and outputs a single bit X. The circuit will also have four additional inputs, VPWR, VGND, VPB, and VNB, which will be used to power the circuit and provide reference voltages. \n\nYour module should be named \"four_to_one_circuit\" and should be no longer than 200 lines of Verilog code. The circuit should operate as follows:\n\n- If A1 and A2 are both 0, and B1 and B2 are both 0, then X should be 0.\n- If A1 and A2 are both 0, and B1 and B2 are both 1, then X should be 1.\n- If A1 and A2 are both 1, and B1 and B2 are both 0, then X should be 1.\n- If A1 and A2 are both 1, and B1 and B2 are both 1, then X should be 0.\n\nYour module should be properly instantiated and connected to the inputs and outputs as follows:\n\n- The output X should be of type output.\n- The inputs A1, A2, B1, B2, VPWR, VGND, VPB, and VNB should be of type input.\n- The inputs A1, A2, B1, and B2 should be connected to wires of the same name within the module.\n- The inputs VPWR, VGND, VPB, and VNB should be connected to wires of the same name within the module.\n\nYour module should be designed to be synthesizable and should be able to be implemented on an FPGA.\n\n", "output": "module four_to_one_circuit (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  B2  ,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    wire not_A1, not_A2, not_B1, not_B2;\n\n    assign not_A1 = ~A1;\n    assign not_A2 = ~A2;\n    assign not_B1 = ~B1;\n    assign not_B2 = ~B2;\n\n    wire and1, and2, or1;\n\n    assign and1 = not_A1 & not_A2 & not_B1 & B2;\n    assign and2 = A1 & A2 & not_B1 & not_B2;\n    assign or1 = and1 | and2;\n\n    assign X = ~or1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 2-input AND gate that operates on a clocked input. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: clock input\n- `a`: first input\n- `b`: second input\n\nOutputs:\n- `out`: output of the AND gate\n\nThe output of the AND gate should only update on the rising edge of the clock input. The module should also have a reset input `rst` that asynchronously resets the output to 0.\n\nWrite a verilog module that meets these specifications and is no more than 200 lines of code.\n\n", "output": "module and_gate(clk, rst, a, b, out);\n    input clk, rst, a, b;\n    output reg out;\n\n    always @(posedge clk or negedge rst) begin\n        if(rst == 0) begin\n            out <= 0;\n        end else begin\n            out <= a & b;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 4-bit adder-subtractor. The module should have four inputs: two 4-bit numbers (A and B), a control signal (sub), and a clock signal (clk). The module should have two outputs: a 4-bit result (out) and a carry-out bit (cout).\n\nIf the sub control signal is 0, the module should add the two input numbers (A and B) and output the result (out) and the carry-out bit (cout). If the sub control signal is 1, the module should subtract B from A and output the result (out) and the carry-out bit (cout).\n\nThe module should operate on the rising edge of the clock signal (clk). The module should also include a reset input (rst) that sets the output to 0 and the carry-out bit to 0 when asserted.\n\nYou are not allowed to use any built-in Verilog operators or functions to implement the adder-subtractor. You must use only basic gates (AND, OR, NOT, XOR, etc.) and/or other modules that you design.\n\nImplement the adder-subtractor module in Verilog and verify its correctness using a testbench.\n\n", "output": "module adder_subtractor (\n  input [3:0] A,\n  input [3:0] B,\n  input sub,\n  input clk,\n  input rst,\n  output [3:0] out,\n  output cout\n);\n\n  reg [3:0] A_inv;\n  reg [3:0] B_inv;\n  reg [3:0] sum;\n  reg carry;\n\n  // Invert B if subtracting\n  assign B_inv = sub ? ~B + 1 : B;\n\n  // Invert A if subtracting\n  assign A_inv = sub ? ~A : A;\n\n  // Full adder\n  always @(posedge clk) begin\n    if (rst) begin\n      sum <= 0;\n      carry <= 0;\n    end else begin\n      {carry, sum} <= A_inv + B_inv + carry;\n    end\n  end\n\n  // Output\n  assign out = sum;\n  assign cout = carry;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit ring counter. The module should have a single input, Clk, and four outputs, Q[3:0]. The counter should cycle through the four outputs, with only one output being high at any given time. The counter should wrap around from Q3 to Q0.", "output": "module ring_counter (\n    input Clk,\n    output reg [3:0] Q\n);\n\nalways @(posedge Clk) begin\n    Q <= {Q[2:0], Q[3]};\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an asynchronous reset release circuit. \nAn asynchronous reset release circuit is a type of digital circuit that is used to release a reset signal asynchronously.\nThe inputs to the circuit are the reset signal (reset) and the clock signal (clk). The output of the circuit is the released reset signal (rst).\nYour module should have the following inputs and outputs:\n\nInputs: reset, clk\nOutputs: rst\n\nYour module should implement the following functionality:\n\nWhen the reset signal is active (e.g., low), the released reset signal should be inactive (e.g., high).\nWhen the reset signal is released (e.g., high), the released reset signal should be active (e.g., low) for a specified period of time (e.g., 10 clock cycles) and then become inactive again.\nThe released reset signal should only be active for the specified period of time after the reset signal is released. It should not be affected by any subsequent resets or clock cycles.\n\nTo implement the asynchronous reset release circuit, you should use Verilog code to define the behavior of the released reset signal based on the reset and clock signals. \nYou should use a counter to count the number of clock cycles since the reset signal was released, and use this counter to determine when to release the reset signal.", "output": "module async_reset_release (\n  input reset,\n  input clk,\n  output rst\n);\n\n  reg [3:0] counter;\n  reg rst_active;\n\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      counter <= 0;\n      rst_active <= 1'b1;\n    end else begin\n      if (counter == 4'd10) begin\n        rst_active <= 1'b0;\n      end else begin\n        counter <= counter + 1;\n      end\n    end\n  end\n\n  assign rst = rst_active;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that performs a specific logic function. The module should have three input ports (`A`, `B`, `Ci`) and two output ports (`S`, `Co`). The module should implement the following logic function:\n```\nS = (A XNOR B) XNOR Ci\nCo = (A NAND B) NAND (A NAND Ci) NAND (B NAND Ci)\n```\nwhere `XNOR` represents the exclusive-NOR operation and `NAND` represents the logical NAND operation.\n\nDesign a Verilog module that implements the above logic function. Your module should be self-contained and should not rely on any external modules or libraries. Your module should be named `logic_function` and should have the following ports:\n- `A`: a 1-bit input port\n- `B`: a 1-bit input port\n- `Ci`: a 1-bit input port\n- `S`: a 1-bit output port\n- `Co`: a 1-bit output port\n\nYour module should be implemented within 200 lines of Verilog code.\n\n", "output": "module logic_function (A, B, Ci, S, Co);\n  input A, B, Ci;\n  output S, Co;\n  wire   n10, n11, n12;\n\n  // XNOR2_X1 U1 ( .A(Ci), .B(n12), .ZN(S) );\n  assign n12 = ~(A ^ B);\n  assign S = ~(n12 ^ Ci);\n\n  // NAND2_X1 U3 ( .A1(n11), .A2(n10), .ZN(Co) );\n  assign n10 = ~(A & B);\n  assign n11 = ~(A & Ci);\n  assign Co = ~(n10 & n11);\n\n  // XNOR2_X1 U2 ( .A(B), .B(A), .ZN(n12) );\n  // NAND2_X1 U4 ( .A1(A), .A2(B), .ZN(n10) );\n  // OAI21_X1 U5 ( .B1(A), .B2(B), .A(Ci), .ZN(n11) );\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 8-bit comparator. The module should have two 8-bit inputs and one output. If the first input is greater than the second input, the output should be high. Otherwise, the output should be low.", "output": "module comparator_8bit (\n    input [7:0] in0,\n    input [7:0] in1,\n    output reg out\n);\n\nalways @(*) begin\n    if (in0 > in1)\n        out = 1;\n    else\n        out = 0;\nend\n\nendmodule"}
{"instruction": "Design a module that implements a NOT gate. The module should have one input port and one output port. However, you are only allowed to use NAND gates to implement this NOT gate.", "output": "module not_gate_using_nand(input in, output out);\n  wire nand_out;\n  assign nand_out = ~(in & in);\n  assign out = nand_out;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-to-1 multiplexer using only basic logic gates (AND, OR, NOT). The module should have four 32-bit input ports (A, B, C, D) and a 2-bit select port (S). The output should be the selected input, based on the value of the select port: if S=00, output A; if S=01, output B; if S=10, output C; if S=11, output D.\n\nYour module should be named \"mux_4to1\" and should not use any pre-existing Verilog libraries or modules. You may use any temporary variables or internal signals that you require.\n\nEnsure that your module is completely self-contained and works correctly for all possible input combinations.\n\n", "output": "module mux_4to1(\n  input [31:0] A,\n  input [31:0] B,\n  input [31:0] C,\n  input [31:0] D,\n  input [1:0] S,\n  output reg [31:0] Y\n);\n\n  always @(*) begin\n    case(S)\n      2'b00: Y = A;\n      2'b01: Y = B;\n      2'b10: Y = C;\n      2'b11: Y = D;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a module that takes in a 4-bit input signal `V` and outputs a 4-bit signal `A`. The module should be named `circuitA`. The output `A` is determined by the following rules:\n\n- The least significant bit of `A` is equal to the least significant bit of `V`.\n- The second least significant bit of `A` is the logical NOT of the second least significant bit of `V`.\n- The third least significant bit of `A` is determined by the following logic expression: `((NOT V[3]) AND (NOT V[1])) OR ((V[2]) AND (V[1]))`.\n- The most significant bit of `A` is determined by the following logic expression: `(NOT V[3]) AND (V[1])`.\n\nWrite a Verilog module that implements this logic and test your module with the provided testbench.\n\n", "output": "module circuitA (input [3:0] V, output [3:0] A);\n  assign A[0] = V[0];\n  assign A[1] = ~V[1];\n  assign A[2] = (~V[3] & ~V[1]) | (V[2] & V[1]);\n  assign A[3] = (~V[3] & V[1]);\nendmodule"}
{"instruction": "\n\nYou have been provided with a Verilog module, `flop_gated_flop`, which contains a sequential logic circuit. The module has three inputs, `d`, `clk`, and `en`, and one output, `q`. The module also has a wire `gated_clock` which is driven by another module, `clock_gate_flop`. The `flop_gated_flop` module contains an always block that is sensitive to the positive edge of `gated_clock`. The functionality of the module is such that when `en` is high, the `d` input is sampled on the positive edge of `gated_clock` and the value is stored in `q`. \n\nYour task is to implement the `clock_gate_flop` module, which takes in the `clk` and `en` signals and generates a gated clock signal that is high only when `en` is high. You need to implement the `clock_gate_flop` module using a single always block.\n\nWrite the Verilog code for the `clock_gate_flop` module.\n\n", "output": "module clock_gate_flop(gated_clk, clk, en);\n  input clk, en;\n  output reg gated_clk;\n  \n  always @(posedge clk) begin\n    if (en) begin\n      gated_clk <= 1'b1;\n    end\n    else begin\n      gated_clk <= 1'b0;\n    end\n  end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit adder/subtractor. The module should have two 4-bit inputs, A and B, and a control input, C, which determines whether the module should perform addition or subtraction. The module should output a 4-bit sum, S, and a carry-out signal, Cout.\n\nThe module should be designed to be synthesizable and should be no more than 200 lines of Verilog code. You may use any standard Verilog constructs, including if/else statements and for loops.\n\nAssume that the inputs A and B are always valid 4-bit values and that the control input C will be either 0 or 1.\n\nYou should also ensure that your module is named \"adder_subtractor\" and has the following ports:\n\n- input [3:0] A\n- input [3:0] B\n- input C\n- output [3:0] S\n- output Cout\n\n", "output": "module adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input C,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] B_comp;\n    wire [3:0] temp_sum;\n    wire temp_carry;\n\n    assign B_comp = ~B + 1;\n\n    assign temp_sum = (C == 0) ? A + B : A + B_comp;\n    assign Cout = (C == 0 && temp_sum[4]) || (C == 1 && !temp_sum[4]);\n    assign S = temp_sum[3:0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements clock gating cells. \nClock gating is a technique used to reduce power consumption in digital circuits by selectively turning off the clock to certain parts of the circuit when they are not needed. \nThe clock gating cells are used to enable or disable the clock to a specific set of logic gates or flip-flops in the circuit. \nYour module should have the following inputs and outputs:\n\nInputs: \n- clk: the system clock signal\n- enable: the enable signal to control the clock gating\nOutputs:\n- gated_clk: the gated clock signal to be used by the specific set of logic gates or flip-flops\n\nYour module should implement the following functionality:\n- When the enable signal is high, the clock signal should be passed through to the gated_clk output.\n- When the enable signal is low, the clock signal should be blocked and the gated_clk output should remain at its previous state.\n\nTo implement the clock gating cells, you should use Verilog code to define a multiplexer to select between the clock signal and a constant value (0 or 1) depending on the enable signal. \nYou should then use this multiplexer to connect the input clock signal to the output gated_clk signal. \nYou should also add a flip-flop to store the previous state of the gated_clk signal when the enable signal is low, so that the output remains stable.", "output": "module clock_gating_cells (\n  input clk,\n  input enable,\n  output gated_clk\n);\n\n  reg gated_clk_reg;\n\n  always @(posedge clk) begin\n    if (enable) begin\n      gated_clk_reg <= 1'b1;\n    end else begin\n      gated_clk_reg <= gated_clk;\n    end\n  end\n\n  assign gated_clk = enable ? clk : gated_clk_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements logic gates including AND, OR, NOT, XOR, and XNOR gates. \nThe inputs and outputs of the module should vary depending on the type of gate being implemented. \n\nFor the AND, OR, XOR, and XNOR gates, the module should have the following inputs and outputs:\n\nInputs: two input signals (a and b)\nOutputs: one output signal (c)\n\nFor the NOT gate, the module should have the following inputs and outputs:\n\nInputs: one input signal (a)\nOutputs: one output signal (b)\n\nYour module should implement the following functionality:\n\nThe AND gate should output a logical 1 if both inputs are 1, and a logical 0 otherwise.\nThe OR gate should output a logical 1 if either input is 1, and a logical 0 otherwise.\nThe NOT gate should output the logical complement of the input signal.\nThe XOR gate should output a logical 1 if the inputs are different, and a logical 0 otherwise.\nThe XNOR gate should output a logical 1 if the inputs are the same, and a logical 0 otherwise.\n\nTo implement the logic gates, you should use Verilog code to define the Boolean functions of the input signals. \nYou should then use these functions to connect the inputs to the appropriate gates and compute the output signals.", "output": "module logic_gates (\n  input a,\n  input b,\n  output c\n);\n\n// AND gate\nand gate_and (a, b, c);\n\n// OR gate\nor gate_or (a, b, c);\n\n// NOT gate\nnot gate_not (a, c);\n\n// XOR gate\nxor gate_xor (a, b, c);\n\n// XNOR gate\nxnor gate_xnor (a, b, c);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 4-to-1 multiplexer using verilog. The module should have four input signals, `A`, `B`, `C`, and `D`, and two select signals, `S0` and `S1`. The output signal, `Y`, should be selected based on the values of `S0` and `S1` as follows:\n\n- If `S0` and `S1` are both 0, `Y` should be equal to `A`.\n- If `S0` is 0 and `S1` is 1, `Y` should be equal to `B`.\n- If `S0` is 1 and `S1` is 0, `Y` should be equal to `C`.\n- If `S0` and `S1` are both 1, `Y` should be equal to `D`.\n\nThe module should also have two power supply signals, `VPWR` and `VGND`, and two bias signals, `VPB` and `VNB`, which are not used in the module.\n\nYour task is to complete the verilog module `mux4to1`, which should implement the 4-to-1 multiplexer functionality described above.\n\n", "output": "module mux4to1 (\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    S0  ,\n    S1  ,\n    Y   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  S0  ;\n    input  S1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign Y = (S1 & S0) ? D :\n               (S1 & ~S0) ? C :\n               (~S1 & S0) ? B :\n               A;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module for a simple calculator that can perform basic arithmetic operations (addition, subtraction, multiplication, and division) on two 8-bit numbers. The module should have the following inputs and outputs:\n- Inputs: \n    - `op`: a 2-bit signal that specifies the operation to be performed (00 for addition, 01 for subtraction, 10 for multiplication, and 11 for division)\n    - `num1`: an 8-bit signal that represents the first number in the operation\n    - `num2`: an 8-bit signal that represents the second number in the operation\n- Outputs:\n    - `result`: an 8-bit signal that represents the result of the operation\n\nYour module should be named `simple_calculator` and should be written in Verilog. The module should only use combinational logic (no registers or state machines). You can assume that the inputs will always be valid (i.e. no divide by zero).\n\n", "output": "module simple_calculator(\n    input [1:0] op,\n    input [7:0] num1,\n    input [7:0] num2,\n    output [7:0] result\n);\n\nwire [15:0] temp;\n\nassign temp = {op, num1} * {op[0], num2};\nassign result = (op == 2'b00) ? num1 + num2 :\n                (op == 2'b01) ? num1 - num2 :\n                (op == 2'b10) ? temp[15:8] :\n                (op == 2'b11) ? (temp[15:8] == 8'h00) ? 8'h00 : temp[15:8] / num2 :\n                                8'h00;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that takes in a 4-bit input and outputs a 3-bit binary number representing the number of even bits in the input. For example, if the input is 0b1101, the output should be 0b001. The module should contain a 4-bit register with active high synchronous reset that stores the input value. The reset value should be set to 0x00. Additionally, the module should include an output module that outputs the binary value of the number of even bits in the input. The output should also be stored in the register. The module should be triggered on the negative edge of the clock.", "output": "module even_bits_counter (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [3:0] in,\n    output reg [2:0] out\n);\n\nreg [3:0] reg_in;\n\nalways @(negedge clk) begin\n    if (reset) begin\n        reg_in <= 4'b0000;\n        out <= 3'b000;\n    end\n    else begin\n        reg_in <= in;\n        out <= {reg_in[0]^reg_in[1]^reg_in[2]^reg_in[3], reg_in[1]^reg_in[2]^reg_in[3], reg_in[2]^reg_in[3]};\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that takes in a 16-bit input `Din` and outputs the 5-bit slice of bits 12 to 8 of the input as `Dout`. You are to implement this module in no more than 200 lines of Verilog code.\n\nYour module should be named `slice_module` and should have the following inputs and outputs:\n- `Din` : a 16-bit input\n- `Dout` : a 5-bit output\n\nYou should ensure that your module has the following characteristics:\n- It should have a single always block.\n- The always block should have a sensitivity list that includes only the input `Din`.\n- The output `Dout` should be assigned within the always block.\n\nYou should assume that the input `Din` is a valid 16-bit binary number.\n\n", "output": "module slice_module\n   (Din,\n    Dout);\n  input [15:0]Din;\n  output [4:0]Dout;\n\n  always @(Din) begin\n    Dout[4:0] = Din[12:8];\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a combinational circuit that performs 3-bit parity checking. The circuit should have 3 input bits and 1 output bit. The output bit should be set to 1 if the input bits have an odd number of 1's, otherwise, it should be set to 0.", "output": "module parity_checker (\n  input [2:0] data,\n  output reg parity\n);\n  \n  always @(*) begin\n    parity = (data[0] ^ data[1] ^ data[2]);\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a D flip-flop with asynchronous preset functionality. The module should have the following inputs and outputs:\n\n- `D`: a single-bit input that represents the data to be stored in the flip-flop.\n- `C`: a single-bit input that represents the clock signal.\n- `PRE`: a single-bit input that represents the asynchronous preset signal.\n- `Q`: a single-bit output that represents the stored data in the flip-flop.\n\nThe module should operate as follows:\n\n- When the `PRE` signal is high, the output `Q` should be set to high, regardless of the values of `D` and `C`.\n- When the `PRE` signal is low and the `C` signal transitions from low to high (i.e., on the rising edge of `C`), the output `Q` should be set to the value of `D`.\n- The output `Q` should maintain its value when the `C` signal is low.\n\nYour task is to implement the Verilog module for this D flip-flop with asynchronous preset functionality. Your module should be named `d_ff_pre` and should be self-contained within 200 lines of Verilog code. You may assume that the inputs `D`, `C`, and `PRE` are valid and will not change more than once per clock cycle.\n\n", "output": "module d_ff_pre (\n  input wire D,\n  input wire C,\n  input wire PRE,\n  output reg Q\n);\n\n  always @ (posedge C or posedge PRE) begin\n    if (PRE) begin\n      Q <= 1'b1;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that can perform a simple arithmetic operation. Your module should have two inputs, `a` and `b`, and one output, `c`. The input `a` is an 8-bit unsigned integer, while `b` is a 4-bit unsigned integer. The output `c` is a 12-bit unsigned integer.\n\nYour module should be able to perform the following arithmetic operation: \n\n`c = a + (b << 8)`\n\nIn other words, your module should take the value of `a` and add it to the value of `b` shifted left by 8 bits. The result should then be stored in `c`.\n\nYou should assume that the values of `a` and `b` will be updated on every rising edge of the clock signal. You should also assume that the reset signal will be active-high, and that the output `c` should be set to 0 when the reset signal is asserted.\n\nYour module should be implemented within 200 lines of verilog code.\n\n", "output": "module arithmetic_operation(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [3:0] b,\n    output reg [11:0] c\n);\n\nalways @(posedge clk) begin\n    if(rst) begin\n        c <= 0;\n    end else begin\n        c <= a + (b << 8);\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that calculates the sum of a set of input numbers. Your module should be able to handle a variable number of inputs, and should output the sum of all inputs. Assume that all inputs are positive integers, and that the sum of all inputs will not exceed the maximum value of a 32-bit integer.\n\nYour module should have the following inputs and outputs:\n- `clk`: a clock signal\n- `rst`: a reset signal\n- `in`: an input bus that accepts a variable number of 32-bit integers\n- `in_valid`: a 1-bit input signal that indicates when a new set of inputs is available\n- `out`: a 32-bit output signal that represents the sum of all inputs\n- `out_valid`: a 1-bit output signal that indicates when the output is valid\n\nYour module should meet the following requirements:\n- When `in_valid` is high, your module should begin summing the inputs on the `in` bus.\n- When the sum is complete, your module should set `out_valid` high and output the sum on the `out` signal.\n- If `in_valid` goes low before the sum is complete, your module should stop summing and set `out_valid` low.\n- Your module should reset to a known state when `rst` is high.\n\nYour module should be implemented in Verilog within 200 lines of code.\n\n", "output": "module sum_module (\n    input clk,\n    input rst,\n    input [31:0] in,\n    input in_valid,\n    output reg [31:0] out,\n    output reg out_valid\n);\n\nreg [31:0] sum;\nreg [31:0] count;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sum <= 0;\n        count <= 0;\n        out_valid <= 0;\n    end else if (in_valid) begin\n        sum <= sum + in;\n        count <= count + 1;\n    end else if (count > 0) begin\n        out <= sum;\n        out_valid <= 1;\n        sum <= 0;\n        count <= 0;\n    end else begin\n        out_valid <= 0;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a digital delay line. \nA digital delay line is a type of digital circuit that delays the input signal by a certain number of clock cycles. \nThe delay time can be adjusted by changing the number of clock cycles.\n\nYour module should have the following inputs and outputs:\nInputs: \n- clk: the clock signal that drives the delay line\n- rst: the reset signal that resets the delay line\n- din: the input signal that is delayed\nOutputs: \n- dout: the delayed output signal\n\nYour module should also have the following parameters:\n- delay: the number of clock cycles by which the input signal is delayed\n\nYour module should implement the following functionality:\n- On the rising edge of the clock signal, the input signal (din) should be sampled and stored in a shift register.\n- The output signal (dout) should be the value that was stored in the shift register delay clock cycles ago.\n- The delay time should be adjustable by changing the value of the parameter \"delay\".\n- When the reset signal (rst) is asserted, the shift register should be cleared and the output signal should be set to 0.\n\nTo implement the digital delay line, you should use Verilog code to define a shift register and connect it to the input and output signals. \nYou should then use the clock signal to control the shift register, and the reset signal to clear the shift register and the output signal.\nFinally, you should use the parameter \"delay\" to determine the number of clock cycles by which the input signal is delayed.", "output": "module delay_line (\n  input clk,\n  input rst,\n  input din,\n  output dout\n);\n\nparameter delay = 3; // number of clock cycles of delay\n\nreg [delay-1:0] shift_reg;\nreg [delay-1:0] delayed_out;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    shift_reg <= 0;\n    delayed_out <= 0;\n  end else begin\n    shift_reg <= {din, shift_reg[delay-2:0]};\n    delayed_out <= shift_reg[delay-1:0];\n  end\nend\n\nassign dout = delayed_out;\n\nendmodule"}
{"instruction": "\n\nIn digital electronics, a Gray code is a binary numeral system where two successive values differ in only one bit. This is useful in applications such as shaft encoders and digital potentiometers, where a small change in the input should result in a small change in the output. \n\nYou are tasked with designing a Gray code counter module that takes in a clock signal, a reset signal, and an enable signal, and outputs the Gray code count. The counter should start at 1 and increment by 1 for each clock cycle when the enable signal is high. When the reset signal is high, the counter should reset to 1. The counter should output a Gray code, not a binary code.\n\nYour task is to implement the `graycounter` module in Verilog, which takes in the following inputs:\n- `Clk`: the clock signal\n- `Clear_in`: the reset signal\n- `Enable_in`: the enable signal\n\nAnd produces the following output:\n- `GrayCount_out`: the Gray code count output\n\nYou may assume that the counter width is 4 bits.\n\n", "output": "module graycounter (\n    input wire Clk,\n    input wire Clear_in,\n    input wire Enable_in,\n    output reg [3:0] GrayCount_out\n);\n\n    reg [3:0] BinaryCount; // binary count\n    \n    always @(posedge Clk) begin\n        if (Clear_in) begin\n            BinaryCount <= 4'b0001;\n            GrayCount_out <= 4'b0000;\n        end\n        else if (Enable_in) begin\n            BinaryCount <= BinaryCount + 1;\n            GrayCount_out <= {BinaryCount[3], BinaryCount[3] ^ BinaryCount[2], BinaryCount[2] ^ BinaryCount[1], BinaryCount[1] ^ BinaryCount[0]};\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in five inputs and produces one output. The inputs are T0, T1, SCLK, ECLK, DQSW270, and RST. The output is Q. The module should have two parameters, GSR and REGSET, with values \"ENABLED\" and \"SET\" respectively.\n\nYour task is to implement the module TSHX2DQA. The module should perform the following operations:\n\n- On the rising edge of SCLK, the module should sample the value of T0 and T1 and store them in a register.\n- On the rising edge of ECLK, the module should output the value of the register to Q.\n- On the rising edge of DQSW270, the module should reset the register to 0 if GSR is \"ENABLED\".\n- On the rising edge of RST, the module should reset the register to 0 if REGSET is \"SET\".\n\nPlease write the verilog code for the TSHX2DQA module that satisfies the above requirements.\n\n", "output": "module TSHX2DQA(\n\tinput T0, T1, SCLK, ECLK, DQSW270, RST,\n\toutput Q\n);\n\tparameter GSR = \"ENABLED\";\n\tparameter REGSET = \"SET\";\n\n\treg [1:0] t_reg;\n\treg [1:0] q_reg;\n\n\talways @(posedge SCLK) begin\n\t\tt_reg <= {T1, T0};\n\t\tif (DQSW270 && (GSR == \"ENABLED\")) begin\n\t\t\tq_reg <= 2'b0;\n\t\tend\n\tend\n\n\talways @(posedge ECLK) begin\n\t\tQ <= q_reg[1];\n\t\tq_reg <= {q_reg[0], t_reg[1]};\n\tend\n\n\talways @(posedge RST) begin\n\t\tif (REGSET == \"SET\") begin\n\t\t\tq_reg <= 2'b0;\n\t\tend\n\tend\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-to-1 multiplexer. The module should have four 8-bit input ports and one 8-bit output port. The module should also have two select input ports, S1 and S0, which select which input port to output on the output port. If S1S0 = 00, output the first input port on the output port. If S1S0 = 01, output the second input port on the output port. If S1S0 = 10, output the third input port on the output port. If S1S0 = 11, output the fourth input port on the output port.\n\n", "output": "module mux4to1(input [7:0] in1, in2, in3, in4, input [1:0] sel, output reg [7:0] out);\n\nalways @(*)\nbegin\n    case(sel)\n        2'b00: out = in1;\n        2'b01: out = in2;\n        2'b10: out = in3;\n        2'b11: out = in4;\n        default: out = 8'b0;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 16-bit memory with 4096 addressable locations. The module should have the following inputs and outputs:\n\n- `address` (12-bit input): the address of the memory location to read or write\n- `clock` (1-bit input): the clock signal\n- `data` (16-bit input): the data to be written to the memory location\n- `wren` (1-bit input): write enable signal. If `wren` is high, the module should write `data` to the memory location specified by `address`.\n- `q` (16-bit output): the data stored at the memory location specified by `address`\n\nYou must implement the memory using a single module with no more than 200 lines of Verilog code. Your module should be named `memory16`.\n\nAssume that the memory is initialized to all zeros when the module is first instantiated.\n\n", "output": "module memory16 (\n  input [11:0] address,\n  input clock,\n  input [15:0] data,\n  input wren,\n  output reg [15:0] q\n);\n\n  reg [15:0] memory [0:4095];\n\n  always @(posedge clock) begin\n    if (wren) begin\n      memory[address] <= data;\n    end\n    q <= memory[address];\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit barrel shifter. The module should have two inputs (A and B) and two outputs (S and C). A should be shifted left or right by the number of positions specified by B. If B is positive, A should be shifted left. If B is negative, A should be shifted right. The shifted value should be output on S. If the shift results in a carry out, it should be output on C.", "output": "module barrel_shifter (\n    input [3:0] A,\n    input [2:0] B,\n    output [3:0] S,\n    output C\n);\n\n    reg [3:0] temp;\n\n    always @(*) begin\n        if (B > 0) begin\n            temp = {A[B-1:0], 4'b0};\n            S = temp;\n            C = temp[3];\n        end else begin\n            temp = {4'b0, A[-B-1:0]};\n            S = temp;\n            C = temp[0];\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit up/down counter with asynchronous reset and load inputs. The module should have four inputs: clk (1-bit input), reset (1-bit input), load (1-bit input), and direction (1-bit input). The module should have one output: count (4-bit output). When reset is high, the count should be reset to zero. When load is high, the count should be set to the value of an input data_in (4-bit input). When direction is high, the count should increment on each clock cycle, and when direction is low, the count should decrement on each clock cycle.", "output": "module up_down_counter (\n    input clk,\n    input reset,\n    input load,\n    input direction,\n    input [3:0] data_in,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            count <= 4'b0000;\n        end else if (load == 0) begin\n            count <= data_in;\n        end else if (direction == 1) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with asynchronous reset using the sky130_fd_sc_ms__dfxtp module. The D flip-flop should have the following ports:\n- D: input port for the data\n- CLK: input port for the clock signal\n- Q: output port for the output data\n- RESET: input port for the asynchronous reset signal\n\nThe D flip-flop should operate on the rising edge of the clock signal. When the reset signal is asserted, the output should be set to 0.\n\nYou should write a Verilog module that implements the D flip-flop with asynchronous reset using the sky130_fd_sc_ms__dfxtp module. The module should be self-contained and should not exceed 200 lines of code.\n\n", "output": "module d_ff_async_reset (\n    input D,\n    input CLK,\n    input RESET,\n    output Q\n);\n\n    wire Q_int;\n    sky130_fd_sc_ms__dfxtp u1 (\n        .D(D),\n        .CLK(CLK),\n        .Q(Q_int)\n    );\n\n    assign Q = RESET ? 1'b0 : Q_int;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with creating a Verilog module that implements a 2-input AND gate with an additional input `C`. The output `Y` should be 1 only if both inputs `A` and `B` are 1 and `C` is 0. You are given the following code snippet as a starting point:\n\n```\nmodule sky130_fd_sc_ms__a2111oi_2 (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ms__a2111oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .C1(C1),\n        .D1(D1)\n    );\n\nendmodule\n```\n\nImplement the 2-input AND gate with an additional input `C` and ensure that the output `Y` is 1 only if both inputs `A` and `B` are 1 and `C` is 0. \n\n", "output": "module and_gate (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input A;\n    input B;\n    input C;\n\n    assign Y = (A & B & ~C);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a voltage level shifter. \nA voltage level shifter is a digital circuit that converts one voltage level to another voltage level. \nYour module should have the following inputs and outputs:\n\nInputs: a single input signal (in)\nOutputs: a single output signal (out)\n\nThe module should also have the following parameters:\nhigh_level: the high voltage level of the input signal\nlow_level: the low voltage level of the input signal\nout_high_level: the high voltage level of the output signal\nout_low_level: the low voltage level of the output signal\n\nYour module should implement the following functionality:\nThe circuit should convert the input signal from the input voltage level to the output voltage level.\nIf the input signal is at the high voltage level, the output signal should be at the high voltage level.\nIf the input signal is at the low voltage level, the output signal should be at the low voltage level.\nTo implement the voltage level shifter, you should use Verilog code to compare the input signal to the input voltage levels. \nIf the input signal is at the high voltage level, you should set the output signal to the high voltage level. \nIf the input signal is at the low voltage level, you should set the output signal to the low voltage level. \nFinally, you should assign the output signal to the output port.", "output": "module voltage_level_shifter(\n  input in,\n  output out\n);\n\nparameter high_level = 1.8;\nparameter low_level = 0.0;\nparameter out_high_level = 3.3;\nparameter out_low_level = 0.0;\n\n  assign out = (in > high_level) ? out_high_level : out_low_level;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that will take in 9 inputs and output a single value. The module should be named \"multi_input_output\" and should be written in Verilog. The inputs are as follows:\n- A 1-bit input named \"in1\"\n- A 2-bit input named \"in2\"\n- A 3-bit input named \"in3\"\n- A 4-bit input named \"in4\"\n- A 5-bit input named \"in5\"\n- A 6-bit input named \"in6\"\n- A 7-bit input named \"in7\"\n- A 8-bit input named \"in8\"\n- A 9-bit input named \"in9\"\n\nThe output is a 10-bit value named \"out\". The module should use the following logic to calculate the output:\n- If in1 is 0, out should be the sum of in2 and in3\n- If in1 is 1, out should be the bitwise OR of in4 and in5, shifted left by 1 bit\n- If in6 is greater than or equal to in7, out should be the bitwise XOR of in8 and in9\n- If in6 is less than in7, out should be the bitwise AND of in8 and in9, shifted right by 1 bit\n\nYou should ensure that the module is self-contained and does not require any other modules to function.\n\n", "output": "module multi_input_output(\n    input in1,\n    input [1:0] in2,\n    input [2:0] in3,\n    input [3:0] in4,\n    input [4:0] in5,\n    input [5:0] in6,\n    input [6:0] in7,\n    input [7:0] in8,\n    input [8:0] in9,\n    output reg [9:0] out\n);\n\n    always @(*) begin\n        if (in1 == 1'b0) begin\n            out = {1'b0, in2 + in3};\n        end\n        else begin\n            out = {1'b0, (in4 | in5) << 1};\n        end\n        \n        if (in6 >= in7) begin\n            out = out ^ {1'b0, in8, in9};\n        end\n        else begin\n            out = {1'b0, (in8 & in9) >> 1};\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with asynchronous set and reset inputs. The module should have the following inputs and outputs:\n\n- `D`: the data input\n- `CLK`: the clock input\n- `SET_B`: asynchronous set input (active low)\n- `RESET_B`: asynchronous reset input (active low)\n- `Q`: the output\n- `Q_N`: the complement of the output\n\nThe module should follow the following behavior:\n\n- When `SET_B` is low, the output `Q` should be set to high and `Q_N` should be set to low, regardless of the state of the clock or data inputs.\n- When `RESET_B` is low, the output `Q` should be set to low and `Q_N` should be set to high, regardless of the state of the clock or data inputs.\n- When `SET_B` and `RESET_B` are both high, the output `Q` should follow the data input on the rising edge of the clock, and `Q_N` should be the complement of `Q`.\n\nDesign a module that meets the above requirements. You may assume that the inputs are glitch-free and that the clock has a 50% duty cycle.\n\n", "output": "module dff_sr (\n    input D,\n    input CLK,\n    input SET_B,\n    input RESET_B,\n    output reg Q,\n    output reg Q_N\n);\n\nalways @ (posedge CLK) begin\n    if (SET_B == 0) begin\n        Q <= 1;\n        Q_N <= 0;\n    end else if (RESET_B == 0) begin\n        Q <= 0;\n        Q_N <= 1;\n    end else begin\n        Q <= D;\n        Q_N <= ~D;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements an 8-bit bidirectional data port. The module should have two input ports, one for data input and the other for direction control. When the direction control input is 1, the data input should be assigned to the output port. Otherwise, the output port should be assigned to the data input in reverse order.", "output": "module bidirectional_data_port (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input direction_control,\n  output reg [7:0] data_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      data_out <= 8'b0;\n    end else if (direction_control) begin\n      data_out <= data_in;\n    end else begin\n      data_out <= {data_in[7], data_in[6], data_in[5], data_in[4], data_in[3], data_in[2], data_in[1], data_in[0]};\n    end\n  end\n\nendmodule\n"}
{"instruction": "\nYou are tasked with designing a Verilog module for an electronic buffer with a tri-state output. The module should have one input signal, `A`, and one output signal, `Z`. In addition, there should be a control signal, `TE_B`, which determines whether the output is enabled or disabled. When `TE_B` is high, `Z` should be in a high-impedance state, and when it is low, `Z` should reflect the value of `A`. \n\nThe module should be named `tri_buf` and should be contained within 200 lines of Verilog code. You may assume that the input signal `A` and the control signal `TE_B` are both 1-bit wide. \n\nYour task is to create the Verilog code for the `tri_buf` module that meets the above specifications.\n\n", "output": "module tri_buf (\n    input A,\n    output reg Z,\n    input TE_B\n);\n\n    always @ (TE_B) begin\n        if (TE_B) begin\n            Z <= 1'bz;\n        end else begin\n            Z <= A;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-to-1 multiplexer. The module should have four input signals, two select signals, and one output signal. The output signal should be the value of the input signal selected by the select signals. The truth table for the module is as follows:\n\n| Select1 | Select0 | Input0 | Input1 | Input2 | Input3 | Output |\n|---------|---------|--------|--------|--------|--------|--------|\n|    0    |    0    |   X    |   X    |   X    |   X    |   X    |\n|    0    |    1    |   I0   |   I1   |   X    |   X    |   Y    |\n|    1    |    0    |   X    |   X    |   I2   |   I3   |   Y    |\n|    1    |    1    |   X    |   X    |   X    |   X    |   X    |\n\nWhere X represents a don't care value.\n\nDesign a verilog module for the 4-to-1 multiplexer that meets the above requirements.\n\n", "output": "module MUX4X1 (\n    input [3:0] input_signals,\n    input [1:0] select_signals,\n    output reg output_signal\n);\n\nalways @ (*)\nbegin\n    case ({select_signals})\n        2'b00: output_signal = input_signals[0];\n        2'b01: output_signal = input_signals[1];\n        2'b10: output_signal = input_signals[2];\n        2'b11: output_signal = input_signals[3];\n        default: output_signal = 1'bx;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a D flip flop with a negative edge triggered clock and an asynchronous reset \"ar\". In addition, add a synchronous set \"s\" input to the module, which sets the output \"q\" to 1 when s=1 and the clock is low.", "output": "module flip_flop (\n  input clk,\n  input ar,\n  input s,\n  input d,\n  output reg q\n);\n\n  always @(negedge clk or posedge ar) begin\n    if (ar) begin\n      q <= 1'b0;\n    end else begin\n      if (s) begin\n        q <= 1'b1;\n      end else begin\n        q <= d;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder-subtractor. The module should have two 4-bit inputs, A and B, and a 1-bit input, SUB. When SUB is 0, the module should perform addition, and when SUB is 1, the module should perform subtraction. The module should output a 4-bit sum/difference, S, and a 1-bit overflow, OVF.\n\nYour module should be named \"adder_subtractor\" and should be contained within 200 lines of Verilog code. Your design should adhere to the following requirements:\n\n- Your design should use only basic Verilog constructs (i.e., no system tasks or functions).\n- You may use any combination of gates and flip-flops, but you may not use any pre-designed adder or subtractor modules.\n- Your design should be synthesizable and should not contain any latches or gated clocks.\n- Your design should be fully tested to ensure correct functionality.\n\n", "output": "module adder_subtractor(\n  input [3:0] A,\n  input [3:0] B,\n  input SUB,\n  output reg [3:0] S,\n  output reg OVF\n);\n\n  reg [3:0] B_neg;\n  reg C_in;\n  \n  always @ (A or B or SUB) begin\n    if (SUB == 1) begin\n      B_neg = ~B + 1;\n    end else begin\n      B_neg = B;\n    end\n  end\n  \n  always @ (A or B or SUB) begin\n    C_in = SUB & (A < B_neg);\n  end\n  \n  always @ (A or B or SUB) begin\n    if (SUB == 1) begin\n      S = A - B_neg;\n    end else begin\n      S = A + B;\n    end\n  end\n  \n  always @ (A or B or SUB) begin\n    OVF = C_in ^ (S[3] ^ A[3]);\n  end\n  \nendmodule"}
{"instruction": "\nYou are tasked to design a verilog module that implements a 4-bit shift register with parallel load. The module should have the following inputs and outputs:\n- `clk`: a clock input\n- `load`: a synchronous active-high input that loads the input data into the shift register on the rising edge of the clock\n- `in`: a 4-bit input that is loaded into the shift register when `load` is high\n- `shift`: a synchronous active-high input that shifts the data in the shift register one bit to the left on the rising edge of the clock\n- `out`: a 4-bit output that represents the current state of the shift register\n\nYou should implement the shift register using a behavioral description.\n\n", "output": "module shift_register(clk, load, in, shift, out);\n    input clk, load, shift;\n    input [3:0] in;\n    output [3:0] out;\n    reg [3:0] reg_out;\n    \n    always @(posedge clk) begin\n        if (load) begin\n            reg_out <= in;\n        end else if (shift) begin\n            reg_out <= {reg_out[2:0], 1'b0};\n        end\n    end\n    \n    assign out = reg_out;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 2-input buffer with a multi-cycle clock constraint. The module should have the following specifications:\n- The module name should be INBUF_MCCC\n- The module should have two input ports, PAD and CLK\n- The module should have one output port, Y\n- The module should have a parameter ACT_PIN that is a string and a parameter ACT_CONFIG that is a single bit\n- The module should be a black box with the PAD port being the black box pad pin\n- The module should be synthesized with a multi-cycle clock constraint\n\nWrite the verilog code for the INBUF_MCCC module that meets these specifications.\n\n", "output": "module INBUF_MCCC(\n    PAD,\n    CLK,\n    Y\n);\n\n/* synthesis syn_black_box */\n/* synthesis black_box_pad_pin =\"PAD\" */\n/* synthesis multicycle_pulse = CLK */\n\ninput PAD;\ninput CLK;\noutput Y;\n\nparameter ACT_PIN = \"\";\nparameter ACT_CONFIG = 1'b0;\n\nassign Y = PAD;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple calculator that can perform addition and subtraction operations on two 8-bit numbers. The module should have two input ports, `A` and `B`, each of which is an 8-bit unsigned integer, and an output port `C`, which is also an 8-bit unsigned integer. Additionally, the module should have a control input port `OP`, which is a single bit that determines the operation to be performed. If `OP` is 0, the module should perform addition; if `OP` is 1, the module should perform subtraction.\n\nYour task is to implement the Verilog module for this calculator. Your module should be named `calc` and should be contained within 200 lines of Verilog code. Your module should take inputs `A`, `B`, and `OP` and output the result of the operation in `C`. You should assume that the inputs are valid 8-bit unsigned integers and that the output will not overflow.\n\n", "output": "module calc(\n  input [7:0] A,\n  input [7:0] B,\n  input OP,\n  output [7:0] C\n);\n\n  wire [7:0] sum;\n  wire [7:0] diff;\n\n  assign sum = A + B;\n  assign diff = A - B;\n\n  assign C = OP ? diff : sum;\n\nendmodule"}
{"instruction": "\nCreate a Verilog module that performs 4:1 multiplexing. The module should have four data inputs, one output, and four select inputs. The size of the data inputs should be parameterized, and the select inputs should be single-bit inputs. The output should be the selected data input based on the select inputs. \n\nWrite a Verilog module that performs the following operations:\n- The module should be named \"mux4\".\n- The module should have the following inputs:\n  - Four data inputs: in0, in1, in2, in3 (each of size DW, where DW is a parameter).\n  - Four select inputs: sel0, sel1, sel2, sel3 (each of size 1).\n- The module should have one output:\n  - One data output: out (of size DW).\n- The module should use bitwise AND and OR operations to select the appropriate data input based on the select inputs.\n- The module should be parameterized with a value for DW (data width).\n- The module should be self-contained and should not use any other modules.\n\n", "output": "module mux4(\n   // Outputs\n   output reg [DW-1:0] out,\n   // Inputs\n   input [DW-1:0]  in0,\n   input [DW-1:0]  in1,\n   input [DW-1:0]  in2,\n   input [DW-1:0]  in3,\n   input           sel0,\n   input           sel1,\n   input           sel2,\n   input           sel3\n   );\n\n   parameter DW=99;\n  \n   always @(*) begin\n      out = ({(DW){sel0}} & in0 |\n             {(DW){sel1}} & in1 |\n             {(DW){sel2}} & in2 |\n             {(DW){sel3}} & in3);\n   end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a 4-bit adder-subtractor module that can perform both addition and subtraction operations based on a control signal. The module should have three inputs: two 4-bit operands (A and B), a control signal (ctrl), and one output (result). If ctrl is 0, the module should perform addition and the output should be the sum of A and B. If ctrl is 1, the module should perform subtraction and the output should be A minus B. You can use either a combinational always block or a clocked always block to implement the module.", "output": "module add_sub_4bit (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  input ctrl,\n  output [3:0] result\n);\n\n  reg [3:0] temp_result;\n  \n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      temp_result <= 4'b0000;\n    end else begin\n      if (ctrl == 0) begin\n        temp_result <= A + B;\n      end else begin\n        temp_result <= A - B;\n      end\n    end\n  end\n  \n  assign result = temp_result;\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 2-bit counter with synchronous reset functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: a clock signal\n- `RESET_B`: an active low synchronous reset signal\n\nOutputs:\n- `Q`: a 2-bit output representing the current count value\n\nThe counter should increment on the rising edge of the clock signal and reset to 0 on the rising edge of the reset signal. The counter should count in the following sequence: 00, 01, 10, 11, 00, ...\n\nYou can use the following code snippet as a starting point:\n\n```\nmodule counter_2bit (\n    Q      ,\n    CLK    ,\n    RESET_B\n);\n\n    // Module ports\n    output reg [1:0] Q      ;\n    input  CLK            ;\n    input  RESET_B        ;\n\n    // Your code here\n\nendmodule\n```\n\n", "output": "module counter_2bit (\n    Q      ,\n    CLK    ,\n    RESET_B\n);\n\n    // Module ports\n    output reg [1:0] Q      ;\n    input  CLK            ;\n    input  RESET_B        ;\n\n    // Local signals\n    reg [1:0] next_Q;\n\n    // Counter logic\n    always @(posedge CLK, negedge RESET_B) begin\n        if (~RESET_B) begin\n            Q <= 2'b00;\n        end else begin\n            next_Q <= Q + 1;\n            if (next_Q == 2'b11) begin\n                Q <= 2'b00;\n            end else begin\n                Q <= next_Q;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 16x32 dual-port RAM. The RAM should have two clock inputs, one for write operations and one for read operations. The module should have the following inputs and outputs:\n\nInputs:\n- `data` (16-bit): data to be written to the RAM\n- `wren` (1-bit): write enable signal\n- `wraddress` (5-bit): write address\n- `rdaddress` (5-bit): read address\n- `wrclock` (1-bit): write clock\n- `rdclock` (1-bit): read clock\n\nOutputs:\n- `q` (16-bit): data read from the RAM\n\nThe RAM should be implemented using an array of registers. The write operation should only occur when `wren` is high and the write clock (`wrclock`) is positive edge-triggered. The read operation should only occur when the read clock (`rdclock`) is positive edge-triggered. \n\nWrite the verilog code for the 16x32 dual-port RAM module.\n\n", "output": "module ram_16x32_dp\n\t(\n\tinput\t[15:0]\t\tdata,\n\tinput\t\t\twren,\n\tinput\t[4:0]\t\twraddress,\n\tinput\t[4:0]\t\trdaddress,\n\tinput\t\t\twrclock,\n\tinput\t\t\trdclock,\n\toutput\treg\t[15:0]\tq \n\t);\n\n\treg\t[15:0]\tmem_a [0:31];\n\n\talways @(posedge wrclock) begin\n\t\tif(wren) mem_a[wraddress] <= data;\n\tend\n\n\talways @(posedge rdclock) begin\n\t\tq <= mem_a[rdaddress];\n\tend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a current source and a current sink. \nA current source is a circuit element that provides a constant current to a load, while a current sink is a circuit element that absorbs a constant current from a source. \nYour module should have the following inputs and outputs:\n\nInputs: a single control signal (ctrl) to enable/disable the current source/sink\nOutputs: a single current signal (I) that represents the current provided/absorbed by the current source/sink\nThe module should also have the following parameters:\n\nI_src: the current provided by the current source (in Amperes)\nI_sink: the current absorbed by the current sink (in Amperes)\nYour module should implement the following functionality:\n\nWhen the control signal is high, the current source should provide a constant current I_src to the load.\nWhen the control signal is low, the current source should provide no current (i.e., the current should be zero).\nWhen the control signal is high, the current sink should absorb a constant current I_sink from the source.\nWhen the control signal is low, the current sink should absorb no current (i.e., the current should be zero).\nTo implement the current source and sink, you should use Verilog code to define the behavior of the module based on the value of the control signal. \nYou should then use this behavior to compute the current signal as a function of the control signal and the parameters I_src and I_sink.", "output": "module current_ctrl (\n  input ctrl,\n  output reg I\n);\n\nparameter I_src = 0.5; // current provided by the source (in Amperes)\nparameter I_sink = 0.3; // current absorbed by the sink (in Amperes)\n\n// implement current source and sink behavior\nalways @(*) begin\n  if (ctrl) begin\n    I = I_src;\n  end else begin\n    I = -I_sink;\n  end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit binary to Gray code converter. The module should have two input ports, an input binary number (bin) and a clock (clk), and one output port, the corresponding Gray code (gray). The module should be triggered on the positive edge of the clock. The output should be updated only when there is a change in the input binary number.", "output": "module bin2gray (\n  input clk,\n  input [3:0] bin,\n  output reg [3:0] gray\n);\n\nreg [3:0] prev_bin;\n\nalways @(posedge clk) begin\n  if (bin !== prev_bin) begin\n    gray[3] = bin[3];\n    gray[2] = bin[3] ^ bin[2];\n    gray[1] = bin[2] ^ bin[1];\n    gray[0] = bin[1] ^ bin[0];\n    prev_bin <= bin;\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a clock signal `clk`, a reset signal `reset`, an input signal `in`, and outputs a signal `p`. The module should have a delay of 250ns and should output `p` as high when the input signal `in` has been high for 12 clock cycles. \n\nWrite a verilog module that implements the above requirements. \n\n", "output": "module dly250ns(input clk, input reset, input in, output p);\n\treg [4-1:0] r;\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tr <= 0;\n\t\telse begin\n\t\t\tif(r)\n\t\t\t\tr <= r + 4'b1;\n\t\t\tif(in)\n\t\t\t\tr <= 1;\n\t\tend\n\tend\n\tassign p = r == 12;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder with carry-in and carry-out signals. The module should have two 4-bit inputs 'a' and 'b', one carry-in input 'cin', one sum output 's', and one carry-out output 'cout'. The module should use an always block to continuously perform the addition of 'a' and 'b' with the carry-in 'cin' and assign the sum to the output 's' and the carry-out to the output 'cout'.", "output": "module adder_4bit (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] s,\n  output cout\n);\n\n  reg [3:0] sum;\n  reg cout;\n\n  always @(*) begin\n    sum = a + b + cin;\n    cout = (sum[4] == 1) ? 1 : 0;\n  end\n\n  assign s = sum[3:0];\n  assign cout = cout;\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-bit shift register with parallel load. The module should have three inputs and one output:\n\n- `clk`: a clock input\n- `load`: a control input that loads the input data into the shift register when high\n- `in`: a 4-bit input that is loaded into the shift register when `load` is high\n- `out`: a 4-bit output that contains the current contents of the shift register\n\nThe shift register should shift its contents to the left on each clock cycle, with the most significant bit being lost and the least significant bit being shifted into a new position. When `load` is high, the contents of `in` should be loaded into the shift register and the shift register should stop shifting until `load` goes low again.\n\nWrite the verilog code for the shift register module.\n\n", "output": "module shift_register(clk, load, in, out);\ninput clk, load;\ninput [3:0] in;\noutput [3:0] out;\nreg [3:0] reg_out;\n\nalways @(posedge clk) begin\n    if (load) begin\n        reg_out <= in;\n    end else begin\n        reg_out <= {reg_out[2:0], 1'b0};\n    end\nend\n\nassign out = reg_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in verilog that takes in a single input signal A and outputs a single signal X. In addition, the module should have four voltage supply signals: VPWR, VGND, VPB, and VNB. \n\nThe input signal A is a single bit, and the output signal X should be a single bit as well. The voltage supply signals are used to provide power and ground to the circuit.\n\nDesign a verilog module that meets these specifications. Your module should be no longer than 200 lines of code.\n\n", "output": "module sky130_fd_sc_ls__dlymetal6s6s (\n    input  A,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Output logic\n    assign X = A;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 5 inputs and produces 1 output. The inputs are labeled A1, A2, A3, B1, and B2, and the output is labeled X. The module should be named \"five_to_one\".\n\nThe module should be defined in Verilog and should include the following:\n\n- The module declaration, including the input and output ports as shown in the code snippet above.\n- A combinational logic block that determines the value of X based on the values of A1, A2, A3, B1, and B2. The logic should be as follows:\n  - If A1, A2, and A3 are all high, X should be high.\n  - If B1 and B2 are both high, X should be low.\n  - In all other cases, X should be high impedance.\n\n- The module should be synthesizable and should not include any procedural blocks.\n\n", "output": "module five_to_one (\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    output X   \n);\n\n    assign X = (A1 & A2 & A3) ? 1'b1 :\n               (B1 & B2) ? 1'b0 :\n               1'bz;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder-subtractor circuit. The module should have four 4-bit inputs A, B, Cin, and Mode. The Mode input should be used to control the operation of the circuit. When Mode is 0, the circuit should perform addition, and when Mode is 1, the circuit should perform subtraction. The module should have two 4-bit outputs, Sum and Cout. Sum should output the result of the addition or subtraction, and Cout should output the carry-out bit.\n\nYou should use the following code snippet as a starting point for your module:\n\n```\nmodule adder_subtractor (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input Mode,\n  output [3:0] Sum,\n  output Cout\n);\n\n  // Your code here\n\nendmodule\n```\n\n", "output": "module adder_subtractor (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input Mode,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [3:0] Adder_out;\n  wire [3:0] Sub_out;\n  wire [3:0] Twos_comp;\n  wire Mode_inv;\n\n  assign Mode_inv = ~Mode;\n\n  // Adder\n  ripple_carry_adder adder (\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .Sum(Adder_out),\n    .Cout(Cout)\n  );\n\n  // Subtractor\n  assign Twos_comp = ~B + 1;\n  ripple_carry_adder subtractor (\n    .A(A),\n    .B(Twos_comp),\n    .Cin(Mode),\n    .Sum(Sub_out),\n    .Cout()\n  );\n\n  // Multiplexer\n  assign Sum = Mode_inv ? Adder_out : Sub_out;\n\nendmodule"}
{"instruction": "\n\nYou have been hired as a Verilog designer for a new project that involves designing a circuit for an inverter. The inverter should have an input A and an output Y. Your task is to design a module that implements this inverter.\n\nYour module should be named `my_inverter` and should have the following ports:\n- `A`: input bit\n- `Y`: output bit\n\nYour module should implement the following logic:\n- If the input `A` is 0, the output `Y` should be 1.\n- If the input `A` is 1, the output `Y` should be 0.\n\nYou can assume that the input `A` will always be either 0 or 1.\n\nYour module should be implemented within 200 lines of Verilog code.\n\n", "output": "module my_inverter (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    assign Y = ~A;\n\nendmodule"}
{"instruction": "\n\nYou have been assigned to design a verilog module for a digital circuit. The module should have two inputs and one output. The first input is a clock signal, which is a 50MHz square wave. The second input is a reset signal, which is active-low. The output is a 4-bit binary number that represents the number of clock cycles that have passed since the reset signal was last active.\n\nDesign a verilog module that satisfies the above requirements. You may assume that the reset signal will only be active-low for a single clock cycle.\n\n", "output": "module clk_counter(\n    input clk,\n    input reset,\n    output reg [3:0] counter\n);\n\nalways @(posedge clk, negedge reset) begin\n    if(!reset) begin\n        counter <= 4'b0000;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-bit counter with asynchronous reset and enable. The counter should increment on the rising edge of the clock signal only if the enable signal is asserted. If the asynchronous reset signal is asserted, the counter should be reset to zero regardless of the state of the enable signal. The module should have two input signals (CLK, RST) and one output signal (COUNT).\n\nWrite the verilog code for this module and simulate it to verify its functionality.\n\n", "output": "module counter_4bit_async_reset_enable (\n    input wire CLK, RST, EN,\n    output reg [3:0] COUNT\n);\n\nalways @(posedge CLK or negedge RST) begin\n    if (!RST) begin\n        COUNT <= 4'b0;\n    end else if (EN) begin\n        COUNT <= COUNT + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a half-adder circuit. The module should take in two input bits, A and B, and output two bits, SUM and COUT. The SUM bit should represent the sum of A and B, while the COUT bit should represent the carry-out bit of the addition. You must implement this module using Verilog code that is no longer than 200 lines.\n\nYour module should be named `half_adder` and have the following inputs and outputs:\n- `input A`: The first input bit\n- `input B`: The second input bit\n- `output SUM`: The sum of A and B\n- `output COUT`: The carry-out bit of the addition\n\nYou may assume that the input bits A and B will always be either 0 or 1.\n\n", "output": "module half_adder (\n    input A,\n    input B,\n    output SUM,\n    output COUT\n);\n\n    assign SUM = A ^ B;\n    assign COUT = A & B;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that takes in 4 inputs and provides 2 outputs. The module should be named \"parity_checker\". The inputs are a 4-bit binary number \"data_in\", an active-low reset signal \"rst\", an active-high enable signal \"en\", and a clock signal \"clk\". The output signals are \"even_parity\" and \"odd_parity\". When \"en\" is high, the module should calculate the even and odd parity of the input and output the results. When \"en\" is low, the output should be held at the last calculated parity values. When \"rst\" is low, the output should be reset to 0.\n\n", "output": "module parity_checker(\n  input [3:0] data_in,\n  input rst,\n  input en,\n  input clk,\n  output even_parity,\n  output odd_parity\n);\n\n  reg [1:0] parity;\n  reg [3:0] last_data_in;\n\n  always @(posedge clk) begin\n    if (rst == 0) begin\n      parity <= 2'b0;\n      last_data_in <= 4'b0;\n    end else if (en == 1) begin\n      parity[0] <= data_in[0] ^ data_in[1] ^ data_in[2] ^ data_in[3];\n      parity[1] <= ~parity[0];\n      last_data_in <= data_in;\n    end\n  end\n\n  assign even_parity = parity[0];\n  assign odd_parity = parity[1];\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes in two 8-bit inputs, `a` and `b`, and outputs a 1-bit signal `y` that is high if `a` is greater than or equal to `b`, and low otherwise. \n\nYour module should be named `greater_than_or_equal` and should have the following ports:\n- `a`: an 8-bit input\n- `b`: an 8-bit input\n- `y`: a 1-bit output\n\nYou should implement this module using only behavioral Verilog (no structural Verilog allowed).\n\n", "output": "module greater_than_or_equal(a, b, y);\n  input [7:0] a;\n  input [7:0] b;\n  output y;\n  \n  always @(*) begin\n    if (a >= b) begin\n      y = 1;\n    end else begin\n      y = 0;\n    end\n  end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary counter. The module should have the following inputs and outputs:\n- `clk`: a clock input\n- `reset`: a reset input\n- `enable`: an enable input\n- `out`: a 4-bit output representing the count\n\nThe counter should increment on every rising edge of the `clk` input when the `enable` input is high. When the `reset` input is high, the counter should reset to 0. The `out` output should represent the current count in binary.\n\nDesign the verilog module `binary_counter` that implements the above specifications.\n\n", "output": "module binary_counter (\n  clk,\n  reset,\n  enable,\n  out\n);\n\ninput wire clk;\ninput wire reset;\ninput wire enable;\noutput reg [3:0] out;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    out <= 4'b0000;\n  end else if (enable) begin\n    out <= out + 1;\n  end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 8-bit counter with a parallel load capability. The module should have three inputs (CLK, RESET, LOAD) and one output (COUNT). When RESET is high, the COUNT should be reset to 0. When LOAD is high, the COUNT should be loaded with the value from an 8-bit input (LOAD_DATA). Otherwise, the COUNT should increment on each rising edge of CLK.", "output": "module counter (\n    input CLK, RESET, LOAD,\n    input [7:0] LOAD_DATA,\n    output reg [7:0] COUNT\n);\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            COUNT <= 8'b0;\n        end\n        else if (LOAD) begin\n            COUNT <= LOAD_DATA;\n        end\n        else begin\n            COUNT <= COUNT + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nDesign a Verilog module that implements a 4-bit asynchronous resettable up-counter with enable and a synchronous gray code output. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `rst`: the asynchronous reset signal\n- `en`: the enable signal\n\nOutputs:\n- `gray_count`: the 4-bit gray code output\n\nThe counter should start at 0 and should increment by 1 whenever the enable signal is high and the clock signal transitions from low to high. The gray code output should be updated synchronously with the counter.\n\n", "output": "module gray_counter(\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] gray_count\n);\n\nreg [3:0] binary_count;\n\nalways @(posedge clk, posedge rst) begin\n    if (rst) begin\n        binary_count <= 4'b0000;\n        gray_count <= 4'b0000;\n    end else if (en) begin\n        binary_count <= binary_count + 1;\n        gray_count <= {binary_count[3], binary_count[3] ^ binary_count[2], binary_count[2] ^ binary_count[1], binary_count[1] ^ binary_count[0]};\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will take in a 4-bit binary input and output the binary value of the input multiplied by 3. The output should be displayed on a 6-bit binary output. The module should also have a reset input that sets the output to 0 when activated. \n\nDesign the module and provide the verilog code for it. \n\n", "output": "module mult_3 (input [3:0] in, input reset, output reg [5:0] out);\n\nalways @ (in, reset) begin\n    if (reset) begin\n        out <= 6'b0;\n    end\n    else begin\n        out <= (in * 3);\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a module that detects transitions in a 16-bit input vector. The module should detect both rising and falling edges, and the output bit should be set on the cycle following the edge detection. If multiple edges occur in the same cycle, only the first edge should be detected.", "output": "module edge_detection (\n  input clk,\n  input reset,\n  input [15:0] data,\n  output reg [15:0] edge_detected\n);\n\n  reg [15:0] prev_data;\n  reg [15:0] curr_data;\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      prev_data <= 16'b0;\n      curr_data <= 16'b0;\n      edge_detected <= 16'b0;\n    end\n    else begin\n      prev_data <= curr_data;\n      curr_data <= data;\n\n      if (prev_data != curr_data) begin\n        edge_detected <= curr_data ^ prev_data;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a simple 2-to-1 multiplexer. The module should have two input signals, `in0` and `in1`, and one select signal, `sel`. When `sel` is 0, the output of the module should be equal to `in0`. When `sel` is 1, the output should be equal to `in1`. \n\nCreate a verilog module named `mux2to1` that implements this functionality.\n\n", "output": "module mux2to1(\n   input         in0, in1, sel,\n   output        out);\n\n   assign out = sel ? in1 : in0;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in two 4-bit inputs (A and B) and outputs the maximum of the inputs in binary form. The module should have one input (clk) and two outputs (max and max_sel). The module should compare the inputs and output the maximum value and a select signal indicating which input was the maximum. The output max should be 4 bits wide and the output max_sel should be 1 bit wide.", "output": "module binary_max (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] max,\n    output reg max_sel\n);\n\nalways @(posedge clk) begin\n    if (A > B) begin\n        max <= A;\n        max_sel <= 1;\n    end else begin\n        max <= B;\n        max_sel <= 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that will take in a 4-bit binary input and output the binary equivalent of the input plus 5. Your module should have the following ports:\n\n- `input [3:0] in`: the 4-bit binary input\n- `output [3:0] out`: the 4-bit binary output\n\nYour module should also be sensitive to the positive edge of the clock signal, `clk`. \n\nWrite a Verilog module that meets these specifications.\n\n", "output": "module add_five(\n    input [3:0] in,\n    output [3:0] out,\n    input clk\n);\n\n    assign out = in + 4'b0101;\n\n    always @(posedge clk) begin\n        out <= in + 4'b0101;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a parameterized Verilog module that implements a binary counter with a configurable number of bits. The module should have an input `clk` and an output `count`, which should be a binary number of length `N`. The module should also have an input `reset` which should reset the count to zero.\n\nYou should design the module such that it can be instantiated with different values of `N` and should be able to count up to `2^N - 1`. The module should be implemented in a single Verilog module that is no more than 200 lines long.\n\nPlease write the Verilog code for the module.\n\n", "output": "module binary_counter\n#(\n  parameter N = 4\n)\n(\n  input clk,\n  input reset,\n  output reg [N-1:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 0;\n  end else begin\n    count <= count + 1;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-input majority gate. The module should take in 4 inputs, A, B, C, and D, and output the majority value of the inputs. The majority value is defined as the value that appears more than half the time. In the case of a tie, the output should be 0. \n\nYou should create a module named `majority_gate` that has the following ports:\n- `input A, B, C, D`\n- `output X`\n\nYou can assume that all inputs are binary values (0 or 1).\n\nYou should use the following template for your module:\n\n```\nmodule majority_gate (\n    // input ports\n    ,\n    ,\n    ,\n    ,\n    // output ports\n    ,\n);\n\n    // your code goes here\n\nendmodule\n```\n\n", "output": "module majority_gate (\n    // input ports\n    input A,\n    input B,\n    input C,\n    input D,\n    // output ports\n    output X\n);\n\n    wire AB = A & B;\n    wire AC = A & C;\n    wire AD = A & D;\n    wire BC = B & C;\n    wire BD = B & D;\n    wire CD = C & D;\n\n    wire majority1 = AB | AC | AD | BC | BD | CD;\n    wire majority0 = ~AB & ~AC & ~AD & ~BC & ~BD & ~CD;\n\n    assign X = (majority1 & ~majority0);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an RC oscillator interface. \nAn RC oscillator is a type of oscillator that uses a resistor and a capacitor to generate a waveform. \nThe waveform generated by the oscillator can be used as a clock signal in a digital circuit.\nYour module should have the following inputs and outputs:\n\nInputs: a clock frequency (clk_freq)\nOutputs: a clock signal (clk)\nThe module should also have the following parameters:\n\nr: the value of the resistor in the oscillator circuit\nc: the value of the capacitor in the oscillator circuit\nYour module should implement the following functionality:\n\nThe circuit should generate a clock signal with a frequency that is determined by the values of the resistor and capacitor.\nThe frequency of the clock signal should be equal to 1/(2*pi*r*c).\nTo implement the RC oscillator interface, you should use Verilog code to calculate the frequency of the clock signal based on the values of the resistor and capacitor. \nYou should then use this frequency to generate a clock signal with the appropriate period using a counter. \nFinally, you should use an output register to output the clock signal.", "output": "module RC_oscillator (\n  input clk_freq,\n  output reg clk\n);\n\nparameter r = 100; // value of the resistor\nparameter c = 1e-6; // value of the capacitor\n\nreg [31:0] count;\nreg toggle;\n\nassign clk = toggle;\n\nalways @(posedge clk_freq) begin\n  count <= count + 1;\n  if (count >= ((1/(2*3.14159*r*c))/clk_freq)) begin\n    toggle <= ~toggle;\n    count <= 0;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a clock gating module for a digital circuit. The module should take in a clock signal (`CLK`), an enable signal (`EN`), and a test enable signal (`TE`). The output of the module should be a gated clock signal (`ENCLK`), which is only enabled when both `EN` and `TE` are high.\n\nYour clock gating module should be implemented in a Verilog module called `myClockGater`. The module should be able to handle a clock signal with a frequency of up to 100 MHz. The module should also be designed to minimize power consumption when the `EN` input is low.\n\nYou should assume that the `TLATNTSCAX2TS` module is already provided and can be used to create the gated clock signal.\n\nYour task is to write the `myClockGater` module that satisfies the above requirements. Your module should be no more than 200 lines of Verilog code.\n\n", "output": "module myClockGater(\n  input CLK, \n  input EN, \n  input TE, \n  output ENCLK\n);\n\n  reg gated_en;\n\n  always @(posedge CLK) begin\n    if (EN && TE) begin\n      gated_en <= 1'b1;\n    end else begin\n      gated_en <= 1'b0;\n    end\n  end\n\n  TLATNTSCAX2TS latch(\n    .E(gated_en),\n    .SE(TE),\n    .CK(CLK),\n    .ECK(ENCLK)\n  );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with a hold function. The module should have four inputs: `in`, `enable_l`, `clock`, and `reset`. The `in` input is the data input to the flip-flop, `enable_l` is the enable input, `clock` is the clock input, and `reset` is the asynchronous reset input. The output of the module should be `out`, which is the output of the flip-flop.\n\nThe module should implement the following functionality:\n- When `enable_l` is high, the flip-flop should operate normally, with `out` following the value of `in` on the rising edge of `clock`.\n- When `enable_l` is low, the flip-flop should hold its current value, regardless of the value of `in` or `clock`.\n- When `reset` is high, the flip-flop should reset to 0, regardless of the value of `in`, `enable_l`, or `clock`.\n\nYou should implement this functionality using a single always block and any other necessary logic gates. Your design should be optimized for area and speed.\n\n", "output": "module dff_hold (\n  input in,\n  input enable_l,\n  input clock,\n  input reset,\n  output reg out\n);\n\nalways @(posedge clock or negedge reset) begin\n  if (!reset) begin\n    out <= 1'b0;\n  end else if (!enable_l) begin\n    out <= out;\n  end else begin\n    out <= in;\n  end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module for a 2:1 MUX. The module should have two input signals, one select signal, and one output signal. The select signal determines which input signal is passed to the output signal. The module should be named \"mux_2_1\". \n\nThe module should be defined with the following ports:\n- \"in_0\": a 1-bit input signal \n- \"in_1\": a 1-bit input signal \n- \"sel\": a 1-bit select signal \n- \"out\": a 1-bit output signal \n\nThe module should implement the following logic:\n- If \"sel\" is 0, then \"in_0\" should be passed to \"out\"\n- If \"sel\" is 1, then \"in_1\" should be passed to \"out\"\n\n\n", "output": "module mux_2_1 (\n    input in_0,\n    input in_1,\n    input sel,\n    output reg out\n);\n\n    always @(*) begin\n        if(sel == 0) begin\n            out = in_0;\n        end\n        else begin\n            out = in_1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a verilog module that will implement a 2:1 multiplexer with an enable signal. The module should have the following ports:\n\n- `data_in_0`: input, one bit data signal\n- `data_in_1`: input, one bit data signal\n- `enable`: input, one bit enable signal\n- `data_out`: output, one bit data signal\n\nThe module should output `data_in_0` when `enable` is low and `data_in_1` when `enable` is high.\n\nDesign the verilog module for the 2:1 multiplexer with enable signal.\n\n", "output": "module mux_2to1_enable(\n    input data_in_0,\n    input data_in_1,\n    input enable,\n    output reg data_out\n);\n\nalways @(*) begin\n    if(enable == 1'b0) begin\n        data_out = data_in_0;\n    end\n    else begin\n        data_out = data_in_1;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a D flip flop with active low asynchronous reset (reset output to 1). Additionally, add an enable input that controls when the D input is sampled. The output should be named \"q\".", "output": "module d_ff (\n  input clk,\n  input reset_n,\n  input enable,\n  input d,\n  output reg q\n);\n\nalways @(posedge clk or negedge reset_n) begin\n  if (!reset_n) begin\n    q <= 1'b0;\n  end else if (enable) begin\n    q <= d;\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple 8-bit shift register with the following inputs and outputs:\n- `in`: 8-bit input data\n- `shift`: a single bit input that controls whether to shift the data or not\n- `reset`: a single bit asynchronous reset input that resets the shift register to all zeros\n- `clk`: a single bit clock input\n- `out`: 8-bit output data\n\nImplement the shift register using a `reg` data type and a single `always` block. Ensure that the shift register shifts the data on the rising edge of the clock when the `shift` input is high. When the `reset` input is high, the shift register should reset to all zeros.\n\n", "output": "module shift_register (\n    in,\n    shift,\n    reset,\n    clk,\n    out\n);\n\ninput [7:0] in;\ninput shift, reset, clk;\noutput [7:0] out;\n\nreg [7:0] shift_reg;\n\nalways @ (posedge clk or posedge reset) begin\n    if (reset) begin\n        shift_reg <= 8'b0;\n    end else if (shift) begin\n        shift_reg <= {shift_reg[6:0], in};\n    end\nend\n\nassign out = shift_reg;\n\nendmodule"}
{"instruction": "Create a module that implements a NOR gate using a combination of NAND gates. A NOR gate is an OR gate with its output inverted. The module must be capable of taking two inputs and providing a single output. Implement the target module with the minimum number of NAND gates.", "output": "module nor_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire nand1_out, nand2_out;\n\nnand nand1(a, a, nand1_out);\nnand nand2(b, b, nand2_out);\nnand nand3(nand1_out, nand2_out, out);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital circuit that performs a specific function. The circuit should be implemented in Verilog and should be contained within a single module. The module should have the following inputs and outputs:\n\nInputs:\n- `D`: a single-bit input signal\n- `GATE_N`: a single-bit input signal\n\nOutputs:\n- `Q`: a single-bit output signal\n\nAdditionally, the module should have the following voltage supply signals:\n- `VPWR`: a 1V voltage supply signal\n- `VGND`: a 0V voltage supply signal\n- `VPB`: a 1V voltage supply signal\n- `VNB`: a 0V voltage supply signal\n\nYour task is to implement the functionality of the circuit within the Verilog module. The circuit should be designed to implement the following logic:\n\n- If `GATE_N` is high, `Q` should be equal to `D`.\n- If `GATE_N` is low, `Q` should be equal to the previous value of `Q`.\n\nYou should assume that the circuit will be used in a larger digital system and that the voltage supply signals will be provided by the system.\n\n", "output": "module digital_circuit (\n    Q,\n    D,\n    GATE_N,\n    VPWR,\n    VGND,\n    VPB,\n    VNB\n);\n\n    output Q;\n    input D;\n    input GATE_N;\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    reg Q;\n\n    always @(*) begin\n        if (GATE_N == 1'b1) begin\n            Q <= D;\n        end else begin\n            Q <= Q;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-input multiplexer using a combinational logic circuit. The module should have three inputs, x, y, and z, and one output, out. The output out should be the result of selecting one of the inputs based on the value of a select signal, sel. If sel is 0, the output should be equal to x. If sel is 1, the output should be equal to y. If sel is 2, the output should be equal to z.", "output": "module mux_3input (\n  input x,\n  input y,\n  input z,\n  input [1:0] sel,\n  output reg out\n);\n\n  always @(*) begin\n    case (sel)\n      2'b00: out = x;\n      2'b01: out = y;\n      2'b10: out = z;\n      default: out = 1'bx;\n    endcase\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit binary counter with a synchronous reset and a synchronous load capability. The module should have two inputs: a clock signal (clk) and a control signal (ctrl). If ctrl is set to 0, the counter should increment on every rising edge of the clock signal. If ctrl is set to 1, the counter should load the value of a 4-bit input (load_data) on the next rising edge of the clock signal. The module should have two outputs: the current value of the counter (count) and a flag signal (flag), which should be set to 1 when the counter reaches its maximum value (15) and then reset to 0 on the next clock cycle.", "output": "module binary_counter (\n  input clk,\n  input ctrl,\n  input [3:0] load_data,\n  output reg [3:0] count,\n  output reg flag\n);\n\n  always @(posedge clk) begin\n    if (ctrl == 1) begin\n      count <= load_data;\n      flag <= 0;\n    end else begin\n      if (count == 4'b1111) begin\n        count <= 4'b0000;\n        flag <= 1;\n      end else begin\n        count <= count + 1;\n        flag <= 0;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that will act as a buffer for a clock signal. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK_IN`: input clock signal\n- `RST`: reset signal\n\nOutputs:\n- `CLK_OUT`: output clock signal\n\nThe module should operate as follows:\n- While `RST` is high, `CLK_OUT` should be held low.\n- When `RST` goes low, `CLK_OUT` should be a buffered version of `CLK_IN`.\n- If `CLK_IN` changes while `RST` is low, `CLK_OUT` should update to reflect the new value of `CLK_IN`.\n\nDesign a Verilog module that implements this behavior. You may use any standard Verilog libraries, but your module should be self-contained and not rely on any external modules.\n\n\n", "output": "module clock_buffer (\n    input CLK_IN,\n    input RST,\n    output reg CLK_OUT\n);\n\nalways @(posedge CLK_IN, posedge RST) begin\n    if (RST) begin\n        CLK_OUT <= 1'b0;\n    end else begin\n        CLK_OUT <= CLK_IN;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that performs a 4-bit binary addition. The module should have the following inputs and outputs:\n\nInputs:\n- A: a 4-bit binary number\n- B: a 4-bit binary number\n- Cin: a single bit representing the carry-in value\n\nOutputs:\n- S: a 4-bit binary number representing the sum of A and B\n- Cout: a single bit representing the carry-out value\n\nYour module should be named \"add4\".\n\n", "output": "module add4(input [3:0] A, input [3:0] B, input Cin, output [3:0] S, output Cout);\n\n   wire [3:0] temp;\n   assign temp[0] = A[0] ^ B[0] ^ Cin;\n   assign Cout = A[0]&B[0] | A[0]&Cin | B[0]&Cin;\n\n   assign temp[1] = A[1] ^ B[1] ^ Cout;\n   assign Cout = A[1]&B[1] | A[1]&Cout | B[1]&Cout;\n\n   assign temp[2] = A[2] ^ B[2] ^ Cout;\n   assign Cout = A[2]&B[2] | A[2]&Cout | B[2]&Cout;\n\n   assign temp[3] = A[3] ^ B[3] ^ Cout;\n   assign S = temp;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder with carry in and carry out. The module should have the following inputs and outputs:\n\nInputs:\n- `A`: 4-bit input signal\n- `B`: 4-bit input signal\n- `Cin`: carry input signal\n\nOutputs:\n- `Sum`: 4-bit output signal representing the sum of `A`, `B`, and `Cin`\n- `Cout`: carry output signal\n\nThe module should be named `adder4` and should use only basic verilog constructs (no pre-defined adder modules).\n\n", "output": "module adder4(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\nwire [3:0] xor_out;\nwire [3:0] and_out;\nwire [3:0] or_out;\n\n// Generate sum bits\nassign xor_out = A ^ B;\nassign Sum = xor_out ^ Cin;\n\n// Generate carry out\nassign and_out = A & B;\nassign or_out = A | B;\nassign Cout = (and_out | (xor_out & Cin)) | (or_out & Cin);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock gating cell. \nA clock gating cell is a digital circuit that is used to control the clock signal to a set of flip-flops. \nBy controlling the clock signal, the clock gating cell can reduce power consumption and improve performance.\n\nYour module should have the following inputs and outputs:\n\nInputs: a clock signal (CLK)\n         a control signal (EN)\nOutputs: a gated clock signal (CLK_G)\n\nYour module should implement the following functionality:\n\nWhen the control signal is high, the clock gating cell should pass the clock signal through to the gated clock signal.\nWhen the control signal is low, the clock gating cell should hold the gated clock signal low, regardless of the state of the clock signal.\nThe module should be implemented using Verilog code. You should use a simple gate-level implementation to create the clock gating cell. \nYou should also ensure that the module produces a synchronous output by using the clock signal as a reference for the control signal.", "output": "module clock_gate (\n  input CLK,\n  input EN,\n  output reg CLK_G\n);\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      CLK_G <= CLK;\n    end\n    else begin\n      CLK_G <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit binary to gray code converter. The module should have one input (BIN) and one output (GRAY). The input BIN is a 4-bit binary number, and the output GRAY is the corresponding 4-bit gray code. Hint: Use exclusive-or (XOR) gates to implement the conversion.", "output": "module binary_to_gray (\n    input [3:0] BIN,\n    output reg [3:0] GRAY\n);\n\nalways @ (BIN) begin\n    GRAY[0] = BIN[0] ^ BIN[1];\n    GRAY[1] = BIN[1] ^ BIN[2];\n    GRAY[2] = BIN[2] ^ BIN[3];\n    GRAY[3] = BIN[3];\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a 4-bit adder using Verilog. The module should have four inputs (A, B, Cin, and enable) and two outputs (Sum and Cout). The module should be implemented using only one module within 200 lines of Verilog code.\n\nThe inputs A and B are 4-bit binary numbers, and Cin is a single bit representing the carry-in bit. The enable input is a single bit that enables the addition operation when high. When enable is low, the module should output the inputs A and B as the Sum output and 0 as the Cout output.\n\nThe Sum output should be a 4-bit binary number representing the sum of A, B, and Cin. The Cout output should be a single bit representing the carry-out bit.\n\nYour module should implement the following equation to calculate the Sum and Cout outputs:\n```\nSum = A + B + Cin\nCout = (A + B + Cin) > 15\n```\nWhere `>` is a greater-than operator.\n\nEnsure that your module is fully parameterized so that the bit-widths of the inputs and outputs can be easily changed.\n\n", "output": "module adder_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input enable,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire [4:0] adder_out;\n    \n    assign sum = A + B + Cin;\n    assign adder_out = {Cin, sum};\n    \n    assign Cout = (adder_out > 4'b1111);\n    assign Sum = (enable) ? sum : A;\n    \nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit shift register with serial input and output. The module should have three inputs: data_in, shift, and clk. If shift is high, the module should shift the contents of the register on every positive edge of the clock. If shift is low, the module should load the data_in value into the shift register. The module should also have one output, q, which is the output of the shift register.", "output": "module shift_reg_serial (\n    input data_in,\n    input shift,\n    input clk,\n    output reg q\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (shift) begin\n        shift_reg <= {shift_reg[2:0], shift_reg[3]};\n    end else begin\n        shift_reg <= {shift_reg[2:0], data_in};\n    end\nend\n\nassign q = shift_reg[0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a Verilog module that implements a 4-bit binary up-counter. The counter should start at 0 and increment by 1 every time the clock input transitions from low to high. When the counter reaches its maximum value of 15 (1111 in binary), it should wrap around to 0. The module should have three ports: a clock input, a reset input, and a 4-bit output for the counter value.", "output": "module up_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 4'b0000;\n  end else begin\n    if (count == 4'b1111) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 2-bit binary adder. The module should have three inputs: A, B, and Carry-In (CI), and two outputs: Sum and Carry-Out (COUT_N). The module should be named \"two_bit_adder\".\n\nThe inputs A and B are 2-bit binary numbers, and the CI input is a single-bit binary number representing the carry-in bit. The output Sum is a 2-bit binary number representing the sum of A, B, and CI, and the output COUT_N is a single-bit binary number representing the carry-out bit.\n\nYour module should be able to handle all possible input combinations, including overflow. Overflow occurs when the sum of A, B, and CI is greater than 3, in which case the output Sum should be equal to the binary representation of the remainder of the sum divided by 4 (i.e., if the sum is 4 or 5, the output Sum should be 0b01; if the sum is 6 or 7, the output Sum should be 0b10).\n\nYour module should be implemented in Verilog and should be no more than 200 lines of code.\n\n", "output": "module two_bit_adder (\n    input [1:0] A,\n    input [1:0] B,\n    input CI,\n    output [1:0] Sum,\n    output COUT_N\n);\n\n    wire [2:0] temp_sum;\n    wire [1:0] temp_carry;\n\n    assign temp_sum = {1'b0, A} + {1'b0, B} + {1'b0, CI};\n    assign temp_carry = {temp_sum[2], temp_sum[1]};\n\n    assign COUT_N = temp_sum[2];\n    assign Sum = (temp_sum[1:0] >= 2'b10) ? (temp_sum[1:0] - 2'b10) : temp_sum[1:0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 2-to-1 multiplexer using a behavioral if statement. The multiplexer should select input a if sel_a is high, otherwise, select input b only if sel_b1 and sel_b2 are both low.", "output": "module mux_2to1_behavioral (\n  input a,\n  input b,\n  input sel_a,\n  input sel_b1,\n  input sel_b2,\n  output reg out_mux\n);\n\n  always @(*) begin\n    if (sel_a) begin\n      out_mux = a;\n    end\n    else if (!sel_b1 && !sel_b2) begin\n      out_mux = b;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple shift register. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: clock input\n- `rst`: asynchronous reset input\n- `shift_in`: input data to be shifted in\n- `shift`: control signal to initiate shifting\n\nOutputs:\n- `shift_out`: output data shifted out\n\nThe shift register should be able to shift in 8 bits of data and shift them out in the same order they were shifted in. The shift register should be able to shift the data in on the rising edge of the `shift` signal and shift the data out on the falling edge of the `shift` signal.\n\nYou should implement the shift register using a behavioral model.\n\n", "output": "module shift_register(clk, rst, shift_in, shift, shift_out);\n    input clk, rst, shift;\n    input [7:0] shift_in;\n    output reg [7:0] shift_out;\n\n    always @(posedge clk, negedge rst) begin\n        if (!rst) begin\n            shift_out <= 8'b0;\n        end else if (shift) begin\n            shift_out <= {shift_out[6:0], shift_in};\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit binary counter that counts from 0 to 15. The counter should have a synchronous reset input, an active-high enable input, and a clock input. The counter should output the current count value on a 4-bit output bus. The counter should reset to 0 when the reset input is asserted. When the enable input is asserted, the counter should increment on every rising edge of the clock input. When the enable input is deasserted, the counter should hold its current value.\n\nDesign a verilog module that meets the above requirements.\n\n", "output": "module binary_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n    );\n\n    always @(posedge clk)\n    begin\n        if (reset)\n            count <= 4'b0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 2-input NOR gate with buffered output. The module should have the following ports:\n\n- `Y`: output port for the NOR gate output\n- `A`: input port for the first input to the NOR gate\n- `B_N`: input port for the second input to the NOR gate, which is inverted\n\nThe module should be implemented using the following verilog primitives:\n\n- `not`: inverts its input\n- `and`: performs an AND operation on its inputs\n- `buf`: buffers its input to its output\n\nIn addition, the module should include the following power supplies:\n\n- `VPWR`: a supply voltage of 1V\n- `VGND`: a ground voltage of 0V\n- `VPB`: a power supply for the buffer\n- `VNB`: a ground supply for the buffer\n\nYour module should be implemented within 200 lines of verilog code.\n\n", "output": "module nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    // Module ports\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    //  Name  Output      Other arguments\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a digital system that implements a 4-bit binary counter. The counter should have an asynchronous reset input (active low) and a clock input. When the reset input is asserted, the counter should reset to 0. When the clock input transitions from low to high, the counter should increment by 1. The counter should output its current value on 4 output pins Q3, Q2, Q1, and Q0. \n\nYour task is to design a verilog module that implements the 4-bit binary counter with the following interface:\n\n```\nmodule binary_counter (\n    input clk,\n    input rst_n,\n    output reg [3:0] Q\n);\n```\n\nThe module should be contained within 200 lines of verilog code, and must include comments to explain the functionality of each section of code. \n\n", "output": "module binary_counter (\n    input clk,\n    input rst_n,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are hired by a company to design a verilog module that takes in two 4-bit inputs A and B and outputs the sum of A and B in binary. You need to implement a module named `adder` that has the following ports:\n\n- `input [3:0] A`: a 4-bit binary input\n- `input [3:0] B`: a 4-bit binary input\n- `output [3:0] sum`: a 4-bit binary output\n\nYour module should perform binary addition of A and B and output the result in binary on the `sum` port. If the sum is greater than 4 bits, the most significant bit should be truncated.\n\n", "output": "module adder (\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] sum\n);\n\n  assign sum = A + B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-to-1 multiplexer with a single output (O) and four inputs (I0, I1, I2, and I3). The module should also have two select inputs (S0 and S1) that determine which input is selected and outputted. The truth table for the multiplexer is as follows:\n\n| S1 | S0 | O  |\n|----|----|----|\n| 0  | 0  | I0 |\n| 0  | 1  | I1 |\n| 1  | 0  | I2 |\n| 1  | 1  | I3 |\n\nYou must implement this multiplexer using only one Verilog module that is no longer than 200 lines of code. Your module should be named `mux4to1` and should take the following inputs and outputs:\n\n- `input [3:0] I`: an array of four inputs\n- `input [1:0] S`: a two-bit select input\n- `output O`: the output of the multiplexer\n\nYour module should contain only combinational logic and should not use any built-in Verilog primitives or operators. You may use basic logic gates (AND, OR, NOT, etc.), as well as conditional statements (if-else), loops (for, while), and other basic programming constructs.\n\nWrite a Verilog module that implements the 4-to-1 multiplexer described above, using only one module and no more than 200 lines of code.\n\n", "output": "module mux4to1(\n    input [3:0] I,\n    input [1:0] S,\n    output O\n);\n\n    wire [1:0] notS;\n    wire [3:0] and0, and1, and2, and3;\n    \n    assign notS = ~S;\n    \n    assign and0 = I[0] & ~S[1] & ~S[0];\n    assign and1 = I[1] & ~S[1] & S[0];\n    assign and2 = I[2] & S[1] & ~S[0];\n    assign and3 = I[3] & S[1] & S[0];\n    \n    assign O = and0 | and1 | and2 | and3;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a simple 8-bit adder with a carry-in and carry-out bit. The module should have the following inputs and outputs:\n\nInputs:\n- `a` (8-bit signed integer)\n- `b` (8-bit signed integer)\n- `cin` (1-bit carry-in)\n\nOutputs:\n- `sum` (8-bit signed integer)\n- `cout` (1-bit carry-out)\n\nThe module should perform the following operation: `sum = a + b + cin`. If the result overflows the 8-bit signed integer range, the output should be saturated to the maximum or minimum value.\n\nDesign the module and write its Verilog code.\n\n", "output": "module simple_adder(\n  input [7:0] a,\n  input [7:0] b,\n  input cin,\n  output [7:0] sum,\n  output cout\n);\n\n  wire [8:0] temp_sum;\n  assign temp_sum = {1'b0, a} + {1'b0, b} + cin;\n  \n  // Check if overflow occurred\n  always @(*) begin\n    if (temp_sum[8] == 1) begin\n      if (temp_sum[7] == 1) begin\n        sum = -128;\n      end else begin\n        sum = 127;\n      end\n      cout = 1;\n    end else begin\n      sum = temp_sum[7:0];\n      cout = 0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a simple 4-bit adder. The module should have two 4-bit inputs, A and B, and a 1-bit input, Cin, representing the carry-in bit. The module should also have two outputs, Sum and Cout, representing the sum of A and B and the carry-out bit, respectively. The module should be named \"four_bit_adder\".\n\nYour module should implement the following equation for the sum output:\n```\nSum = A + B + Cin\n```\nWhere the addition is performed in binary arithmetic.\n\nIf the sum of A, B, and Cin is greater than 15, the Cout output should be set to 1, indicating that there was a carry-out from the most significant bit. Otherwise, Cout should be set to 0.\n\nYou may assume that the inputs A and B are valid 4-bit binary numbers and that Cin is a valid 1-bit binary number.\n\nYour module should be contained within 200 lines of Verilog code.\n\n", "output": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] Sum,\n    output reg Cout\n);\n\n    always @(*) begin\n        // Calculate the sum of A, B, and Cin\n        Sum = A + B + Cin;\n\n        // Set the carry-out bit if the sum is greater than 15\n        if (Sum > 15) begin\n            Cout = 1;\n        end else begin\n            Cout = 0;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a hysteresis comparator. \nA hysteresis comparator is a type of comparator that is used to detect when an input signal crosses a threshold voltage. \nThe circuit has two threshold voltages, one for the rising edge (Vth_r) and one for the falling edge (Vth_f). \nWhen the input signal rises above Vth_r, the output signal should go high. The output signal should remain high until the input signal falls below Vth_f. \nWhen the input signal falls below Vth_f, the output signal should go low. The output signal should remain low until the input signal rises above Vth_r.\n\nYour module should have the following inputs and outputs:\nInputs: \n- in: the input signal\n- Vth_r: the rising threshold voltage\n- Vth_f: the falling threshold voltage\nOutputs: \n- out: the output signal, which should be high when the input signal is above Vth_r and low when the input signal is below Vth_f.\n\nTo implement the hysteresis comparator, you should use Verilog code to define the logic for the rising edge and falling edge. \nYou should use an internal signal to keep track of the output state (high or low) and update this signal based on the input signal and the threshold voltages. \nFinally, you should use this internal signal to set the output signal.", "output": "module hysteresis_comparator (\n    input in,\n    input Vth_r,\n    input Vth_f,\n    output reg out\n);\n\nreg state;\n\nalways @ (in or state) begin\n    if (in > Vth_r)\n        state <= 1;\n    else if (in < Vth_f)\n        state <= 0;\nend\n\nassign out = state;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary adder with carry-in and carry-out. The module should have two 4-bit inputs, A and B, and a 1-bit input, Cin, representing the carry-in. The module should output a 4-bit sum, S, and a 1-bit carry-out, Cout.\n\nYour module should be named \"binary_adder\" and should include the following:\n\n- A 4-bit input port named \"A\"\n- A 4-bit input port named \"B\"\n- A 1-bit input port named \"Cin\"\n- A 4-bit output port named \"S\"\n- A 1-bit output port named \"Cout\"\n\nYou should use only basic logic gates (AND, OR, XOR, NOT) and the verilog \"+\" operator to implement your module.\n\n", "output": "module binary_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [4:0] C;\n\nassign C = {Cin, 4'b0};\n\nassign S = A + B + C[4:1];\n\nassign Cout = C[5];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit adder-subtractor in Verilog. The module should have the following inputs and outputs:\n\nInputs:\n- `a` (4-bit input): the first operand of the operation\n- `b` (4-bit input): the second operand of the operation\n- `sub` (1-bit input): a control signal that determines whether the operation is addition or subtraction. If `sub` is 1, the operation is subtraction. If `sub` is 0, the operation is addition.\n\nOutputs:\n- `result` (4-bit output): the result of the operation\n- `carry_out` (1-bit output): the carry-out bit of the operation. For addition, `carry_out` is the carry-out bit of the most significant bit. For subtraction, `carry_out` is the borrow-out bit of the most significant bit.\n\nYour module should be named `adder_subtractor` and should have the following interface:\n\n```\nmodule adder_subtractor(a, b, sub, result, carry_out);\n\tinput [3:0] a, b;\n\tinput sub;\n\toutput [3:0] result;\n\toutput carry_out;\n\t\n\t// your code here\n\t\nendmodule\n```\n\nYou should assume that the inputs `a` and `b` are valid 4-bit binary numbers.\n\n", "output": "module adder_subtractor(a, b, sub, result, carry_out);\n\tinput [3:0] a, b;\n\tinput sub;\n\toutput [3:0] result;\n\toutput carry_out;\n\t\n\treg [3:0] twos_comp_b;\n\treg [4:0] temp_result;\n\t\n\tassign twos_comp_b = ~b + 1;\n\t\n\talways @(*) begin\n\t\tif (sub) begin\n\t\t\ttemp_result = a + twos_comp_b;\n\t\t\tcarry_out = temp_result[4];\n\t\t\tresult = temp_result[3:0];\n\t\tend\n\t\telse begin\n\t\t\ttemp_result = a + b;\n\t\t\tcarry_out = temp_result[4];\n\t\t\tresult = temp_result[3:0];\n\t\tend\n\tend\n\t\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-to-1 multiplexer (MUX) with an enable signal. The module should have the following inputs and outputs:\n\nInputs:\n- `in0`, `in1`, `in2`, `in3`: 1-bit data inputs to the MUX\n- `en`: 1-bit enable signal\n\nOutputs:\n- `out`: 1-bit data output from the MUX\n\nYour module should be named `mux4_en` and should use the `always` block for combinational logic. You should assume that the `en` signal is active high. If `en` is low, the output should be 0.\n\n", "output": "module mux4_en(\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input en,\n    output out\n);\n\n    always @(*) begin\n        if (en == 1'b1) begin\n            casez({in3, in2, in1, in0})\n                4'b0000: out = in0;\n                4'b0001: out = in1;\n                4'b0010: out = in2;\n                4'b0011: out = in3;\n                default: out = 1'b0;\n            endcase\n        end else begin\n            out = 1'b0;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two 8-bit inputs, `a` and `b`, and outputs a 16-bit value `result`. The module should perform the following operation: `result = a * b`.\n\nDesign a verilog module that implements this functionality.\n\n", "output": "module multiply_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n\nreg [15:0] temp_result;\n\nalways @(*) begin\n    temp_result = a * b;\nend\n\nassign result = temp_result;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit input and outputs a 2-bit value representing the number of 1's in the input. For example, if the input is 0011, the output should be 01 (since there are two 1's in the input). \n\nYour module should have the following ports:\n- `input [3:0] in`\n- `output [1:0] out`\n\nWrite the Verilog code for this module.\n\n", "output": "module count_ones(\n  input [3:0] in,\n  output [1:0] out\n);\n\nreg [1:0] count;\n\nalways @(*) begin\n  count = {in[0] + in[1], in[2] + in[3]};\nend\n\nassign out = count;\n\nendmodule"}
{"instruction": "Given an 8-bit input vector [7:0], implement a module that performs a bitwise AND operation between the input vector and a constant 8-bit vector [11100011] and outputs the result.", "output": "module bitwise_and(\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = in & 8'b11100011;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a 4-bit binary-to-Gray code converter. The module should have a 4-bit input (binary) and a 4-bit output (Gray code). The output should be updated whenever there is a change in the input. The module should be implemented within 200 lines of Verilog code.\n\nA Gray code is a binary numeral system where two successive values differ in only one bit. For example, the binary representation of 6 is 110, whereas its Gray code representation is 100. The conversion from binary to Gray code can be done using the following algorithm:\n\n1. The most significant bit (MSB) of the Gray code is the same as the MSB of the binary code.\n2. For each bit starting from the second most significant bit (2nd MSB), the Gray code bit is the XOR of the current binary bit and the previous Gray code bit.\n\nFor example, to convert the binary number 0110 to Gray code, we follow the algorithm as follows:\n\n1. The MSB of the Gray code is the same as the MSB of the binary code, which is 0.\n2. The 2nd MSB of the Gray code is the XOR of the 2nd MSB of the binary code (1) and the previous Gray code bit (0), which gives 1.\n3. The 3rd MSB of the Gray code is the XOR of the 3rd MSB of the binary code (1) and the previous Gray code bit (1), which gives 0.\n4. The 4th MSB of the Gray code is the XOR of the 4th MSB of the binary code (0) and the previous Gray code bit (0), which gives 0.\n\nTherefore, the Gray code representation of 0110 is 1000.\n\nImplement a Verilog module that takes a 4-bit binary input and produces a 4-bit Gray code output, using the algorithm described above. Your module should be named \"bin2gray\" and should have the following interface:\n\n```\nmodule bin2gray (\n    input [3:0] binary,\n    output [3:0] gray\n);\n```\n\nThe module should be implemented within 200 lines of Verilog code.\n\n", "output": "module bin2gray (\n    input [3:0] binary,\n    output [3:0] gray\n);\n\n    wire [2:0] xor_out;\n    \n    assign xor_out[0] = binary[1] ^ binary[0];\n    assign xor_out[1] = binary[2] ^ binary[1];\n    assign xor_out[2] = binary[3] ^ binary[2];\n    \n    assign gray[0] = binary[0];\n    assign gray[1] = xor_out[0];\n    assign gray[2] = xor_out[1];\n    assign gray[3] = xor_out[2];\n    \nendmodule"}
{"instruction": "\n\nYou are tasked to design a module that implements a 2-bit comparator using the Verilog HDL. The module should have two 2-bit inputs, A and B, and one 2-bit output, EQ. The output EQ should be high (1) if A is equal to B, and low (0) otherwise.\n\nYou should implement this module using only basic logic gates, such as AND, OR, and NOT gates. You are not allowed to use any built-in Verilog primitives or operators, such as == or ===.\n\nWrite a Verilog module that implements the 2-bit comparator as described above.\n\n", "output": "module comparator_2bit (\n    input [1:0] A,\n    input [1:0] B,\n    output EQ\n);\n\n    wire eq1, eq2, eq3, eq4;\n\n    // Compare the most significant bits of A and B\n    and(eq1, A[1], B[1]);\n    and(eq2, ~A[1], ~B[1]);\n\n    // Compare the least significant bits of A and B\n    and(eq3, A[0], B[0]);\n    and(eq4, ~A[0], ~B[0]);\n\n    // Combine the results of the two comparisons\n    and(EQ, eq1, eq3);\n    or(EQ, EQ, and(eq2, eq4));\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 2-input XOR gate. The module should have the following inputs and outputs:\n- Inputs: A (1-bit), B (1-bit)\n- Output: X (1-bit)\n\nThe module should be named \"xor2\" and should be written using gate-level modeling.\n\n", "output": "module xor2 (\n    input A,\n    input B,\n    output X\n);\n\n    wire w1, w2, w3;\n\n    // First stage\n    nand n1(w1, A, B);\n    nand n2(w2, A, w1);\n    nand n3(w3, B, w1);\n\n    // Second stage\n    nand n4(X, w2, w3);\n\nendmodule\n\n// Define nand gate\nmodule nand (output o, input a, input b);\n    assign o = ~(a & b);\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2-bit up/down counter with asynchronous reset and enable. The counter should increment or decrement based on the value of the enable input, with 2'b00 representing no change, 2'b01 representing an increment, and 2'b10 representing a decrement. The counter should reset to 2'b00 when the asynchronous reset input is high.", "output": "module up_down_counter (\n    input clk,\n    input async_reset,\n    input [1:0] enable,\n    output reg [1:0] count\n);\n\n    always @(posedge clk or negedge async_reset) begin\n        if (!async_reset) begin\n            count <= 2'b00;\n        end else begin\n            case (enable)\n                2'b00: count <= count;\n                2'b01: count <= count + 2'b01;\n                2'b10: count <= count - 2'b01;\n                default: count <= count;\n            endcase\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a pulse width modulator (PWM). \nA PWM is a type of digital circuit that generates a pulse width modulated (PWM) signal, which is commonly used in applications such as motor control, audio amplifiers, and power supplies. \nThe PWM signal is a square wave with a varying duty cycle, where the duty cycle is the percentage of time that the signal is high over a period.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- a clock signal (clk)\n- a modulation signal (mod) that determines the duty cycle of the PWM signal\n- a reset signal (rst) that resets the PWM signal to its initial state\n\nOutputs: \n- a PWM signal (pwm) that has a duty cycle determined by the modulation signal\n\nThe module should also have the following parameters:\n\n- p: the number of bits used to represent the modulation signal\n\nYour module should implement the following functionality:\n\n- The PWM signal should have a period of 2^p clock cycles.\n- The duty cycle of the PWM signal should be determined by the modulation signal, which should be a p-bit binary number.\n- When the modulation signal is zero, the PWM signal should be low for the entire period.\n- When the modulation signal is 2^p-1, the PWM signal should be high for the entire period.\n- When the modulation signal is between zero and 2^p-1, the duty cycle of the PWM signal should be proportional to the value of the modulation signal.\n\nTo implement the PWM, you should use Verilog code to generate the PWM signal based on the input signals and parameters. \nYou should use a counter to generate the period of the PWM signal, and compare the counter value to the modulation signal to determine the duty cycle of the PWM signal. \nYou should also use the reset signal to reset the counter and PWM signal to their initial states.", "output": "module PWM (\n  input clk,\n  input rst,\n  input [p-1:0] mod,\n  output pwm\n);\n\nparameter p = 8; // number of bits used to represent the modulation signal\n\nreg [p-1:0] counter;\nreg pwm_reg;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    counter <= 0;\n    pwm_reg <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter >= 2**p) begin\n      counter <= 0;\n    end\n    if (counter < mod) begin\n      pwm_reg <= 1;\n    end else begin\n      pwm_reg <= 0;\n    end\n  end\nend\n\nassign pwm = pwm_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 2-to-1 multiplexer (MUX) with an enable input. The module should have three inputs: A, B, and EN, and one output Y. When EN is high, the output Y should be equal to A. When EN is low, the output Y should be equal to B. \n\nIn addition, the module should include voltage supply signals for VPWR (voltage power), VGND (voltage ground), VPB (voltage power for B input), and VNA (voltage ground for A input).\n\nDesign the verilog module for the 2-to-1 MUX with enable input according to the specifications above. \n\n", "output": "module mux2to1_enable (\n    input A,\n    input B,\n    input EN,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNA ;\n\n    assign Y = EN ? A : B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a D flip-flop with set and reset inputs, and an asynchronous clear input. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` (1-bit): clock input\n- `d` (1-bit): data input\n- `set` (1-bit): set input\n- `reset` (1-bit): reset input\n- `clear` (1-bit): asynchronous clear input\n\nOutputs:\n- `q` (1-bit): output\n- `q_bar` (1-bit): complement output\n\nThe flip-flop should operate as follows:\n- When the `clear` input is asserted, both `q` and `q_bar` should be set to 0, regardless of the values of the other inputs.\n- When the `set` input is asserted, both `q` and `q_bar` should be set to 1, regardless of the values of the other inputs.\n- When the `reset` input is asserted, both `q` and `q_bar` should be set to 0, regardless of the values of the other inputs.\n- At each rising edge of the `clk` input, the output `q` should be updated with the value of the `d` input, unless the `clear` input is asserted. The output `q_bar` should be the complement of `q`.\n\nWrite a verilog module that implements this flip-flop.\n\n", "output": "module dffsr_async_clear_set_reset(clk, d, set, reset, clear, q, q_bar);\n    input clk, d, set, reset, clear;\n    output q, q_bar;\n    reg q, q_bar;\n\n    always @(posedge clk) begin\n        if (clear) begin\n            q <= 0;\n            q_bar <= 1;\n        end else if (set) begin\n            q <= 1;\n            q_bar <= 0;\n        end else if (reset) begin\n            q <= 0;\n            q_bar <= 1;\n        end else begin\n            q <= d;\n            q_bar <= ~d;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four input signals and outputs one signal. The module should be named \"signal_converter\". The input signals are A1_N, A2_N, B1, and B2. The output signal is X. \n\nThe module should have the following functionality:\n- If A1_N and A2_N are both low (0), X should be set to B1.\n- If A1_N is low (0) and A2_N is high (1), X should be set to B2.\n- If A1_N is high (1) and A2_N is low (0), X should be set to the inverse of B1.\n- If A1_N and A2_N are both high (1), X should be set to the inverse of B2.\n\nAssume that the input signals are all 1-bit signals. You can use any gates, primitives, or other modules from the sky130_fd_sc_lp library to implement the module.\n\n", "output": "module signal_converter(\n    input A1_N,\n    input A2_N,\n    input B1,\n    input B2,\n    output reg X\n);\n\n    always @(*) begin\n        if (A1_N==0 && A2_N==0) begin\n            X = B1;\n        end else if (A1_N==0 && A2_N==1) begin\n            X = B2;\n        end else if (A1_N==1 && A2_N==0) begin\n            X = ~B1;\n        end else if (A1_N==1 && A2_N==1) begin\n            X = ~B2;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-to-1 multiplexer. The module should have four input ports, one output port, and two select lines. The output of the module should be equal to the value of the input port selected by the select lines. The module should be named `mux4to1` and should be designed to be synthesizable.\n\nYour module should have the following ports:\n- `in0`, `in1`, `in2`, `in3`: 4-bit input ports\n- `out`: 4-bit output port\n- `sel0`, `sel1`: 2-bit select lines\n\nYour module should implement the following truth table:\n```\nsel1 sel0 | out\n---------|----\n  0   0   | in0\n  0   1   | in1\n  1   0   | in2\n  1   1   | in3\n```\n\n", "output": "module mux4to1 (\n    in0,\n    in1,\n    in2,\n    in3,\n    out,\n    sel0,\n    sel1\n);\n\n    input [3:0] in0, in1, in2, in3;\n    output [3:0] out;\n    input sel0, sel1;\n\n    wire [3:0] sel;\n\n    assign sel = {sel1, sel0};\n\n    always @(*) begin\n        case (sel)\n            2'b00: out = in0;\n            2'b01: out = in1;\n            2'b10: out = in2;\n            2'b11: out = in3;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a 4:1 multiplexer. The module should take in two 1-bit inputs, `in0` and `in1`, and two select lines, `sel0` and `sel1`. If `sel1` and `sel0` are both 0, the output should be 0. If `sel1` is 0 and `sel0` is 1, the output should be `in0`. If `sel1` is 1 and `sel0` is 0, the output should be `in1`. If `sel1` and `sel0` are both 1, the output should be undefined (`x`).\n\nYour module should be named `mux4` and should have the following inputs and outputs:\n- `dout`: a 1-bit output representing the output of the multiplexer\n- `in0`: a 1-bit input representing the first input to the multiplexer\n- `in1`: a 1-bit input representing the second input to the multiplexer\n- `sel0`: a 1-bit input representing the least significant select line\n- `sel1`: a 1-bit input representing the most significant select line\n\nYou should implement the module using behavioral Verilog.\n\n", "output": "module mux4 (dout, in0, in1, sel0, sel1);\n\n  output dout;\n  input in0, in1, sel0, sel1;\n\n  reg dout;\n\n  always @ (sel1 or sel0 or in0 or in1) begin\n    case ({sel1, sel0})\n      2'b00: dout = 1'b0;\n      2'b01: dout = in0;\n      2'b10: dout = in1;\n      2'b11: dout = 1'bx;\n    endcase\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Build a module that implements a 3-bit up/down counter with asynchronous reset. The counter should increment or decrement based on a control input, with a value of 0 incrementing and a value of 1 decrementing. The counter should reset to 0 when the asynchronous reset input is high.", "output": "module updown_counter (\n    input clk,\n    input reset,\n    input control,\n    output reg [2:0] count\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            count <= 3'b0;\n        end else begin\n            if (control == 0) begin\n                count <= count + 1;\n            end else begin\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that takes in three inputs A, B, and C_N, and outputs X. The module should implement an OR gate with three inputs. The module should also have inputs VPWR, VGND, VPB, and VNB. These inputs are power and ground connections, as well as voltage connections for the module. The module should be named \"my_or_gate\" and should be implemented within 200 lines of verilog code.\n\n", "output": "module my_or_gate (\n    input A,\n    input B,\n    input C_N,\n    output X,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\nwire AB, ABC_N;\n\nassign AB = A | B;\nassign ABC_N = AB | C_N;\nassign X = ABC_N;\n\nsky130_fd_sc_hdll__or3b_4 base (\n    .X(X),\n    .A(A),\n    .B(B),\n    .C_N(C_N),\n    .VPWR(VPWR),\n    .VGND(VGND),\n    .VPB(VPB),\n    .VNB(VNB)\n);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module for a 2-to-1 multiplexer. The module should have two input ports, one select port, and one output port. When the select input is high, the output should be equal to the first input. When the select input is low, the output should be equal to the second input. \n\nYou should name your module \"mux2to1\".\n\n", "output": "module mux2to1 (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    assign out = (sel == 1'b1) ? a : b;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two inputs, `data_in` and `mask_in`, and generates an output `data_out`. The module should be able to perform the following operations:\n- When `mask_in` is 0, `data_out` should be the same as `data_in`.\n- When `mask_in` is 1, the upper 4 bits of `data_in` should be set to 0, and the lower 4 bits of `data_in` should be set to the value of `data_in`'s upper 4 bits.\n- When `mask_in` is 2, the lower 4 bits of `data_in` should be set to 0, and the upper 4 bits of `data_in` should be set to the value of `data_in`'s lower 4 bits.\n- When `mask_in` is 3, `data_out` should be the bitwise AND of `data_in` and `0xF0`.\n\nWrite a Verilog module that implements the above functionality. The module should have the following interface:\n\n```\nmodule data_mask(\n  input [7:0] data_in,\n  input [1:0] mask_in,\n  output reg [7:0] data_out\n);\n```\n\n", "output": "module data_mask(\n  input [7:0] data_in,\n  input [1:0] mask_in,\n  output reg [7:0] data_out\n);\n\n  always @* begin\n    case(mask_in)\n      2'b00: data_out = data_in;\n      2'b01: data_out = {4'b0000, data_in[7:4]};\n      2'b10: data_out = {data_in[3:0], 4'b0000, data_in[7:4]};\n      2'b11: data_out = data_in & 8'b11110000;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in six input signals, A1, A2, B1, B2, C1, and produces one output signal X. The module should be named \"logic_gate\" and should implement the following logic equation:\n\nX = A1 AND A2 AND (B1 OR B2) AND (NOT C1)\n\nUse the given code snippet as a starting point for your module, and ensure that all input and output signals are defined correctly. Additionally, make sure to include any necessary logic gates to implement the required logic equation.\n\n", "output": "module logic_gate (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    output reg X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    always @(*) begin\n        X = (A1 & A2 & (B1 | B2) & ~C1);\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an audio codec block. \nAn audio codec block is a digital circuit that can encode or decode digital audio signals. \nThe inputs to the circuit are the digital audio signals, and the outputs are the encoded or decoded digital audio signals. \nThe circuit can be configured to support different audio formats such as MP3, AAC, or WMA.\nYour module should have the following inputs and outputs:\n\nInputs: a set of n input digital audio signals (audio_in)\nOutputs: a set of m output digital audio signals (audio_out)\nThe module should also have the following parameters:\n\nn: the number of input digital audio signals\nm: the number of output digital audio signals\naudio_format: the audio format to be supported (MP3, AAC, or WMA)\nYour module should implement the following functionality:\n\nThe circuit should be able to encode or decode digital audio signals in the selected audio format.\nThe circuit should use appropriate algorithms to process the digital audio signals and generate the encoded or decoded digital audio signals.\nTo implement the audio codec block, you should use Verilog code to define the algorithms for encoding or decoding digital audio signals in the selected audio format. \nYou should then use these algorithms to process the input digital audio signals and generate the output digital audio signals.\nFinally, you should use the output digital audio signals to verify the correctness of your audio codec block implementation.", "output": "module audio_codec (\n  input [n-1:0] audio_in,\n  output [m-1:0] audio_out\n);\n\nparameter n = 16; // number of input digital audio signals\nparameter m = 16; // number of output digital audio signals\nparameter audio_format = \"MP3\"; // selected audio format (MP3, AAC, or WMA)\n\n// Verilog code to implement audio codec block goes here\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. You are required to design a Verilog module that implements a 4-bit binary to gray code converter. Gray code is a binary numeral system in which two successive values differ in only one bit. A Gray code sequence must begin with 0. You can implement the module using any method you prefer, but keep in mind that the module should be able to convert 4-bit binary numbers into their corresponding Gray code values.", "output": "module bin2gray(\n  input [3:0] binary,\n  output reg [3:0] gray\n);\n\n  always @ (binary) begin\n    gray[3] = binary[3];\n    gray[2] = binary[3] ^ binary[2];\n    gray[1] = binary[2] ^ binary[1];\n    gray[0] = binary[1] ^ binary[0];\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four inputs and produces one output. The module should be implemented in Verilog and should be no more than 200 lines of code. The module should be named `four_input_one_output` and should have the following inputs and outputs:\n\nInputs:\n- `a` (1-bit)\n- `b` (1-bit)\n- `c` (1-bit)\n- `d` (1-bit)\n\nOutputs:\n- `out` (1-bit)\n\nThe module should implement the following logic:\n- If `a` is 1, `out` should be 1.\n- If `a` is 0 and `b` is 1, `out` should be 1.\n- If `a` is 0, `b` is 0, and `c` is 1, `out` should be 1.\n- If `a` is 0, `b` is 0, `c` is 0, and `d` is 1, `out` should be 1.\n- In all other cases, `out` should be 0.\n\nImplement the `four_input_one_output` module in Verilog and test it using a testbench. The testbench should cover all possible input combinations.\n\n", "output": "module four_input_one_output (\n    input a,\n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    if (a) begin\n        out = 1;\n    end else if (b) begin\n        out = 1;\n    end else if (c) begin\n        out = 1;\n    end else if (d) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a circuit that incorporates a D flip-flop with enable and set functionality. The circuit should be implemented in Verilog and should be contained within a single module with no more than 200 lines of code.\n\nThe module should have the following inputs and outputs:\n- `C`: a clock input\n- `E`: an enable input\n- `S`: a set input\n- `D`: a data input\n- `Q`: a data output\n\nThe circuit should operate as follows:\n- When `E` is high, the circuit should be enabled and the flip-flop should be able to store data.\n- When `S` is high, the output `Q` should be set to 1 regardless of the value of `D`.\n- When `S` is low and `E` is high, the output `Q` should take on the value of `D` on the falling edge of the clock `C`.\n\nImplement the circuit as a single module in Verilog.\n\n", "output": "module dff_with_enable_and_set(output Q, input C, E, S, D);\n    reg Q;\n\n    always @(negedge C) begin\n        if (E) begin\n            if (S) begin\n                Q <= 1;\n            end else begin\n                Q <= D;\n            end\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit input `in_data` and outputs a 2-bit value `out_data` based on the following truth table:\n\n| in_data | out_data |\n| ------- | -------- |\n| 0000    | 00       |\n| 0001    | 01       |\n| 0010    | 10       |\n| 0011    | 11       |\n| 0100    | 00       |\n| 0101    | 01       |\n| 0110    | 10       |\n| 0111    | 11       |\n| 1000    | 00       |\n| 1001    | 01       |\n| 1010    | 10       |\n| 1011    | 11       |\n| 1100    | 00       |\n| 1101    | 01       |\n| 1110    | 10       |\n| 1111    | 11       |\n\nWrite a verilog module `truth_table` that implements this truth table.\n\n", "output": "module truth_table (\n  input [3:0] in_data,\n  output reg [1:0] out_data\n);\n\nalways @* begin\n  case (in_data)\n    4'b0000, 4'b0100, 4'b1000, 4'b1100: out_data = 2'b00;\n    4'b0001, 4'b0101, 4'b1001, 4'b1101: out_data = 2'b01;\n    4'b0010, 4'b0110, 4'b1010, 4'b1110: out_data = 2'b10;\n    4'b0011, 4'b0111, 4'b1011, 4'b1111: out_data = 2'b11;\n  endcase\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module for a D-latch with reset and enable. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: a clock signal\n- `D`: a data input signal\n- `RESET`: a synchronous reset signal\n- `EN`: an enable signal\n\nOutputs:\n- `Q`: a data output signal\n- `Q_N`: the complement of the data output signal\n\nThe module should follow the following behavior:\n- When `RESET` is asserted, both `Q` and `Q_N` should be set to 0.\n- When `EN` is de-asserted, the output should hold its previous value.\n- When `EN` is asserted, the output should follow the input `D`.\n- The output should only change on the rising edge of the clock signal `CLK`.\n\nWrite a Verilog module that implements this behavior within 200 lines of code.\n\n", "output": "module d_latch (\n    input CLK,\n    input D,\n    input RESET,\n    input EN,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (EN) begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 8-bit barrel shifter. The module should have three inputs (in, shift, and direction) and one output (out). The shift input should be a 3-bit value that determines the amount of shifting. The direction input should be 0 for left shift and 1 for right shift. The output out should be the result of the shifting operation.", "output": "module barrel_shifter_8bit (\n    input [7:0] in,\n    input [2:0] shift,\n    input direction,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (direction == 0) // Left shift\n            out = {in[shift[2]:7], in[6:shift[2]]};\n        else // Right shift\n            out = {in[1+shift[2]:0], in[7:1+shift[2]]};\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 16-bit adder/subtractor. The circuit should have three inputs, two 16-bit binary numbers (A and B) and a control input (C). If C is high, the circuit should perform subtraction (A - B). If C is low, the circuit should perform addition (A + B). The circuit should have a single 16-bit output (Q) that represents the result.", "output": "module addsub (\n    input [15:0] A,\n    input [15:0] B,\n    input C,\n    output [15:0] Q\n);\n\n    assign Q = (C == 1'b1) ? A - B : A + B;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a Gray code converter. \nGray code is a binary code where any two consecutive values differ in only one bit position. \nThe task of the Gray code converter is to convert a binary code into a Gray code or vice versa. \n\nYour module should have the following inputs and outputs:\n\nInputs: a binary signal (bin)\nOutputs: a Gray code signal (gray)\nThe module should also have the following parameter:\n\nn: the number of bits in the binary code and Gray code\nYour module should implement the following functionality:\n\nIf the input is a binary code, the module should convert it to a Gray code and output the Gray code.\nIf the input is a Gray code, the module should convert it to a binary code and output the binary code.\n\nTo implement the Gray code converter, you should use Verilog code to define the conversion between binary and Gray code. \nYou can use bitwise operations to perform the conversion. \nFor example, to convert a binary code to a Gray code, you can use the following formula:\n\ngray = bin ^ (bin >> 1);\n\nTo convert a Gray code to a binary code, you can use the following formula:\n\nbin = gray ^ (gray >> 1);\n\nYou should then use these formulas to connect the input to the conversion logic and the conversion logic to the output.", "output": "module GrayCodeConverter (\n  input [n-1:0] bin,\n  output [n-1:0] gray\n);\n\nparameter n = 4; // number of bits in binary and Gray code\n\n// Binary to Gray conversion\nassign gray = bin ^ (bin >> 1);\n\n// Gray to Binary conversion\nassign bin = gray ^ (gray >> 1);\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module named `xor_32` that computes the XOR of two 32-bit inputs `a` and `b` and produces a 32-bit output `out`. The module uses 32 separate `assign` statements to compute each bit of the output. Your task is to refactor the module to use a single `assign` statement to compute the entire output.\n\nWrite a new Verilog module named `xor_32_refactored` that performs the same function as `xor_32` but uses a single `assign` statement to compute the output. Your module should have the same input and output ports as `xor_32`. You should not use any other modules or Verilog constructs besides `assign` statements.\n\n", "output": "module xor_32_refactored(\n\tinput [31:0] a, //input values\n\tinput [31:0] b,\n\toutput [31:0] out //output value\n\t);\n\n\t//output is the XOR of a and b\n\tassign out = a ^ b;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in a 4-bit input signal `a` and outputs a 4-bit signal `b`. The output signal `b` is the result of a bitwise XOR operation between the input signal `a` and a constant 4-bit value `c`.\n\nDesign a Verilog module that takes in a 4-bit input signal `a` and outputs a 4-bit signal `b`. The module should include the following:\n- A 4-bit input port named `a`\n- A 4-bit output port named `b`\n- A 4-bit constant value named `c` that is set to `4'b1011`\n- A combinational logic block that performs the XOR operation between `a` and `c` and assigns the result to `b`\n\nYour Verilog module should be named `xor_module`.\n\n", "output": "module xor_module(\n    input [3:0] a,\n    output [3:0] b\n);\n\n    // Define constant value\n    parameter [3:0] c = 4'b1011;\n\n    // Perform XOR operation between a and c\n    assign b = a ^ c;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit shift register with serial input and parallel output. The module should have the following ports:\n\n- `clk`: clock input\n- `reset`: active-high asynchronous reset input\n- `serial_in`: serial input\n- `parallel_out`: 4-bit parallel output\n\nThe shift register should shift the data in `serial_in` into the register on every rising edge of the clock, and output the current contents of the register on `parallel_out` on every falling edge of the clock. The shift register should be reset to all zeros when `reset` is asserted.\n\nWrite the verilog code for the shift register module.\n\n", "output": "module shift_register(clk, reset, serial_in, parallel_out);\n  input clk, reset, serial_in;\n  output [3:0] parallel_out;\n\n  reg [3:0] register;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      register <= 4'b0;\n    end else begin\n      register <= {register[2:0], serial_in};\n    end\n  end\n\n  always @(negedge clk) begin\n    parallel_out <= register;\n  end\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a synchronous reset D flip-flop with set and clear capabilities. The module should have the following inputs and outputs:\n- Input `CLK` is the clock signal.\n- Input `D` is the data signal.\n- Input `RESET` is the reset signal that asynchronously resets the flip-flop to 0.\n- Input `SET` is the set signal that asynchronously sets the flip-flop to 1.\n- Output `Q` is the output of the flip-flop.\n\nThe module should be named `sync_reset_D_flipflop_set_clear` and should be designed in Verilog. The module should have a single always block that implements the flip-flop logic.\n\n", "output": "module sync_reset_D_flipflop_set_clear (\n    Q      ,\n    CLK    ,\n    D      ,\n    RESET  ,\n    SET\n);\n\n    output Q      ;\n    input  CLK    ;\n    input  D      ;\n    input  RESET  ;\n    input  SET    ;\n\n    reg Q;\n\n    always @(posedge CLK or posedge RESET or posedge SET) begin\n        if (RESET) begin\n            Q <= 0;\n        end else if (SET) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that can perform a specific operation on input signals. The module should be named \"opModule\" and should have the following inputs and outputs:\n\nInputs:\n- clk (1-bit): the clock signal\n- iA (4-bit): the first input signal\n- iB (4-bit): the second input signal\n- iC (1-bit): a control signal that determines the operation to be performed\n    - If iC is 0, the module should output the bitwise AND of iA and iB\n    - If iC is 1, the module should output the bitwise OR of iA and iB\n\nOutputs:\n- oResult (4-bit): the result of the operation\n\nThe module should be designed using behavioral Verilog and should be completely self-contained. You should not use any other modules in your design.\n\n", "output": "module opModule (clk, iA, iB, iC, oResult);\n    input clk;\n    input [3:0] iA;\n    input [3:0] iB;\n    input iC;\n    output [3:0] oResult;\n\n    always @(posedge clk) begin\n        if (iC == 0) begin\n            oResult <= iA & iB;\n        end else begin\n            oResult <= iA | iB;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary counter with synchronous reset. The module should have one input clock signal `clk`, one input reset signal `rst`, and one output `out` that is the current count value. The counter should increment on the rising edge of the clock signal and reset to 0 on the rising edge of the reset signal. \n\nWrite the verilog code for the module and ensure that it follows the given specifications. \n\n", "output": "module binary_counter(clk, rst, out);\n   input clk, rst;\n   output reg [3:0] out;\n   \n   always @(posedge clk) begin\n      if (rst) begin\n         out <= 4'b0;\n      end else begin\n         out <= out + 1;\n      end\n   end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 8-bit adder with carry-in and carry-out signals. The module should have three input signals: `A`, `B`, and `Cin` representing the two 8-bit numbers to be added and the carry-in bit, respectively. The module should also have two output signals: `Sum` representing the sum of the two input numbers and `Cout` representing the carry-out bit.\n\nThe Verilog module should be named `adder_8bit` and should be designed to be synthesizable. The module should only use combinational logic and should not use any sequential logic or memory elements. The module should be self-contained and should not rely on any external modules.\n\nYou must write the Verilog code for the `adder_8bit` module within 200 lines of code. Your code should be well-commented and easy to read.\n\n", "output": "module adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    wire [8:0] tempSum;\n    wire [7:0] tempA;\n    wire [7:0] tempB;\n    \n    assign tempA = {Cin, A};\n    assign tempB = {Cin, B};\n    \n    assign tempSum = tempA + tempB;\n    \n    assign Sum = tempSum[7:0];\n    assign Cout = tempSum[8];\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple calculator. The calculator should be able to perform basic arithmetic operations such as addition, subtraction, multiplication, and division on 32-bit signed integers. The module should have two input ports, one for the operation to be performed and the other for the operands, and one output port for the result. The operation input port should be a 2-bit signal with the following encoding:\n- 00: addition\n- 01: subtraction\n- 10: multiplication\n- 11: division\n\nThe operand input port should be a 64-bit signed integer, with the first 32 bits representing the first operand and the second 32 bits representing the second operand. The output port should also be a 32-bit signed integer representing the result of the operation.\n\nYour module should implement the calculator functionality in less than 200 lines of Verilog code.\n\n", "output": "module simple_calculator(\n    input [1:0] operation,\n    input signed [63:0] operands,\n    output signed [31:0] result\n);\n\nreg signed [31:0] op1;\nreg signed [31:0] op2;\nreg signed [31:0] res;\n\nalways @(*) begin\n    op1 = operands[31:0];\n    op2 = operands[63:32];\n    case(operation)\n        2'b00: res = op1 + op2; // Addition\n        2'b01: res = op1 - op2; // Subtraction\n        2'b10: res = op1 * op2; // Multiplication\n        2'b11: res = op1 / op2; // Division\n    endcase\nend\n\nassign result = res;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in six inputs and produces one output. The input signals are A1, A2, B1, B2, C1, VPB, VPWR, VGND, and VNB. The output signal is Y. \n\nThe module should be named \"six_input_module\". The inputs and outputs should be declared in the module header. The inputs A1, A2, B1, B2, and C1 are data signals, while VPB, VPWR, VGND, and VNB are power signals. The output Y is also a data signal. \n\nThe module should implement the following logic: \n- If A1 and A2 are both 1, and B1 and B2 are both 0, then Y should be 1.\n- If A1 and A2 are both 0, and B1 and B2 are both 1, then Y should be 0.\n- If C1 is 1, then Y should be 1.\n- If none of the above conditions are met, then Y should be 0.\n\nImplement the \"six_input_module\" and test it using the following test cases:\n- A1 = 1, A2 = 1, B1 = 0, B2 = 0, C1 = 0 -> Y = 0\n- A1 = 0, A2 = 0, B1 = 1, B2 = 1, C1 = 0 -> Y = 1\n- A1 = 0, A2 = 0, B1 = 0, B2 = 0, C1 = 1 -> Y = 1\n- A1 = 1, A2 = 0, B1 = 1, B2 = 0, C1 = 0 -> Y = 0\n\n\n", "output": "module six_input_module (\n    input A1, A2, B1, B2, C1, VPB, VPWR, VGND, VNB, \n    output Y\n);\n\n    assign Y = ((A1 & A2 & ~B1 & ~B2) | (~A1 & ~A2 & B1 & B2) | C1) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that will take in a 4-bit binary number and output a 3-bit binary number representing the range of memory indices that the input number falls within. The memory array has 4096 elements, and each memory element is a single bit. The memory array is defined as `reg mem[4095:0]`. \n\nYou must design a module called `memidxrng` that takes in a 4-bit binary number `in_num`, and outputs a 3-bit binary number `out_num` representing the range of memory indices that the input number falls within. Specifically, the output `out_num` should be such that the memory indices `mem[out_num*8 +: 8]` to `mem[out_num*8 + 7 -: 8]` (inclusive) are the ones that the input number falls within. \n\nFor example, if the input number is `0101`, then the output number should be `000`, indicating that the memory indices `mem[0:7]` are the ones that the input number falls within. \n\nYou should assume that the module has a clock input, a reset input, and an enable input. When the enable input is high, the module should output the correct `out_num` value for the given `in_num`. When the enable input is low, the module should output a default value of `000`. \n\nYou should also assume that the module has been instantiated in a testbench, and that the testbench will provide appropriate values for the inputs. \n\nWrite the `memidxrng` module in Verilog.\n\n", "output": "module memidxrng (\n   input clk,\n   input rst,\n   input en,\n   input [3:0] in_num,\n   output reg [2:0] out_num\n);\n\n   reg [11:0] mem_idx;\n\n   always @(posedge clk, posedge rst)\n   begin\n      if (rst)\n         mem_idx <= 12'h0;\n      else if (en)\n         mem_idx <= mem_idx + 1;\n   end\n\n   always @(posedge clk)\n   begin\n      if (rst)\n         out_num <= 3'h0;\n      else if (en)\n         out_num <= mem_idx[11:9];\n      else\n         out_num <= 3'h0;\n   end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that performs a simple mathematical operation on two 4-bit inputs. The module should have two inputs, `a` and `b`, and one output, `result`. The operation to be performed is as follows: `result = a + (2 * b)`. \n\nYou will need to create a module that takes in two 4-bit inputs, `a` and `b`, and performs the above mathematical operation. The output `result` should be a 4-bit value.\n\nPlease write a verilog module that performs this operation and ensure that your module is synthesizable.\n\n", "output": "module math_operation(\n   input wire [3:0] a,\n   input wire [3:0] b,\n   output wire [3:0] result\n);\n\n   assign result = a + (2 * b);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a 3-bit synchronous up-counter with an asynchronous reset signal. The counter should count from 0 to 7 and then wrap around to 0 again. The counter should increment on the rising edge of the clock signal. The output should be displayed on the 3-bit output port. The counter should reset to 0 when the asynchronous reset signal is asserted.", "output": "module up_counter (\n  input clk,\n  input reset,\n  output reg [2:0] count\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      count <= 0;\n    end else begin\n      if (count == 7) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a digital logic circuit. The module should have the following input/output signals:\n\n- A single data input signal named \"D\"\n- A single output signal named \"Q\"\n- A control signal named \"RESET_B\"\n- A clock signal named \"GATE\"\n\nIn addition to these signals, the module should have four voltage supply signals named \"VPWR\", \"VGND\", \"VPB\", and \"VNB\".\n\nYour task is to write a verilog module that implements this circuit. The module should have the following behavior:\n\n- When the \"RESET_B\" signal is low, the output signal \"Q\" should be set to 0.\n- When the \"RESET_B\" signal is high, the output signal \"Q\" should be set to the value of the input signal \"D\" on the rising edge of the \"GATE\" signal.\n\nYou may assume that the input signal \"D\" is stable when the \"GATE\" signal is low.\n\nWrite a verilog module that meets these requirements. Your module should be no more than 200 lines of code.\n\n", "output": "module digital_circuit (\n    input D,\n    output Q,\n    input RESET_B,\n    input GATE\n);\n\n    reg Q_reg;\n\n    always @(posedge GATE) begin\n        if (RESET_B == 0) begin\n            Q_reg <= 0;\n        end else begin\n            Q_reg <= D;\n        end\n    end\n\n    assign Q = Q_reg;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a D-latch with an active-low reset and an active-high gate. The module should have the following inputs and outputs:\n\nInputs:\n- D: Data input\n- GATE: Active-high gate input\n- RESET: Active-low reset input\n- VPWR: Positive power supply voltage\n- VGND: Ground reference voltage\n\nOutputs:\n- Q: Latched output\n\nThe D-latch should operate as follows:\n- When the gate input is high, the D-latch should transparently pass the data input to the output.\n- When the gate input is low, the D-latch should hold the previous value of the data input at the output.\n- When the reset input is low, the output should be forced to a low state regardless of the state of the gate and data inputs.\n\nYour task is to design a Verilog module that implements this D-latch functionality. Your module should be self-contained and should not rely on any external modules or libraries. Your module should also be less than 200 lines of Verilog code.\n\n", "output": "module d_latch (\n    input D,\n    input GATE,\n    input RESET,\n    input VPWR,\n    input VGND,\n    output Q\n);\n\n    wire nGATE;\n    wire nRESET;\n    wire nD;\n\n    assign nGATE = ~GATE;\n    assign nRESET = ~RESET;\n    assign nD = ~D;\n\n    wire Qbar;\n    wire Qbarbar;\n\n    and and1 (Qbar, nD, nGATE, VPWR, VGND);\n    and and2 (Qbarbar, D, nGATE, VPWR, VGND);\n\n    nor nor1 (Q, Qbar, nRESET, VPWR, VGND);\n    nor nor2 (Q, Qbarbar, RESET, VPWR, VGND);\n\nendmodule"}
{"instruction": "Create a module that can detect the falling edges of a 32-bit input signal. The output should be a 32-bit vector, where each bit represents a corresponding bit in the input signal. When a falling edge is detected on a specific bit, the corresponding bit in the output should be set to 1 and remain 1 until a synchronous reset signal is received. The module should be designed using a combination of shift register and comparator.", "output": "module falling_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 0;\n        out <= 0;\n    end else begin\n        shift_reg <= {shift_reg[30:0], in};\n        out <= out & ~shift_reg;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that implements a 4-bit Gray code counter with an asynchronous reset input. The module should have four outputs, Q3, Q2, Q1, and Q0, representing the counter value in Gray code. The module should also have one input, reset. When reset is high, the counter should be reset to 0.", "output": "module gray_code_counter (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q ^ (Q >> 1);\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nWrite a verilog module named \"counter\" that counts from 0 to 15 and then resets back to 0. The module should have two inputs and one output. The first input is a clock signal with a frequency of 10MHz. The second input is a reset signal that resets the counter to 0 when it is high. The output is a 4-bit binary number that represents the current count value.\n\n", "output": "module counter (\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0000;\n    end else begin\n      if (count == 4'b1111) begin\n        count <= 4'b0000;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in two inputs, `c_in` and `d_in`, and outputs `out1`. The `out1` output should be the result of a bitwise XOR operation between `temp` and `d_in`. The `temp` signal should be the result of a bitwise AND operation between `c_in` and `d_in`.\n\nWrite a Verilog module that implements the above functionality. Your module should be named `xor_and` and should have the following ports:\n- `c_in`: input bit\n- `d_in`: input bit\n- `out1`: output bit\n\n", "output": "module xor_and(\n        c_in,\n        d_in,\n        out1\n    );\n\n    // SIGNAL DECLARATIONS\n    input c_in;\n    input d_in;\n    output out1;\n    wire out1;\n    wire temp;\n\n    assign temp = c_in & d_in;\n    assign out1 = temp ^ d_in;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two inputs, `A` and `B`, and outputs the sum of the two inputs, `sum`. The inputs and output are all 8-bit unsigned integers. The module should be named `adder_8bit`.\n\nYour module should include the following ports:\n- `A`: an 8-bit unsigned integer input\n- `B`: an 8-bit unsigned integer input\n- `sum`: an 8-bit unsigned integer output\n\nYour module should use the following verilog constructs:\n- `always` block\n- `assign` statement\n- `reg` declaration\n\nYou should design your module in such a way that it can be synthesized and implemented on an FPGA.\n\n", "output": "module adder_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum\n);\n\n    reg [7:0] temp_sum;\n\n    always @ (A, B) begin\n        temp_sum = A + B;\n    end\n\n    assign sum = temp_sum;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that will take in four input signals and output a single signal. The input signals are named A1, A2, A3, and B1, and the output signal is named X. The module should be named \"my_module\".\n\nThe input signals are all of type \"input\", and the output signal is of type \"output\". The module should be designed to be compatible with the sky130_fd_sc_hs__o31a_4 module.\n\nThe module should be designed to perform the following logic:\n\n- If A1 is high and A2 is low, then X should be high.\n- If A1 is low and A2 is high, then X should be low.\n- If A1 and A2 are both high, then X should be high if A3 is high and B1 is low, and low otherwise.\n- If A1 and A2 are both low, then X should be high if A3 is low and B1 is high, and low otherwise.\n\nYour task is to implement this module in Verilog. The module should be no more than 200 lines of code.\n\n", "output": "module my_module (\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    assign X = ((A1 & ~A2) | (A2 & ~A1 & A3 & ~B1) | (~A1 & ~A2 & ~A3 & B1)) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit ripple carry adder. The module should have two input ports, A and B, each 4 bits wide, and an output port, S, also 4 bits wide. The module should also have a carry-out port, Cout, which is a single bit. The module should operate on the rising edge of the clock signal, Clk. The module should use only basic Verilog operators and no built-in adder modules.\n\n", "output": "module ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Clk,\n    output [3:0] S,\n    output Cout\n);\n\nreg [3:0] S_reg;\nreg Cout_reg;\n\nalways @(posedge Clk) begin\n    // add the two inputs and the carry-in\n    S_reg = A + B + Cout_reg;\n    // determine the carry-out\n    Cout_reg = (A[3] & B[3]) | (A[3] & Cout_reg) | (B[3] & Cout_reg);\nend\n\nassign S = S_reg;\nassign Cout = Cout_reg;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module for a circuit called \"sky130_fd_sc_hs__a22oi\". This circuit has one output signal \"Y\" and four input signals \"A1\", \"A2\", \"B1\", and \"B2\". In addition, the circuit has two voltage supply signals \"VPWR\" and \"VGND\". \n\nYour module should be able to take in the four input signals and output a value for \"Y\". You should assume that the input signals are binary and that the output signal is also binary. \n\nYour module should be written in Verilog and should be no more than 200 lines of code. Your code should be well-structured and easy to understand. \n\n", "output": "module sky130_fd_sc_hs__a22oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    // assign Y to the AND of A1, A2, B1, and B2\n    assign Y = A1 & A2 & B1 & B2;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a Verilog module that implements a 3-input XOR gate using a combination of a 2-input XOR gate and a 2-input OR gate. In this design, utilize both an assign statement and a combinational always block. The output of the module should be the result of the 3-input XOR gate.", "output": "module xor_gate(input a, b, c, output out);\n\n  assign out = (a ^ b) ^ c;\n\n  always @ (a, b, c)\n    begin\n      out = (a ^ b) ^ c;\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-to-2 priority encoder with an enable input. The priority encoder should output the position of the highest value input bit that is high. If none of the input bits are high, the output should be zero. When the enable input is low, the output should be zero regardless of the input values.", "output": "module priority_encoder (\n    input [3:0] in,\n    input enable,\n    output reg [1:0] pos\n);\n\nalways @ (in or enable) begin\n    if (enable == 1'b0) begin\n        pos <= 2'b0;\n    end\n    else if (in[3] == 1'b1) begin\n        pos <= 2'b11;\n    end\n    else if (in[2] == 1'b1) begin\n        pos <= 2'b10;\n    end\n    else if (in[1] == 1'b1) begin\n        pos <= 2'b01;\n    end\n    else if (in[0] == 1'b1) begin\n        pos <= 2'b00;\n    end\n    else begin\n        pos <= 2'b0;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 4-to-1 multiplexer (mux). The module should have four inputs (I0, I1, I2, I3) and one output (F). The module should also have a select input (S) that determines which input is selected for output. If S is 2'b00, the output should be I0; if S is 2'b01, the output should be I1; if S is 2'b10, the output should be I2; and if S is 2'b11, the output should be I3. \n\nYou should implement the module using a behavioral approach. You should also use blocking assignments to assign values to the output F and non-blocking assignments to assign values to any intermediate signals.\n\nAssume that all inputs and outputs are 1-bit wide.\n\n", "output": "module mux4to1(I0, I1, I2, I3, S, F);\n    input I0, I1, I2, I3;\n    input [1:0] S;\n    output F;\n\n    reg F;\n\n    always @(*) begin\n        case (S)\n            2'b00: F = I0;\n            2'b01: F = I1;\n            2'b10: F = I2;\n            2'b11: F = I3;\n        endcase\n    end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a watchdog timer. \nA watchdog timer is a hardware component that is used to monitor the proper functioning of a system. \nIt is a timer that is programmed to trigger an action if it doesn't receive a \"reset\" signal within a certain amount of time. \nIn other words, if the system hangs or stops working, the watchdog timer will trigger a reset signal, which will restart the system.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- clk: the clock signal of the system\n- reset: the reset signal of the system\n- timer_duration: the duration of the timer in clock cycles\n\nOutputs: \n- timer_reset: the reset signal triggered by the watchdog timer\n\nYour module should implement the following functionality:\n\n- When the system is working properly, the watchdog timer should be reset by a signal from the system, such as a heartbeat signal.\n- If the watchdog timer doesn't receive a reset signal within the specified duration, it should trigger a timer reset signal.\n- The timer reset signal should be active for one clock cycle and then go back to its inactive state.\n\nTo implement the watchdog timer, you should use Verilog code to count the clock cycles and compare it to the timer duration. \nIf the timer duration is exceeded, you should set the timer reset signal to active for one clock cycle. \nOtherwise, the timer reset signal should remain inactive.", "output": "module watchdog_timer (\n  input clk,\n  input reset,\n  input [31:0] timer_duration,\n  output reg timer_reset\n);\n\nreg [31:0] timer_count;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    timer_count <= 0;\n    timer_reset <= 0;\n  end else begin\n    timer_count <= timer_count + 1;\n    if (timer_count >= timer_duration) begin\n      timer_count <= 0;\n      timer_reset <= 1;\n    end else begin\n      timer_reset <= 0;\n    end\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a clock gating circuit that will be used in a larger ASIC design. The module must implement a D flip-flop with an enable signal and a clock enable signal. The module should take in a clock signal, an enable signal, and a trigger enable signal, and output a gated clock enable signal.\n\nThe Verilog module should be named \"my_clock_gate\" and should have the following inputs and outputs:\n\nInputs:\n- `clk` (1-bit): the clock signal\n- `en` (1-bit): the enable signal\n- `te` (1-bit): the trigger enable signal\n\nOutputs:\n- `enclk` (1-bit): the gated clock enable signal\n\nYour module should implement a D flip-flop with an enable signal and a clock enable signal. The clock enable signal should be gated using the trigger enable signal. The flip-flop should only update its output when the enable signal is high.\n\nYour module should be self-contained and should not rely on any external modules or libraries. Your solution should be implemented in Verilog and should be no more than 200 lines of code.\n\n", "output": "module my_clock_gate (\n  input clk,\n  input en,\n  input te,\n  output reg enclk\n);\n\nreg d;\n\nalways @(posedge clk) begin\n  if (en) begin\n    d <= 1'b1;\n  end else begin\n    d <= 1'b0;\n  end\nend\n\nalways @(posedge clk) begin\n  if (en) begin\n    if (te) begin\n      enclk <= 1'b1;\n    end else begin\n      enclk <= 1'b0;\n    end\n  end\nend\n\nendmodule"}
{"instruction": "Design a module that can perform XOR operation on two binary inputs using a non-clocked always block. The module should have two input ports, each capable of accepting a binary input. The output port should be able to provide the result of XOR operation. The module must be designed using a combinational logic architecture.", "output": "module xor_module(\n    input a,\n    input b,\n    output out_comb_logic\n);\n    \n    assign out_comb_logic = a ^ b;\n    \nendmodule"}
{"instruction": "\nYou are tasked with designing a combinational circuit that takes in four inputs, A1, A2, B1_N, and selects the output Y based on the following rules:\n- If A1 and A2 are both high, Y should be high.\n- If A1 is high and A2 is low, Y should be low.\n- If A1 is low and A2 is high, Y should be low.\n- If A1 and A2 are both low, Y should be high if and only if B1_N is high.\n\nYou must implement this circuit in a single module using Verilog. The module should have the following inputs and outputs:\n- Input A1: a single bit representing the A1 input.\n- Input A2: a single bit representing the A2 input.\n- Input B1_N: a single bit representing the B1_N input.\n- Output Y: a single bit representing the output of the circuit.\n\nYou may assume that all inputs are valid and will only be either high or low.\n\nYour task is to write the Verilog code for this module, ensuring that it is correct and meets the given specifications.\n\n", "output": "module combinational_circuit (\n    input A1,\n    input A2,\n    input B1_N,\n    output reg Y\n);\n\nalways @* begin\n    if (A1 && A2) begin\n        Y = 1;\n    end else if (A1 && !A2) begin\n        Y = 0;\n    end else if (!A1 && A2) begin\n        Y = 0;\n    end else begin\n        Y = B1_N;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module `r_FAULT_STATUS_MASK` that takes in a reset signal, a write enable signal (`wenb`), input data (`in_data`), and a clock signal. The module should output an 8-bit register `reg_0x15`. \n\nThe module should behave as follows:\n- When reset is high, `reg_0x15` should be cleared to 0x00.\n- When reset is low and `wenb` is low, `reg_0x15` should be updated with the value of `in_data`.\n- When reset is low and `wenb` is high, `reg_0x15` should remain unchanged.\n\nDesign a Verilog module that implements the above behavior. Your solution should include a module declaration and the necessary Verilog code to implement the functionality described above. \n\n", "output": "module r_FAULT_STATUS_MASK(\n    output reg [7:0] reg_0x15, \n    input wire reset, \n    input wire wenb, \n    input wire [7:0] in_data, \n    input wire clk\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        reg_0x15 <= 8'h00;\n    end\n    else begin\n        if (wenb == 0) begin\n            reg_0x15 <= in_data;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes two 4-bit inputs, A and B, and outputs the result of adding them together. The inputs and outputs should be of type `reg`. The module should be named `add4bits` and should be self-contained, i.e., it should not require any other modules to function.\n\nThe module should have the following ports:\n- `input [3:0] A`: a 4-bit input\n- `input [3:0] B`: a 4-bit input\n- `output [3:0] S`: a 4-bit output representing the sum of A and B\n\nYou should use the `always` block to implement the addition. The module should be able to handle overflow, i.e., if the sum of A and B requires more than 4 bits to represent, the most significant bit should be dropped.\n\n", "output": "module add4bits (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S\n);\n\n    reg [4:0] sum; // Declare a 5-bit register to handle overflow\n\n    always @* begin\n        sum = A + B; // Perform addition\n        if (sum > 15) // Check for overflow\n            S = sum[3:0]; // Drop the most significant bit\n        else\n            S = sum[3:0]; // No overflow, output the sum\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that generates a 4-bit binary counter. The counter should count from 0 to 15 and then reset back to 0. The module should have the following inputs and outputs:\n\nInputs:\n- clk: a clock signal\n- rst: a reset signal\n\nOutputs:\n- q: a 4-bit binary output representing the current count\n\nThe module should use the given code snippet as a template and should not use any other modules.\n\n", "output": "module binary_counter (\n    q,\n    clk,\n    rst\n);\n\n    output reg [3:0] q;\n    input clk;\n    input rst;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n            if (q == 4'b1111) begin\n                q <= 4'b0000;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in two 4-bit binary numbers and outputs their difference in binary. If the difference is negative, the output should be the two's complement of the absolute value of the difference.", "output": "module binary_subtractor (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] diff\n);\n\n    always @(*) begin\n        if (a >= b) begin\n            diff = a - b;\n        end else begin\n            diff = ~(b - a) + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes in four inputs and produces one output. The inputs are as follows:\n- `empty` (1-bit): indicates whether a first-in-first-out (FIFO) buffer is empty\n- `ge2_free` (1-bit): indicates whether at least two spaces in the FIFO buffer are free\n- `ge3_free` (1-bit): indicates whether at least three spaces in the FIFO buffer are free\n- `input_tm_cnt` (2-bit): indicates the number of items in the FIFO buffer (00 = empty, 01 = 1 item, 10 = 2 items, 11 = 3 items)\n\nThe output is as follows:\n- `fifo_cnt_inc` (5-bit): indicates the number of items to be added to the FIFO buffer\n\nYour task is to design a Verilog module that implements the following logic:\n- If the FIFO buffer is empty, `fifo_cnt_inc` should be set to the value of `input_tm_cnt[1:0]`\n- If there are at least three free spaces in the FIFO buffer and `input_tm_cnt` is 3, `fifo_cnt_inc` should be set to 2\n- If there are at least two free spaces in the FIFO buffer and `input_tm_cnt` is 2 or 3, `fifo_cnt_inc` should be set to 1\n- If there is at least one item in the FIFO buffer, `fifo_cnt_inc` should be set to 0\n- If none of the above conditions are met, `fifo_cnt_inc` should be set to a 5-bit value where all bits are 1.\n\nYour Verilog module should be self-contained and no more than 200 lines of code.\n\n", "output": "module fifo_controller (\n  input empty,\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [4:0] fifo_cnt_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifo_cnt_inc = input_tm_cnt[1:0];\n    end else if (ge3_free && (input_tm_cnt == 2'b11)) begin\n      fifo_cnt_inc = 2;\n    end else if (ge2_free && (input_tm_cnt >= 2)) begin\n      fifo_cnt_inc = 1;\n    end else if (input_tm_cnt >= 1) begin\n      fifo_cnt_inc = 0;\n    end else begin\n      fifo_cnt_inc = 5'b11111;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 12-bit multiplexer with 10 input ports. The module should have the following input and output ports:\n\nInput Ports:\n- I: a 12-bit input signal\n- in0 to in9: ten 12-bit input signals\n\nOutput Port:\n- O: a 12-bit output signal\n\nThe module should select one of the ten input signals to output based on a control signal. The control signal is a 4-bit input signal that indicates which input signal should be selected. The control signal should be decoded as follows:\n\nControl Signal Decoding:\n- 0000: select in0\n- 0001: select in1\n- 0010: select in2\n- 0011: select in3\n- 0100: select in4\n- 0101: select in5\n- 0110: select in6\n- 0111: select in7\n- 1000: select in8\n- 1001: select in9\n\nIf the control signal is not within the range of 0000 to 1001, the output signal should be set to 0.\n\nYour task is to design a Verilog module that implements this functionality within 200 lines of code.\n\n", "output": "module Span12Mux_s10_h(I, in0, in1, in2, in3, in4, in5, in6, in7, in8, in9, O);\n  input [11:0] I, in0, in1, in2, in3, in4, in5, in6, in7, in8, in9;\n  output [11:0] O;\n  input [3:0] select;\n  \n  always @(*) begin\n    case (select)\n      4'b0000: O = in0;\n      4'b0001: O = in1;\n      4'b0010: O = in2;\n      4'b0011: O = in3;\n      4'b0100: O = in4;\n      4'b0101: O = in5;\n      4'b0110: O = in6;\n      4'b0111: O = in7;\n      4'b1000: O = in8;\n      4'b1001: O = in9;\n      default: O = 12'b0;\n    endcase\n  end\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a 16-bit adder with a carry-in and a carry-out. The module should have two input ports, `A` and `B`, each 16 bits wide, and a single-bit input port `CIN` for the carry-in. The module should also have two output ports, `SUM` and `COUT`, each 16 bits wide, for the sum and carry-out, respectively.\n\nYour module should consist of a single `always` block that uses Verilog's `+` operator to add the input values and generate the output values. The `always` block should also handle the carry-in and carry-out logic. You may assume that the inputs and outputs are always valid.\n\nWrite a Verilog module that implements this 16-bit adder with a carry-in and a carry-out.\n\n", "output": "module adder16(\n    input [15:0] A,\n    input [15:0] B,\n    input CIN,\n    output [15:0] SUM,\n    output COUT\n);\n\nreg [15:0] sum_temp;\nreg cout_temp;\n\nalways @(*) begin\n    {cout_temp,sum_temp} = A + B + CIN;\nend\n\nassign SUM = sum_temp;\nassign COUT = cout_temp;\n\nendmodule"}
{"instruction": "Create a shift register of length 3 using Verilog. The shift register should have a single input port and a single output port, both of which are 1-bit wide. The shift register should be designed using a ring counter architecture.", "output": "module shift_register ( input clk, input d, output q );\n  reg [2:0] reg_data;\n  always @(posedge clk) begin\n    reg_data <= {reg_data[1:0], d};\n  end\n  assign q = reg_data[0];\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit synchronous counter. The counter should increment on the rising edge of the clock input and should reset to zero when a reset input is asserted. The counter output should be displayed on four output wires.\n\nYou are given the following code snippet as a starting point:\n\n```\nmodule synchronous_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] count\n);\n\n// your code here\n\nendmodule\n```\n\nUsing this code snippet, implement a synchronous counter that meets the requirements stated above. Your solution should include:\n\n1. A declaration for a 4-bit register to hold the current count value.\n2. A combinational logic block that increments the count register on the rising edge of the clock input.\n3. A synchronous reset block that resets the count register to zero when the reset input is asserted.\n4. A continuous assignment statement that assigns the value of the count register to the count output wires.\n\n", "output": "module synchronous_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] count\n);\n\nreg [3:0] count_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count_reg <= 4'b0;\n    end else begin\n        count_reg <= count_reg + 1;\n    end\nend\n\nassign count = count_reg;\n\nendmodule"}
{"instruction": "Design a module that implements a NOR gate using only NAND gates. The module should have two input ports and one output port. The output should be the inverse of the logical OR of the two input values. In addition, the module should be designed using a hierarchical architecture.", "output": "module nor_using_nand(\n    input a,\n    input b,\n    output out\n);\n\nwire nand1_out;\nwire nand2_out;\n\nnand nand1(\n    .a(a),\n    .b(a),\n    .out(nand1_out)\n);\n\nnand nand2(\n    .a(b),\n    .b(b),\n    .out(nand2_out)\n);\n\nnand nand3(\n    .a(nand1_out),\n    .b(nand2_out),\n    .out(out)\n);\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output out\n);\n\nnor_using_nand nor_gate(\n    .a(a),\n    .b(b),\n    .out(out)\n);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a module in Verilog that takes in a 32-bit input signal `data_in` and outputs a 16-bit signal `data_out` which is the sum of the most significant 16 bits and the least significant 16 bits of `data_in`. If there is an overflow during addition, the module should output an overflow signal `ovf` set to 1, otherwise, `ovf` should be set to 0. \n\nIn addition, the module should have an enable signal `en` which, when set to 0, should cause the module to output 0 for `data_out` and 0 for `ovf`. \n\nThe module should be named `sum16` and should be implemented within 200 lines of Verilog code.\n\n", "output": "module sum16 (\n    input [31:0] data_in,\n    input en,\n    output reg [15:0] data_out,\n    output reg ovf\n);\n\n    always @(*) begin\n        if (en == 1) begin\n            data_out = data_in[31:16] + data_in[15:0];\n            if (data_out > 16'hFFFF) begin\n                ovf = 1;\n            end else begin\n                ovf = 0;\n            end\n        end else begin\n            data_out = 16'h0000;\n            ovf = 0;\n        end\n    end\n\nendmodule"}
{"instruction": "Design a module that captures the rising edge of each bit in a 32-bit input vector and generates a 1-bit output for each bit. The output should remain high until the register is reset (synchronous reset). Use a combination of D flip-flops and combinational logic to achieve the functionality.", "output": "module rising_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] prev_in;\nreg [31:0] curr_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        prev_in <= 32'b0;\n        curr_in <= 32'b0;\n    end else begin\n        prev_in <= curr_in;\n        curr_in <= in;\n    end\nend\n\nassign out = curr_in & ~prev_in;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that synchronizes an input signal to an output signal based on a clock and reset signal. The module should have the following ports:\n\n- `clk`: input clock signal\n- `data_in`: input data signal\n- `reset_n`: input reset signal\n- `data_out`: output synchronized data signal\n\nThe module should implement a single flop to delay the input signal by one clock cycle before being synchronized to the output signal. The flop should be reset to 0 when the reset signal is asserted low. The module should meet the following requirements:\n\n- The output signal should be synchronized to the input signal based on the rising edge of the clock signal.\n- When the reset signal is asserted low, the output signal should be immediately set to 0.\n- The module should be synthesizable and meet the timing requirements of the target FPGA.\n\nImplement the module in verilog and simulate it to verify its functionality.\n\n", "output": "module sync_module (\n  input clk,\n  input data_in,\n  input reset_n,\n  output reg data_out\n);\n\n  reg data_in_d1;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      data_in_d1 <= 1'b0;\n      data_out <= 1'b0;\n    end else begin\n      data_in_d1 <= data_in;\n      data_out <= data_in_d1;\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a 4-bit counter with synchronous reset functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK` (1-bit): Clock input\n- `RST` (1-bit): Asynchronous reset input\n- `EN` (1-bit): Enable input\n\nOutputs:\n- `Q` (4-bit): Counter output\n\nWhen `EN` is high, the counter should increment on every positive edge of `CLK`. When `RST` is high, the counter should reset to zero, regardless of the value of `EN`. The counter should be initialized to zero when `RST` is low and `EN` is high.\n\n", "output": "module counter (\n    input  wire        CLK,\n    input  wire        RST,\n    input  wire        EN,\n    output wire [3:0]  Q\n);\n\n    reg [3:0] count;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            count <= 4'b0;\n        end\n        else if (EN) begin\n            count <= count + 1;\n        end\n    end\n\n    assign Q = count;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 2-input D flip-flop with asynchronous set and reset control signals. The module should have a single clock input and two data inputs, one for the data to be stored and one for the clock enable signal. The module should output the stored data on a single output port.\n\nYour module should be named \"dff_2input_async_reset_set\" and should be contained within 200 lines of Verilog code. The module should be synthesizeable and meet the following requirements:\n\n1. When the reset signal is asserted, the output of the flip-flop should be set to 0 regardless of the value of the data input.\n2. When the set signal is asserted, the output of the flip-flop should be set to 1 regardless of the value of the data input.\n3. When both the reset and set signals are asserted, the output of the flip-flop should be set to 0.\n4. When neither the reset nor set signals are asserted, the output of the flip-flop should be the same as the data input on the rising edge of the clock signal.\n\nYou may assume that the input signals are valid and will not violate setup or hold time requirements.\n\n", "output": "module dff_2input_async_reset_set (\n    input  wire clk,\n    input  wire reset,\n    input  wire set,\n    input  wire d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 0;\n    end else if (set) begin\n        q <= 1;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit up/down counter with asynchronous load, synchronous reset, and direction control. The module should have four inputs (LOAD, RESET, DIR, and CLK) and one output (Q). If LOAD is high, the counter should be loaded with the value of the D input. If RESET is high, the counter should be reset to zero. If DIR is high, the counter should count up on each clock cycle. If DIR is low, the counter should count down on each clock cycle. The counter should be triggered by the positive edge of CLK.", "output": "module up_down_counter (\n    input LOAD, RESET, DIR, CLK,\n    input [3:0] D,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= D;\n        end else if (DIR) begin\n            Q <= Q + 1;\n        end else begin\n            Q <= Q - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 32-bit data input `MDR_data`, a memory write enable signal `Mem_write_enable`, and outputs two 32-bit data signals `BusData_out` and `Mdata_out`. The module should be named `MDMux_out`.\n\nThe `MDMux_out` module should have the following behavior:\n- When `Mem_write_enable` is high, `Mdata_out` should be equal to `MDR_data` and `BusData_out` should be equal to 0.\n- When `Mem_write_enable` is low, `BusData_out` should be equal to `MDR_data` and `Mdata_out` should be equal to 0.\n\nYou should implement this module in Verilog.\n\n", "output": "module MDMux_out(\n    input Mem_write_enable,\n    input [31:0] MDR_data,\n    output [31:0] BusData_out,\n    output [31:0] Mdata_out\n);\n\n    assign Mdata_out = Mem_write_enable ? MDR_data : 0;\n    assign BusData_out = Mem_write_enable ? 0 : MDR_data;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a D flip-flop with a clock enable and a clear input. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: clock input\n- `d`: data input\n- `ce`: clock enable input\n- `clr`: clear input\n\nOutputs:\n- `q`: output\n\nThe module should implement the following behavior:\n- When the `clr` input is high, the output `q` should be low, regardless of the other inputs.\n- When the `ce` input is low, the output `q` should hold its previous value, regardless of the other inputs.\n- When the `ce` input is high and the `clr` input is low, the output `q` should follow the input `d` on the rising edge of the clock `clk`.\n\nYou can use any necessary intermediate signals.\n\n", "output": "module d_ff_ce_clr(clk, d, ce, clr, q);\ninput clk, d, ce, clr;\noutput q;\nreg q;\n\nalways @(posedge clk) begin\n  if (clr) begin\n    q <= 1'b0;\n  end else if (ce) begin\n    q <= d;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in six inputs and outputs one signal. The module should be named `six_to_one`.\n\nThe six inputs are:\n- `in0`: a single-bit input signal\n- `in1`: a single-bit input signal\n- `in2`: a single-bit input signal\n- `in3`: a single-bit input signal\n- `in4`: a single-bit input signal\n- `in5`: a single-bit input signal\n\nThe output signal is named `out` and should be a single-bit signal.\n\nThe module should implement the following logic:\n- If `in0` is 1, `out` should be 1.\n- If `in0` is 0 and `in1` is 1, `out` should be 1.\n- If `in0` and `in1` are 0 and `in2` is 1, `out` should be 1.\n- If `in0`, `in1`, and `in2` are 0 and `in3` is 1, `out` should be 1.\n- If `in0`, `in1`, `in2`, and `in3` are 0 and `in4` is 1, `out` should be 1.\n- If `in0`, `in1`, `in2`, `in3`, and `in4` are 0 and `in5` is 1, `out` should be 1.\n- If all inputs are 0, `out` should be 0.\n\nYou should implement this module within 200 lines of verilog code.\n\n", "output": "module six_to_one (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    input in5,\n    output reg out\n);\n\nalways @(*) begin\n    if (in0) begin\n        out = 1;\n    end else if (in1) begin\n        out = 1;\n    end else if (in2) begin\n        out = 1;\n    end else if (in3) begin\n        out = 1;\n    end else if (in4) begin\n        out = 1;\n    end else if (in5) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule"}
{"instruction": "Design a 64-bit Johnson counter (torsional ring counter) using a linear feedback shift register (LFSR) and generate the same cyclic state as the 4-bit Johnson counter in the given prompt. The LFSR should be implemented using a shift register and an XOR gate. The module should have an input clock and a reset signal. The output of the module should be a 64-bit binary number represented by a 64-bit vector.", "output": "module chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [63:0]   Q\n);\n\n  reg [63:0] lfsr;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      lfsr <= 64'h0000000000000000;\n      Q <= 4'b0000;\n    end\n    else begin\n      lfsr <= {lfsr[62:0], lfsr[63] ^ lfsr[0] ^ lfsr[3] ^ lfsr[4]};\n      Q <= {lfsr[0], lfsr[4], lfsr[5], lfsr[6]};\n    end\n  end\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 4 inputs and produces 1 output. The module should implement the following logic:\n- The output should be the result of a NAND gate that takes in 3 inputs: C1, the output of an OR gate, and B1.\n- The OR gate should take in 2 inputs: A1 and A2.\n- The module should have the following supplies: VPWR (1), VGND (0), VPB (1), and VNB (0).\n\nDesign a module that implements the above logic and declare its ports and supplies as shown in the code snippet below. The module should be named `my_module` and the output port should be named `out`.\n\n```\nmodule my_module (\n    out ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  \n);\n\n    // Module ports\n    // TODO: declare module ports\n\n    // Module supplies\n    // TODO: declare module supplies\n\n    // Local signals\n    // TODO: declare local signals\n\n    // TODO: implement logic\n\nendmodule\n```\n\n", "output": "module my_module (\n    out ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  \n);\n\n    // Module ports\n    output out;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire or_out     ;\n    wire nand_out   ;\n\n    // Implement logic\n    or   or_gate   (or_out  , A1, A2);\n    nand nand_gate (nand_out, C1, or_out, B1);\n    buf  buf_gate  (out     , nand_out);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit shift register with parallel load functionality. The module should have four inputs and two outputs. The inputs are: \n\n1. `clk`: a clock signal\n2. `reset`: a reset signal\n3. `load`: a load signal\n4. `data_in`: a 4-bit input data signal\n\nThe outputs are:\n\n1. `data_out`: a 4-bit output data signal\n2. `shift_out`: a 1-bit signal that outputs the value of the most significant bit in the shift register.\n\nThe module should implement the following functionality:\n\n- On the rising edge of the clock signal `clk`, if the `reset` signal is high, the shift register should be reset to all zeros.\n- On the rising edge of the clock signal `clk`, if the `reset` signal is low and the `load` signal is high, the shift register should be loaded with the value of `data_in`.\n- On the rising edge of the clock signal `clk`, if the `reset` signal is low and the `load` signal is low, the shift register should shift all bits to the left, with the most significant bit being output on the `shift_out` signal and the least significant bit being discarded. The new least significant bit should be set to zero, and the new most significant bit should be set to the value of the previous second-most significant bit. The value of the shift register should be output on the `data_out` signal.\n\nYou should implement this functionality in a single Verilog module that is no more than 200 lines long.\n\n", "output": "module shift_register(clk, reset, load, data_in, shift_out, data_out);\n\n\tinput clk;\n\tinput reset;\n\tinput load;\n\tinput [3:0] data_in;\n\toutput shift_out;\n\toutput [3:0] data_out;\n\n\treg [3:0] reg_data;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\treg_data <= 4'b0;\n\t\tend else if (load) begin\n\t\t\treg_data <= data_in;\n\t\tend else begin\n\t\t\treg_data[3] <= reg_data[2];\n\t\t\treg_data[2] <= reg_data[1];\n\t\t\treg_data[1] <= reg_data[0];\n\t\t\treg_data[0] <= 1'b0;\n\t\tend\n\tend\n\n\tassign shift_out = reg_data[3];\n\tassign data_out = reg_data;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module to implement a logic circuit. The circuit should take in 5 inputs: A1, A2, B1, B2, and C1. The circuit should output a single value X. \n\nThe circuit should be implemented within a module named \"logic_circuit\". You are not allowed to use any pre-defined Verilog modules, and the entire circuit should be implemented within a single module that is no longer than 200 lines of code.\n\nThe logic circuit should be implemented as follows:\n- The output X should be the result of a logical OR operation between the following:\n  - A logical AND operation between B1 and B2\n  - A logical AND operation between A1 and A2\n  - The input C1\n\nYour task is to implement the \"logic_circuit\" module in Verilog that satisfies the above requirements. Your module should be able to compile without any errors or warnings.\n\n", "output": "module logic_circuit (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    output X\n);\n\n    // Local signals\n    wire and0_out;\n    wire and1_out;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , B1, B2                );\n    and and1 (and1_out , A1, A2                );\n    or  or0  (or0_out_X, and1_out, and0_out, C1);\n    buf buf0 (X        , or0_out_X             );\n\nendmodule"}
{"instruction": "Create a module that can perform the functionality of a D flip-flop. The module should have one input port that accepts a single binary value and one output port that outputs the binary value received at the input port on the next clock cycle. The module must be designed using a JK flip-flop.", "output": "module d_flip_flop (\n    input clk,\n    input d,\n    output reg q\n);\n\nreg j, k;\n\nalways @(posedge clk) begin\n    j <= d;\n    k <= ~d;\n    q <= j ^ q;\n    q <= k ^ q;\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing an Arithmetic Logic Unit (ALU) module in Verilog that can perform basic arithmetic and logic operations on two 32-bit inputs. The module should have three 32-bit inputs A, B, and F. The input F is a 3-bit signal that specifies the operation to be performed on A and B. The module should have two 32-bit outputs: Y and Zero. Y is the result of the operation and Zero is a flag that is set to 1 if the result is zero.\n\nThe ALU module should support the following operations:\n- Bitwise AND (F = 000)\n- Bitwise OR (F = 001)\n- Addition (F = 010)\n- Bitwise AND with negated B (F = 011)\n- Addition with negated B (F = 101)\n- Subtraction (F = 110)\n- Set if less than (F = 111)\n\nImplement the ALU module using a case statement that selects the appropriate operation based on the value of F.\n\n", "output": "module alu(\n    input [31:0] A, B, \n    input [2:0] F, \n    output reg [31:0] Y, \n    output reg Zero\n);\n\nalways @*\nbegin\n    case(F)\n        3'b000: Y <= A & B;\n        3'b001: Y <= A | B;\n        3'b010: Y <= A + B;\n        3'b011: Y <= A & ~B;\n        3'b101: Y <= A + ~B;\n        3'b110: Y <= A - B;\n        3'b111: Y <= (A < B) ? 1 : 0;\n        default: Y <= 0;\n    endcase\n    Zero <= (Y == 0) ? 1 : 0;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that converts a two's complement binary number to its corresponding sign-magnitude representation. The module should have three inputs and one output. The inputs are:\n- `i`: a `n`-bit two's complement binary number, where `n` is a positive integer.\n- `rst`: a synchronous reset signal that clears the output to 0 when asserted.\n- `clk`: a clock signal.\n\nThe output is:\n- `o`: a `n+1`-bit sign-magnitude representation of the input `i`.\n\nThe module should have the following behavior:\n- When `rst` is asserted, `o` should be cleared to 0.\n- On each rising edge of `clk`, the module should convert the input `i` to its sign-magnitude representation and output the result on `o`.\n\nYou should implement the module in Verilog.\n\n", "output": "module twos_comp_to_sign_mag (\n  output reg [(n+1)-1:0] o,\n  input [(n)-1:0] i,\n  input rst,\n  input clk\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      o <= {1'b0, {(n)-1{1'b0}}};\n    end\n    else begin\n      if (i[n-1] == 1'b0) begin\n        o <= {1'b0, i};\n      end\n      else begin\n        o <= {1'b1, ~(i-1)};\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that implements a binary counter with asynchronous reset. The module should have the following specifications:\n\n- The counter should be 8 bits wide.\n- The counter should increment by 1 on each rising edge of the clock signal.\n- The counter should reset to 0 asynchronously when a reset signal is asserted.\n- The module should have the following inputs:\n  - `clk`: the clock signal.\n  - `reset`: the asynchronous reset signal.\n- The module should have the following outputs:\n  - `count`: the 8-bit binary count.\n\nWrite a Verilog module that implements the above specifications. Your module should be self-contained and no more than 200 lines of code.\n\n", "output": "module binary_counter(clk, reset, count);\n\n  input clk, reset;\n  output reg [7:0] count;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been hired to design a verilog module that takes in five input signals - A1, A2, A3, B1, and C1 - and generates a single output signal X. You are required to implement this module using the following components:\n\n- An OR gate with three inputs, named or0\n- An AND gate with three inputs, named and0\n- A buffer, named buf0\n\nThe module should be named sky130_fd_sc_ls__o311a and should have the following interface:\n\n- X: a single-bit output\n- A1, A2, A3, B1, C1: single-bit inputs\n\nYou are also provided with four supply nets: VPWR (supply1), VGND (supply0), VPB (supply1), and VNB (supply0).\n\nWrite the verilog code for the sky130_fd_sc_ls__o311a module that meets these requirements.\n\n", "output": "module sky130_fd_sc_ls__o311a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire or0_out   ;\n    wire and0_out_X;\n\n    //  Name  Output      Other arguments\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1, C1);\n    buf buf0 (X         , and0_out_X     );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder. The module should have two 4-bit inputs, A and B, and a 4-bit output, S, where S = A + B. The module should also have a carry output, COUT, which should be high if the addition operation results in a carry.\n\nYour module should be named \"adder4\" and should be self-contained, meaning it should not rely on any external modules. Your module should be implemented within 200 lines of Verilog code.\n\nPlease write a Verilog module that satisfies the above requirements and provide the code for it.\n\n", "output": "module adder4(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output COUT\n);\n\nwire [3:0] sum;\nwire carry;\n\nassign sum = A + B;\nassign COUT = (sum[4] == 1);\n\nassign S = sum[3:0];\n\nendmodule"}
{"instruction": "Design a 2-to-1 multiplexer using Verilog. The module should have two input ports, each capable of accepting binary values. The output port should provide a binary value that is either a or b, depending on the values of sel_b1 and sel_b2. If both sel_b1 and sel_b2 are true, the output should be b. Otherwise, the output should be a. The module must be designed using a combinational logic circuit.", "output": "module mux_2to1(\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output reg out_always\n);\n\nalways @(*) begin\n    if (sel_b1 && sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a combinational circuit that performs the following operation on a 4-bit input signal `in` and outputs a 4-bit signal `out`:\n\n- If `in` is in the range 0 to 7 (inclusive), `out` should be the binary representation of `in` multiplied by 2.\n- If `in` is in the range 8 to 15 (inclusive), `out` should be the binary representation of `in` divided by 2.\n- If `in` is outside the range 0 to 15 (inclusive), `out` should be 0.\n\nYou can assume that the input signal `in` is valid and does not change during the operation of the circuit.\n\nWrite a Verilog module that implements this circuit. Your module should have the following interface:\n\n```\nmodule comb_op\n(\n  input [3:0] in,\n  output reg [3:0] out\n);\n```\n\nYou are not allowed to use any multiplication or division operators in your implementation. You are allowed to use if statements and logical operators.\n\n", "output": "module comb_op\n(\n  input [3:0] in,\n  output reg [3:0] out\n);\n\n  always @(*)\n  begin\n    if (in >= 0 && in <= 7) // Range 0 to 7\n      out = in << 1;\n    else if (in >= 8 && in <= 15) // Range 8 to 15\n      out = in >> 1;\n    else // Outside range 0 to 15\n      out = 0;\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that interfaces with a sky130_fd_sc_ms__o21ba module. The module should have one output, X, and seven inputs: A1, A2, B1_N, VPWR, VGND, VPB, and VNB. The sky130_fd_sc_ms__o21ba module is already instantiated in the code snippet provided and cannot be modified. Your module should be able to take in the inputs and output a value for X based on the following logic:\n\n- If A1 and A2 are both high, X should be high.\n- If B1_N is low, X should be low.\n- If VPWR is high and VGND is low, X should be high.\n- If VPB is high and VNB is low, X should be low.\n- If none of the above conditions are met, X should be high.\n\nYou should design your module within 200 lines of Verilog code and ensure that it satisfies the above requirements.\n\n", "output": "module custom_module (\n    output X,\n    input A1,\n    input A2,\n    input B1_N,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    assign X = (A1 & A2) ? 1'b1 :\n               (!B1_N) ? 1'b0 :\n               (VPWR & !VGND) ? 1'b1 :\n               (VPB & !VNB) ? 1'b0 :\n               1'b1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two inputs, A and B, and outputs their logical AND. The module should be named \"and_gate\" and should have the following interface:\n\n```\nmodule and_gate (\n    input A,\n    input B,\n    output X\n);\n```\n\nYour module should be able to handle both rising and falling edge clock signals. The output should be updated only on the rising edge of the clock signal. You should also implement a reset signal that sets the output to 0.\n\nYou should write a Verilog module that implements this logic. Your module should be self-contained and should not rely on any external modules or libraries. Your module should be no more than 200 lines of Verilog code.\n\n", "output": "module and_gate (\n    input A,\n    input B,\n    input clk,\n    input reset,\n    output reg X\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            X <= 0;\n        end else begin\n            X <= A & B;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a Verilog module that checks a tuple of three values for correctness. The tuple is represented as a 3-bit vector, with each bit representing a value of either 0 or 1. Your module should output a single bit indicating whether the tuple is valid or not.\n\nA tuple is considered valid if it meets the following criteria:\n- The first value is equal to the second value XOR the third value.\n- The second value is equal to the first value XOR the third value.\n- The third value is equal to the first value XOR the second value.\n\nYour module should be named `check_tuple` and should have the following input and output ports:\n\nInput:\n- `tuple`: a 3-bit vector representing the tuple to be checked.\n\nOutput:\n- `valid`: a single bit indicating whether the tuple is valid (`valid` = 1) or not (`valid` = 0).\n\nYour module should be implemented within 200 lines of Verilog code.\n\n", "output": "module check_tuple(\n  input [2:0] tuple,\n  output valid\n);\n\n  wire a = tuple[0] ^ tuple[1];\n  wire b = tuple[1] ^ tuple[2];\n  wire c = tuple[0] ^ tuple[2];\n  \n  assign valid = (a == tuple[2]) && (b == tuple[0]) && (c == tuple[1]);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a clock gating circuit. The module should have four input ports: `CLK`, `EN`, `TE`, and `RESET`, and one output port: `ENCLK`. The `CLK` input is the system clock, `EN` is the enable signal, `TE` is the transparent enable signal, and `RESET` is the reset signal. The `ENCLK` output is the gated clock signal.\n\nThe clock gating circuit should operate as follows:\n- When `EN` is low, `ENCLK` should be low.\n- When `EN` is high and `RESET` is low, `ENCLK` should be the same as `CLK`.\n- When `EN` is high, `RESET` is high, and `TE` is low, `ENCLK` should be low.\n- When `EN` is high, `RESET` is high, and `TE` is high, `ENCLK` should be the inverted value of `CLK`.\n\nYour Verilog module should be named `ClockGating` and should be designed such that it can be used in a larger Verilog design.\n\n", "output": "module ClockGating (\n  input CLK, EN, TE, RESET,\n  output reg ENCLK\n);\n\nalways @ (posedge CLK, posedge RESET) begin\n  if (RESET) begin\n    ENCLK <= 0;\n  end else if (EN) begin\n    if (TE) begin\n      ENCLK <= 0;\n    end else begin\n      ENCLK <= ~CLK;\n    end\n  end else begin\n    ENCLK <= 0;\n  end\nend\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a Verilog module that takes in six inputs and outputs a single value. The module should be named \"AO222X2\" and should be contained within 200 lines of Verilog code. The six inputs, named IN1 through IN6, are all single-bit wires. The output, named Q, is also a single-bit wire.\n\nWithin the module, you should use three AND2 gates and one OR3 gate to compute the output Q. Specifically, the output Q should be the logical OR of the three AND2 gates, where each AND2 gate takes in two of the six input wires.\n\nYour task is to write the Verilog code for this module, using the provided code snippet as a starting point. Your code should be contained within the module definition and should not rely on any external modules or functions.\n\n", "output": "module AO222X2 (IN1,IN2,IN3,IN4,IN5,IN6,Q);\n\n input IN1,IN2,IN3,IN4,IN5,IN6;\n output Q;\n\n wire Otemp0,Otemp1,Otemp2;\n\n AND2 XIL_AND2_0 (.I0(IN1),.I1(IN2),.O(Otemp0));\n AND2 XIL_AND2_1 (.I0(IN3),.I1(IN4),.O(Otemp1));\n AND2 XIL_AND2_2 (.I0(IN5),.I1(IN6),.O(Otemp2));\n OR3  XIL_OR3  (.I0(Otemp0),.I1(Otemp1),.I2(Otemp2),.O(Q));\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in a 32-bit input signal and outputs the maximum value of the input signal. You should name your module `max32` and it should have the following ports:\n\n- `input [31:0] in1`: a 32-bit input signal\n- `output [31:0] out1`: a 32-bit output signal that represents the maximum value of the input signal\n\nYou should assume that the input signal is a signed integer, and the output signal should also be a signed integer.\n\nYou should ensure that your design is synthesizable and meets the following requirements:\n\n- Your design should be optimized for area\n- Your design should be able to handle all possible input values, including the maximum and minimum values for a signed 32-bit integer\n\n", "output": "module max32 (in1, out1);\ninput [31:0] in1;\noutput [31:0] out1;\n\nreg [31:0] max_val;\n\nalways @ (in1) begin\n    if (in1 > max_val) begin\n        max_val <= in1;\n    end\nend\n\nassign out1 = max_val;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that will implement a D-latch with an active-low asynchronous reset and a gated clock. The module should have the following inputs and outputs:\n\n- `D`: input signal that holds the data to be stored in the latch\n- `RESET_B`: input signal that resets the latch to a known state when active low\n- `GATE`: input signal that enables the latch to store the data when high\n- `Q`: output signal that represents the stored data\n- `Q_N`: output signal that represents the complement of the stored data\n\nYour module should be named `d_latch` and be contained within 200 lines of Verilog code. You should assume that the voltage supply signals have already been defined in a separate module.\n\n", "output": "module d_latch (\n    Q      ,\n    Q_N    ,\n    RESET_B,\n    D      ,\n    GATE\n);\n\n    output Q      ;\n    output Q_N    ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE   ;\n\n    reg Q, Q_N;\n\n    always @(negedge RESET_B or posedge GATE) begin\n        if (!RESET_B) begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end else if (GATE) begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that instantiates two sub-modules, `ent_ba` and `ent_bb`. `ent_ba` and `ent_bb` are both black boxes, so you do not have access to their internal signals or behavior. \n\nYour job is to correctly instantiate these two sub-modules and wire them up to the top-level module's ports. The top-level module should have an input port `in` and an output port `out`. The `in` port should be connected to both sub-modules, and the `out` port should be connected to only `ent_bb`. \n\nYour task is to write the top-level module, including the necessary port declarations, instance declarations, and port mappings. \n\n", "output": "module top_module (\n    input in,\n    output out\n);\n\n    // Instantiate sub-modules\n    ent_ba inst_ba();\n    ent_bb inst_bb();\n\n    // Wire up sub-modules to top-level ports\n    assign inst_ba.in = in;\n    assign inst_bb.in = inst_ba.out;\n    assign out = inst_bb.out;\n\nendmodule"}
{"instruction": "\n\nYou have been given a code snippet for a module named `t`. The module has one input port named `clk` and three signals named `a`, `b`, and `c`. The signal `a` is assigned the value of the input port `clk` whereas the signal `b` is assigned a constant value of `1'b0`. The signal `c` is declared as a register type. Additionally, an instance of another module named `array_test` is instantiated within module `t`. \n\nYour task is to modify the code snippet to implement a counter that counts the number of rising edges of the `clk` signal. The counter should increment on each rising edge of the `clk` signal and should be stored in the signal `c`. You should also modify the instantiation of the `array_test` module to pass the value of `c` as an input to the `array_test` module.\n\n", "output": "module t (\n   // Inputs\n   input clk\n   );\n   \n   reg prev_clk;\n   reg [31:0] counter;\n   \n   always @(posedge clk) begin\n      if (prev_clk == 1'b0 && clk == 1'b1) begin\n         counter <= counter + 1;\n      end\n      prev_clk <= clk;\n   end\n   \n   wire  a = clk;\n   wire  b = 1'b0;\n   \n   array_test array_test_i (\n      // Inputs\n      .clk(clk),\n      .counter(counter)\n   );\n   \nendmodule"}
{"instruction": "\nYou have been tasked with designing a verilog module that implements a simple calculator. The calculator should be able to perform basic arithmetic operations such as addition, subtraction, multiplication, and division. The calculator should also be able to perform logical operations such as AND, OR, and NOT. The input to the calculator should be two 8-bit numbers and an operation code. The output of the calculator should be the result of the operation. The operation code is a 4-bit number that specifies the operation to be performed. The mapping of operation codes to operations is as follows:\n\n| Operation Code | Operation |\n|----------------|-----------|\n| 0000           | Addition  |\n| 0001           | Subtraction |\n| 0010           | Multiplication |\n| 0011           | Division |\n| 0100           | Bitwise AND |\n| 0101           | Bitwise OR |\n| 0110           | Bitwise NOT |\n\nImplement a verilog module named `calculator` that takes in two 8-bit numbers and an operation code and outputs the result of the operation. The module should have the following ports:\n\n- `input [7:0] a`: The first 8-bit number\n- `input [7:0] b`: The second 8-bit number\n- `input [3:0] op`: The operation code\n- `output [7:0] result`: The result of the operation\n\nAssume that the input numbers are always valid and that division by zero will not occur.\n\n", "output": "module calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [3:0] op,\n    output [7:0] result\n);\n\nreg [15:0] temp;\n\nalways @* begin\n    case (op)\n        4'b0000: temp = a + b; // Addition\n        4'b0001: temp = a - b; // Subtraction\n        4'b0010: temp = a * b; // Multiplication\n        4'b0011: temp = a / b; // Division\n        4'b0100: temp = a & b; // Bitwise AND\n        4'b0101: temp = a | b; // Bitwise OR\n        4'b0110: temp = ~a; // Bitwise NOT\n        default: temp = 0; // Invalid operation code\n    endcase\nend\n\nassign result = temp[7:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit binary input and outputs a 3-bit binary number that represents the number of ones in the input. For example, if the input is 0101, the output should be 2 (001 in binary). You are not allowed to use any built-in functions or operators.\n\nYour module should have the following interface:\n\nInputs:\n- `in`: a 4-bit binary input\n- `clk`: a clock signal\n- `rst`: a reset signal\n\nOutputs:\n- `out`: a 3-bit binary output representing the number of ones in the input\n\nYou may use any additional signals or modules as necessary.\n\nWrite the Verilog code for your module.\n\n", "output": "module ones_counter(\n    input [3:0] in,\n    input clk,\n    input rst,\n    output reg [2:0] out\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            out <= 0;\n        end else begin\n            out <= (in[0] + in[1] + in[2] + in[3]);\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit RAM (Random Access Memory) with 8 memory locations. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `addr`: a 3-bit address bus\n- `din`: an 4-bit input data bus\n- `en`: an enable signal\n- `we`: a write enable signal\n\nOutputs:\n- `dout`: a 4-bit output data bus\n\nYour module should be implemented using behavioral Verilog and should use a reg data type to store the memory. The RAM should be initialized with all 0's.\n\n", "output": "module ram_4x8(\n    input clk,\n    input [2:0] addr,\n    input [3:0] din,\n    input en,\n    input we,\n    output reg [3:0] dout\n);\n\nreg [3:0] memory [0:7];\n\nalways @(posedge clk) begin\n    if (en) begin\n        if (we) begin\n            memory[addr] <= din;\n        end else begin\n            dout <= memory[addr];\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements memory protection blocks. \nMemory protection blocks are used to control access to memory blocks in a digital system. \nThe inputs to the circuit are the address bus and the control signals, and the output is the memory enable signal.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- address bus: a set of n address signals (addr1, addr2, ..., addrn)\n- control signals: a set of m control signals (ctrl1, ctrl2, ..., ctrlm)\n\nOutputs: \n- memory enable signal (mem_en)\n\nThe module should also have the following parameters:\n\n- n: the number of address signals\n- m: the number of control signals\n- memory size: the size of the memory block that needs to be protected\n\nYour module should implement the following functionality:\n\n- The circuit should compare the input address signals with the given memory size.\n- If the address signals are within the memory block, the circuit should check the control signals to determine whether the memory can be accessed.\n- If the control signals allow the access, the circuit should generate the memory enable signal.\n- If the address signals are outside the memory block or the control signals do not allow the access, the circuit should disable the memory.\n\nTo implement the memory protection blocks, you should use Verilog code to compare the address signals with the memory size and check the control signals to determine whether the memory can be accessed.\nYou should then use these signals to generate the memory enable signal and disable the memory when necessary.", "output": "module mem_protect (\n  input [n-1:0] addr,\n  input [m-1:0] ctrl,\n  output mem_en\n);\n\nparameter n = 4; // number of address signals\nparameter m = 2; // number of control signals\nparameter memory_size = 1024; // size of the memory block to be protected.\n\nreg mem_en;\n\nalways @(*) begin\n  if (addr < memory_size && ctrl[0] && !ctrl[1]) begin\n    mem_en = 1;\n  end else begin\n    mem_en = 0;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a simple counter. The module should have two inputs and one output. The first input is a clock signal, and the second input is a reset signal. The output should be a 4-bit binary counter that increments on each rising edge of the clock signal, unless the reset signal is high, in which case the counter should be set to zero.\n\nYou should use the following verilog code snippet as a starting point:\n\n```\nmodule counter(\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\n// Your code goes here\n\nendmodule\n```\n\nYour task is to fill in the missing code to implement the counter as described above. You should assume that the clock signal is a 50MHz signal, and that the reset signal is active high.\n\n", "output": "module counter(\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a digital circuit using Verilog. The circuit should implement a D flip-flop with asynchronous reset and set inputs. The circuit should have the following inputs:\n\n- D: the data input\n- RESET_B: the asynchronous reset input (active low)\n- SET_B: the asynchronous set input (active low)\n- CLK: the clock input\n\nThe circuit should have the following output:\n\n- Q: the output\n\nThe circuit should be designed using only one module within 200 lines of Verilog code. You can use the provided code snippet as a reference for creating your module.\n\nYour task is to complete the implementation of the D flip-flop with asynchronous reset and set inputs. You should ensure that the circuit meets the following requirements:\n\n- When RESET_B is asserted, the output Q should be set to 0.\n- When SET_B is asserted, the output Q should be set to 1.\n- When neither RESET_B nor SET_B is asserted, the output Q should follow the input D on the rising edge of the clock CLK.\n\n", "output": "module dff_async_reset_set (\n    input D,\n    input RESET_B,\n    input SET_B,\n    input CLK,\n    output Q\n);\n\n    reg Q_int;\n\n    always @(posedge CLK or negedge RESET_B or negedge SET_B)\n    begin\n        if (!RESET_B) // Asynchronous reset\n            Q_int <= 1'b0;\n        else if (!SET_B) // Asynchronous set\n            Q_int <= 1'b1;\n        else // Synchronous logic\n            Q_int <= D;\n    end\n\n    assign Q = Q_int;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that takes in five inputs and produces two outputs. The module should be no longer than 200 lines of code. The inputs and outputs are as follows:\n\nInputs:\n- PIN1 (1-bit)\n- PIN2 (1-bit)\n- GIN1 (1-bit)\n- GIN2 (1-bit)\n- PHI (1-bit)\n\nOutputs:\n- POUT (1-bit)\n- GOUT (1-bit)\n\nThe module should be named \"BLOCK1\" and should have the following functionality:\n\n- The value of POUT should be the logical NOT of the OR of PIN1 and PIN2.\n- The value of GOUT should be the logical NOT of the AND of GIN2 and the OR of PIN2 and GIN1.\n\nYour task is to write the Verilog code for this module, making sure to adhere to the following specifications:\n\n- The module should be named \"BLOCK1\".\n- The inputs and outputs should be declared in the order given above.\n- The input and output ports should not be assigned any values within the module.\n- The values of POUT and GOUT should be assigned using the \"assign\" keyword.\n\n", "output": "module BLOCK1 ( PIN1, PIN2, GIN1, GIN2, PHI, POUT, GOUT );\ninput  PIN1;\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput POUT;\noutput GOUT;\n   assign POUT =  ~ (PIN1 | PIN2);\n   assign GOUT =  ~ (GIN2 & (PIN2 | GIN1));\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that takes in four inputs (A1_N, A2_N, B1, B2) and produces one output (X). The module should also have four additional inputs (VPWR, VGND, VPB, VNB) which are used for power and ground connections.\n\nThe module should output a 1 if the inputs satisfy the following conditions:\n- A1_N and A2_N are both 0\n- B1 and B2 are both 1\n\nThe module should output a 0 for all other input combinations.\n\nYour module should be named \"verilog_module\" and should be no longer than 200 lines of Verilog code.\n\n", "output": "module verilog_module (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    reg X;\n    \n    always @(*) begin\n        if (A1_N == 0 && A2_N == 0 && B1 == 1 && B2 == 1) begin\n            X = 1;\n        end else begin\n            X = 0;\n        end\n    end\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder-subtractor. The module should have two input ports: `A` and `B`, and two control input ports: `S` and `C`. `S` is a control signal that determines whether the module should perform addition or subtraction. If `S` is high, the module should perform subtraction, otherwise it should perform addition. `C` is a carry-in signal that can be used to add an additional bit to the operation. The module should have two output ports: `F` and `C_out`. `F` is the result of the addition or subtraction, and `C_out` is the carry-out signal.\n\n", "output": "module addsub4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input S,\n    input C,\n    output [3:0] F,\n    output C_out\n);\n\nreg [3:0] temp;\n\nalways @ (*)\nbegin\n    if(S == 1) // subtraction\n    begin\n        temp = A - B;\n        if(C == 1) temp = temp - 1;\n        F = temp;\n        C_out = (temp[3] == 1) ? 0 : 1;\n    end\n    else // addition\n    begin\n        temp = A + B;\n        if(C == 1) temp = temp + 1;\n        F = temp;\n        C_out = (temp[4] == 1) ? 1 : 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in multiple inputs and produces one output. The module should be named `adder` and should have the following specifications:\n\n- The module should have 3 input ports, `a`, `b`, and `cin`, and 2 output ports, `sum` and `cout`.\n- The module should be able to add two binary numbers represented by `a` and `b`, as well as the carry-in `cin`, and produce the sum `sum` and the carry-out `cout`.\n- The inputs and outputs should be 1-bit binary values.\n- The module should be synchronous and operate on the rising edge of the clock signal `clk`.\n- The module should be designed using behavioral Verilog.\n\nYou are required to implement the `adder` module and test it using test vectors.\n\n", "output": "module adder (\n    input clk,\n    input [1:0] a,\n    input [1:0] b,\n    input cin,\n    output [1:0] sum,\n    output cout\n);\n\n    reg [2:0] temp_sum;\n    wire [1:0] temp_cout;\n\n    always @(posedge clk) begin\n        temp_sum <= {1'b0, a} + {1'b0, b} + {1'b0, cin};\n        temp_cout <= temp_sum[2];\n    end\n\n    assign sum = temp_sum[1:0];\n    assign cout = temp_cout;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 3-to-8 decoder with active low outputs. The module should have three inputs (A, B, and C) and eight outputs (Y0-Y7). Only one output should be low at a time, depending on the input values.", "output": "module decoder (\n    input A,\n    input B,\n    input C,\n    output reg [7:0] Y\n);\n\nalways @(*) begin\n    case ({A,B,C})\n        3'b000: Y = 8'b111_11110;\n        3'b001: Y = 8'b111_11101;\n        3'b010: Y = 8'b111_11011;\n        3'b011: Y = 8'b111_10111;\n        3'b100: Y = 8'b111_01111;\n        3'b101: Y = 8'b110_11111;\n        3'b110: Y = 8'b101_11111;\n        3'b111: Y = 8'b011_11111;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in a 4-bit input `A` and outputs the 2's complement of `A`. The module should be named `complement` and should have the following inputs and outputs:\n\nInputs:\n- `A` (4-bit input)\n\nOutputs:\n- `C` (4-bit output)\n\nThe module should use the following logic to calculate the 2's complement of `A`:\n- Invert all bits of `A`\n- Add 1 to the result\n\nYou can assume that the input `A` will always be a valid 4-bit binary number.\n\nWrite the Verilog code for the `complement` module.\n\n", "output": "module complement(\n    input [3:0] A,\n    output reg [3:0] C\n);\n\n    always @(*) begin\n        C = ~A + 4'b1;\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a simple calculator that can perform basic arithmetic operations. The calculator should be able to add, subtract, multiply, and divide two input values. The inputs and outputs should be 8-bit unsigned integers. The calculator should also have a clear input that resets the calculator to 0.\n\nDesign a Verilog module for this calculator that can perform all of the required operations. Your module should have the following inputs and outputs:\n\n- `clk`: The clock signal\n- `reset`: A synchronous reset signal that resets the calculator to 0\n- `op`: A 2-bit input that specifies the operation to perform (00 for addition, 01 for subtraction, 10 for multiplication, 11 for division)\n- `a`: An 8-bit input that represents the first operand\n- `b`: An 8-bit input that represents the second operand\n- `result`: An 8-bit output that represents the result of the operation\n\nYour module should be able to perform the operations in a single clock cycle and should be implemented within 200 lines of Verilog code.\n\n", "output": "module calculator(\n  input clk,\n  input reset,\n  input [1:0] op,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] result\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      result <= 0;\n    end else begin\n      case (op)\n        2'b00: result <= a + b;\n        2'b01: result <= a - b;\n        2'b10: result <= a * b;\n        2'b11: result <= a / b;\n      endcase\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2-to-4 line decoder with enable input. The module should have two inputs (A and B), an enable input (EN), and four outputs (Y0-Y3). When EN is high, only one of the outputs should be low, depending on the input values.", "output": "module decoder (\n    input A,\n    input B,\n    input EN,\n    output reg [3:0] Y\n);\n\nalways @ (A or B or EN) begin\n    if (EN) begin\n        case ({A, B})\n            2'b00: Y = 4'b0001;\n            2'b01: Y = 4'b0010;\n            2'b10: Y = 4'b0100;\n            2'b11: Y = 4'b1000;\n        endcase\n    end else begin\n        Y = 4'b0000;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a clock gating functionality. The module should have the following inputs and outputs:\n- `CLK`: a clock input\n- `EN`: an enable input\n- `TE`: a transparent enable input\n- `ENCLK`: an output that is the gated version of the clock input\n\nWhen `EN` is high, the output `ENCLK` should be the same as the input `CLK`. When `EN` is low, the output `ENCLK` should be low, regardless of the value of `CLK`. However, when `TE` is high, the output `ENCLK` should be the same as the input `CLK`, regardless of the value of `EN`.\n\nYou should implement the module using a level-sensitive latch. You should also include a SDF annotation that specifies the timing constraints for the module.\n\nYour solution should consist of a single Verilog module that implements the clock gating functionality described above. The module should be no more than 200 lines of code.\n\n", "output": "module clock_gate (\n    input CLK,\n    input EN,\n    input TE,\n    output reg ENCLK\n);\n\n    // level-sensitive latch\n    always @(posedge CLK) begin\n        if (EN) begin\n            ENCLK <= CLK;\n        end else if (TE) begin\n            ENCLK <= CLK;\n        end else begin\n            ENCLK <= 1'b0;\n        end\n    end\n\n    // SDF annotation\n    initial begin\n        $sdf_annotate(\"FPU_Interface2_ASIC_fpu_syn_constraints_clk10.tcl_GATED_KOA_2STAGE_syn.sdf\");\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 16-bit adder that takes two 16-bit inputs and produces a 16-bit output. The module should have the following inputs and outputs:\n\nInputs:\n- `a` (16-bit signed integer)\n- `b` (16-bit signed integer)\n- `clk` (1-bit clock signal)\n- `rst` (1-bit reset signal)\n\nOutputs:\n- `sum` (16-bit signed integer)\n\nThe module should perform the addition operation on `a` and `b` every clock cycle when the `clk` signal is high. If the `rst` signal is high, the module should reset to zero and wait for a new input.\n\nAssume that overflow and underflow conditions will not occur.\n\n", "output": "module adder(\n    input signed [15:0] a,\n    input signed [15:0] b,\n    input clk,\n    input rst,\n    output reg signed [15:0] sum\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sum <= 0;\n    end else begin\n        sum <= a + b;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple calculator that can perform basic arithmetic operations on two 8-bit inputs. The module should have the following inputs and outputs:\n\nInputs:\n- `a`: an 8-bit input representing the first operand\n- `b`: an 8-bit input representing the second operand\n- `op`: a 2-bit input representing the operation to be performed. `op` can take the following values:\n  - `00`: addition\n  - `01`: subtraction\n  - `10`: multiplication\n  - `11`: division\n\nOutputs:\n- `result`: an 8-bit output representing the result of the operation\n- `overflow`: a 1-bit output indicating whether an overflow occurred during the operation. An overflow occurs when the result of an addition or subtraction operation exceeds the maximum value of an 8-bit number (255) or when the result of a multiplication operation exceeds the maximum value of a 16-bit number (65535). The `overflow` output should be high if an overflow occurred and low otherwise.\n\nYour module should be named `calculator` and should be designed to be synthesizable. Your module should be able to perform the operations accurately and efficiently within 200 lines of Verilog code.\n\n", "output": "module calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    output [7:0] result,\n    output overflow\n);\n\nreg [15:0] temp_result;\n\nalways @(*) begin\n    case(op)\n        2'b00: temp_result = a + b;\n        2'b01: temp_result = a - b;\n        2'b10: temp_result = a * b;\n        2'b11: temp_result = a / b;\n    endcase\nend\n\nassign result = temp_result[7:0];\nassign overflow = (op[1] == 0) ? (temp_result > 8'hFF) : (temp_result > 16'hFFFF);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary counter with a synchronous reset and a load enable input. The counter should increment on every positive edge of the clock signal when the load enable input is low. When the load enable input is high, the counter should load the value on the input data bus on the next positive edge of the clock signal. The output of the counter should be available on a 4-bit output bus.\n\nThe module should have the following inputs and outputs:\n\n- `clk` (input): a clock signal\n- `reset` (input): a synchronous reset signal that resets the counter to 0 when high\n- `load_en` (input): a load enable signal that determines whether the counter should increment or load the input data\n- `data_in` (input): a 4-bit input bus that provides data to be loaded into the counter when `load_en` is high\n- `count_out` (output): a 4-bit output bus that provides the current count value of the counter\n\nYou may use any Verilog constructs or modules that you see fit to implement the counter.\n\n", "output": "module binary_counter(clk, reset, load_en, data_in, count_out);\n  input clk, reset, load_en;\n  input [3:0] data_in;\n  output reg [3:0] count_out;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      count_out <= 4'b0;\n    end else if (load_en) begin\n      count_out <= data_in;\n    end else begin\n      count_out <= count_out + 1;\n    end\n  end\nendmodule"}
{"instruction": "\n\nYou are asked to create a verilog module for a simple calculator that can perform addition and subtraction operations on two 4-bit numbers. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `reset`: a synchronous active-high reset signal\n- `a`: a 4-bit input representing the first operand\n- `b`: a 4-bit input representing the second operand\n- `op`: a 1-bit input representing the operation to be performed (0 for addition, 1 for subtraction)\n\nOutputs:\n- `result`: a 4-bit output representing the result of the operation\n\nThe module should perform the following operations:\n- If `reset` is high, the `result` output should be set to 0.\n- If `op` is 0, the `result` output should be the sum of `a` and `b`.\n- If `op` is 1, the `result` output should be the difference between `a` and `b`.\n\n", "output": "module calculator (\n   // Inputs\n   clk,\n   reset,\n   a,\n   b,\n   op,\n\n   // Outputs\n   result\n   );\n\n   input clk, reset;\n   input [3:0] a, b;\n   input op;\n   output reg [3:0] result;\n\n   always @ (posedge clk) begin\n      if (reset) begin\n         result <= 4'b0;\n      end else begin\n         if (op == 0) begin\n            result <= a + b;\n         end else begin\n            result <= a - b;\n         end\n      end\n   end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in a 32-bit `data_in` input and outputs a 16-bit `data_out` by performing the following operations:\n1. If the 2 most significant bits of `data_in` are `01`, then `data_out` should be the 16 least significant bits of `data_in`.\n2. If the 2 most significant bits of `data_in` are `10`, then `data_out` should be the 16 most significant bits of `data_in`.\n3. If the 2 most significant bits of `data_in` are `11`, then `data_out` should be the 16 most significant bits of the bitwise complement of `data_in`.\n4. If the 2 most significant bits of `data_in` are `00`, then `data_out` should be the 16 least significant bits of the bitwise complement of `data_in`.\n\nYour module should have the following inputs and outputs:\n- `input [31:0] data_in`: the 32-bit input data\n- `output [15:0] data_out`: the 16-bit output data\n\n", "output": "module data_converter(\n    input [31:0] data_in,\n    output [15:0] data_out\n);\n\n    wire [1:0] msb = data_in[31:30];\n\n    assign data_out = (msb == 2'b01) ? data_in[15:0] :\n                     (msb == 2'b10) ? data_in[31:16] :\n                     (msb == 2'b11) ? ~data_in[31:16] :\n                                      ~data_in[15:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes three inputs (A, B, C) and outputs the logical OR of the inputs (X). You will be provided with a code snippet for inspiration, but you are free to design your module in any way you see fit as long as it is within 200 lines of Verilog code.\n\nYour module should be named \"my_or_gate\" and should have the following inputs and outputs:\n\nInputs:\n- A (1-bit)\n- B (1-bit)\n- C (1-bit)\n\nOutputs:\n- X (1-bit)\n\nYou should also include the following voltage supply signals:\n- VPWR (1-bit)\n- VGND (1-bit)\n- VPB (1-bit)\n- VNB (1-bit)\n\nYour module should be able to handle all possible input combinations and should output the correct logical OR value.\n\n", "output": "module my_or_gate (\n    X,\n    A,\n    B,\n    C,\n    VPWR,\n    VGND,\n    VPB,\n    VNB\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire AB;\n    wire BC;\n    wire AC;\n\n    assign AB = A | B;\n    assign BC = B | C;\n    assign AC = A | C;\n\n    assign X = AB | BC | AC;\n\nendmodule"}
{"instruction": "Design a module that can detect the falling edge of a 32-bit binary input signal. The output should be a 32-bit binary signal that will remain high until the module is reset using a synchronous reset. You are only allowed to use a counter and a comparator to achieve this functionality.", "output": "module falling_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] counter;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        counter <= 0;\n        out <= 0;\n    end\n    else begin\n        counter <= counter + 1;\n        if (in < counter) begin\n            out <= 1;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, a multiplexer (or MUX) is a device that selects one of several input signals and forwards the selected input into a single output line. The selection of the input signal is controlled by a set of binary inputs called select lines. In this problem, you are tasked with designing a 2:1 multiplexer using Verilog.\n\nThe multiplexer should have two input lines, A and B, and one output line, Y. It should also have one select line, S. When S is 0, the output Y should be equal to A. When S is 1, the output Y should be equal to B. You should use the following module definition:\n\n```\nmodule mux_2to1 (\n    input A,\n    input B,\n    input S,\n    output Y\n);\n```\n\nYou should implement the multiplexer using only logic gates, such as AND, OR, and NOT gates. You should not use any pre-built multiplexer modules.\n\nWrite a Verilog module that implements the 2:1 multiplexer using only logic gates. Your module should be named \"mux_2to1\" and should have the inputs and outputs specified as shown above.\n\n", "output": "module mux_2to1 (\n    input A,\n    input B,\n    input S,\n    output Y\n);\n    wire notS;\n    assign notS = ~S;\n    \n    wire and1, and2;\n    assign and1 = A & notS;\n    assign and2 = B & S;\n    \n    assign Y = and1 | and2;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-to-1 multiplexer. The module should have four input ports, one output port, and a select input port. The select input port should be a single bit that determines which input port should be connected to the output port. If the select input is 0, then the output should be connected to the first input port. If the select input is 1, then the output should be connected to the second input port. If the select input is 2, then the output should be connected to the third input port. If the select input is 3, then the output should be connected to the fourth input port. \n\nYou should name your module \"mux4to1\" and ensure that it is synthesizable. \n\n", "output": "module mux4to1(\n    input [3:0] data_in,\n    input [1:0] sel,\n    output reg data_out\n);\n\nalways @(*) begin\n    case (sel)\n        2'b00: data_out = data_in[0];\n        2'b01: data_out = data_in[1];\n        2'b10: data_out = data_in[2];\n        2'b11: data_out = data_in[3];\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that can be used to control a digital circuit. The module should have the following inputs and outputs:\n\nInputs:\n- RESET_B: a single bit input that will reset the circuit when it is set to 0.\n- D: a single bit input that will be used to set the output of the circuit.\n- GATE_N: a single bit input that will be used to enable or disable the circuit.\n- VPWR: a power supply input.\n- VGND: a ground input.\n- VPB: a positive power supply input.\n- VNB: a negative power supply input.\n\nOutputs:\n- Q: a single bit output that will be the output of the circuit.\n\nYour task is to write a Verilog module that can be used to control the circuit. The module should be named `my_circuit` and should be designed to meet the following specifications:\n\n1. When RESET_B is set to 0, the output Q should be set to 0.\n2. When GATE_N is set to 1, the output Q should be set to the value of the input D.\n3. When GATE_N is set to 0, the output Q should remain unchanged.\n4. The module should be designed to work with the given power supply inputs.\n\nYou should assume that all inputs and outputs are single bit signals.\n\n", "output": "module my_circuit (\n    Q      ,\n    RESET_B,\n    D      ,\n    GATE_N ,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    wire Q_int;\n\n    assign Q = Q_int;\n\n    sky130_fd_sc_ms__dlrtn base (\n        .Q(Q_int),\n        .RESET_B(RESET_B),\n        .D(D),\n        .GATE_N(GATE_N),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 2-bit binary counter using D flip-flops. The module should have two inputs: a clock signal (clk) and a reset signal (rst). When the reset signal is high, the counter should be reset to 00. When the clock signal transitions from low to high, the counter should increment by one. The module should have two outputs: Q1 and Q0, representing the two bits of the counter.\n\nYour implementation should use only D flip-flops and basic logic gates (AND, OR, NOT). You are not allowed to use any pre-built counters or other complex modules.\n\nWrite a Verilog module that implements the above functionality. Your module should be named \"binary_counter\" and have the following interface:\n\n```\nmodule binary_counter (\n    input clk,\n    input rst,\n    output reg Q1,\n    output reg Q0\n);\n```\n\nAssume that the input signals are synchronous to the rising edge of the clock signal and that the reset signal is asynchronous.\n\n", "output": "module binary_counter (\n    input clk,\n    input rst,\n    output reg Q1,\n    output reg Q0\n);\n\n    reg D1, D0;\n\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            D1 <= 1'b0;\n            D0 <= 1'b0;\n        end else begin\n            D1 <= Q0;\n            D0 <= ~Q0;\n        end\n    end\n\n    assign Q1 = D1;\n    assign Q0 = D0;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit shift register with a parallel load function. The shift register has two inputs, clk and load, and two outputs, q and q_bar. The clk input is the clock signal which is used to synchronize the shift register. The load input is a control signal which will load the data from the parallel input, p, into the shift register when it is high. The shift register should shift the data in q to the left on every rising edge of the clock signal. The q output is the output of the shift register which will be the current value stored in the shift register. The q_bar output is the inverse of the q output. The module should have an always block which is triggered on the rising edge of the clock signal.", "output": "module shift_register (\n  input clk,\n  input load,\n  input [3:0] p,\n  output reg [3:0] q,\n  output reg [3:0] q_bar\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      q <= p;\n      q_bar <= ~p;\n    end else begin\n      q <= {q[2:0], 1'b0};\n      q_bar <= ~{q[2:0], 1'b0};\n    end\n  end\n  \nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a comparator for unsigned and signed numbers. \nA comparator is a digital circuit that compares two input signals and outputs a signal indicating which one is greater.\nYour module should have the following inputs and outputs:\n\nInputs: two n-bit input signals (in1, in2)\nOutputs: a single bit output signal (out)\nThe module should also have the following parameter:\n\ns: a parameter indicating whether the inputs are signed (s=1) or unsigned (s=0)\nYour module should implement the following functionality:\n\nIf s=0, the module should output a 1 if in1 is greater than in2, and a 0 otherwise.\nIf s=1, the module should output a 1 if in1 is greater than in2 in two's complement representation, and a 0 otherwise.\nTo implement the comparator, you should use Verilog code to define the comparison logic based on the input signals and the value of s.\nYou can use if-else statements or ternary operators to compare the input signals, and assign the result to the output signal.", "output": "module comparator (\n  input [n-1:0] in1,\n  input [n-1:0] in2,\n  output out\n);\n\nparameter n = 4; // number of bits in input signals\nparameter s = 0; // 0 for unsigned, 1 for signed\n\n  assign out = (s == 1) ? (in1[n-1] ^ in2[n-1] ? in1[n-1] : in1 > in2) : (in1 > in2);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Develop a Verilog module that implements a 4-bit binary counter with a synchronous reset. The module should have four input ports: clk, rst, en, and load. The module should have two output ports: q, and q_bar. The q and q_bar ports should output the binary count and its complement, respectively. When the load input is high, the counter should load the value from the input ports and start counting from that value. When the enable input is high, the counter should increment by one on each rising edge of the clk input. When the reset input is high, the counter should reset to zero.", "output": "module binary_counter (\n  input clk,\n  input rst,\n  input en,\n  input load,\n  output reg [3:0] q,\n  output reg [3:0] q_bar\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      q <= 4'b0000;\n    end else if (en) begin\n      q <= q + 1;\n    end else if (load) begin\n      q <= {q_bar[3], q_bar[2], q_bar[1], q_bar[0]};\n    end\n  end\n\n  assign q_bar = ~q;\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 8 inputs and outputs a single bit. The module should be named `bitwise_module` and should implement a bitwise function that calculates the following expression: `((A1 & A2) | (A3 & B1)) & (VPWR ^ VGND) & (VPB | VNB)`.\nThe inputs to the module are as follows:\n- `A1`: a single bit input\n- `A2`: a single bit input\n- `A3`: a single bit input\n- `B1`: a single bit input\n- `VPWR`: a single bit input\n- `VGND`: a single bit input\n- `VPB`: a single bit input\n- `VNB`: a single bit input\n\nThe output of the module is a single bit named `out`.\n\nYou are required to write a Verilog module that implements the above functionality. Your module should be named `bitwise_module` and should be no longer than 200 lines of code.\n\n", "output": "module bitwise_module(\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output out\n);\n\nwire and1, and2, or1, xor1, or2;\n\nassign and1 = A1 & A2;\nassign and2 = A3 & B1;\nassign or1 = and1 | and2;\nassign xor1 = VPWR ^ VGND;\nassign or2 = VPB | VNB;\n\nassign out = or1 & xor1 & or2;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 8-bit shift register with a parallel load capability. The module should have three inputs (data_in, shift, and load) and one output (data_out). When shift is high, the contents of the shift register should be shifted left by one bit. When load is high, the contents of the shift register should be loaded with the value of data_in. When both shift and load are low, the contents of the shift register should remain unchanged.", "output": "module shift_reg (\n    input [7:0] data_in,\n    input shift,\n    input load,\n    output reg [7:0] data_out\n);\n\n    reg [7:0] shift_reg;\n\n    always @ (posedge shift) begin\n        shift_reg <= {shift_reg[6:0], 1'b0};\n    end\n\n    always @ (posedge load) begin\n        shift_reg <= data_in;\n    end\n\n    assign data_out = shift_reg;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a simple computer architecture. The module should be responsible for controlling access to memory and handling read/write operations. The memory is modeled as a 4K x 8-bit RAM, and the module should support both byte and word access (i.e., 8-bit and 16-bit data transfers).\n\nYour module should have the following inputs:\n\n- `clk`: a clock signal\n- `rst`: a synchronous reset signal\n- `addr`: a 12-bit address bus\n- `we`: a write enable signal\n- `din`: a 16-bit data input bus\n\nAnd the following outputs:\n\n- `dout`: a 16-bit data output bus\n- `ack`: an acknowledge signal indicating that the operation has been completed successfully\n\nThe module should implement the following behavior:\n\n- On the rising edge of `clk`, if `rst` is high, the module should reset its internal state and output `ack` low.\n- If `we` is high, the module should write the data on `din` to the memory address specified by `addr`. The module should output `ack` high once the write operation is complete.\n- If `we` is low, the module should read the data from the memory address specified by `addr` and output it on `dout`. The module should output `ack` high once the read operation is complete.\n\nYou should ensure that the module meets the following requirements:\n\n- The module should be synthesizable and meet timing requirements for a 50MHz clock.\n- The module should generate no latches or inferred memory.\n- The module should have a single always block for clocked behavior.\n- The module should not use any non-blocking assignments.\n- The module should be designed to minimize area and power consumption.\n\n", "output": "module memory_controller (\n    input clk,\n    input rst,\n    input [11:0] addr,\n    input we,\n    input [15:0] din,\n    output reg [15:0] dout,\n    output reg ack\n);\n\n    reg [15:0] mem [0:4095];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            ack <= 0;\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n                ack <= 1;\n            end else begin\n                dout <= mem[addr];\n                ack <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module for a Gray code decoder. The module should take in a Gray code input and output the corresponding binary code. The input and output should be of the same width, which is given as a parameter. \n\nThe module should have two ports: `gin` and `bout`. `gin` is an input port of width `width`, which takes in the Gray code. `bout` is an output port of width `width`, which outputs the corresponding binary code. \n\nThe module should use a reg `breg` of width `width`, which stores the binary code. The module should also use an integer `i` for iteration. \n\nThe output `bout` should be calculated using the following steps:\n- The MSB of `breg` should be set equal to the MSB of `gin`.\n- For each bit position from `width-2` to `0`, the corresponding bit of `breg` should be set equal to the XOR of the current bit of `gin` and the next bit of `breg`.\n\nDesign the module `gray_decoder` to implement this functionality. \n\n", "output": "module gray_decoder (\n        gin, \n        bout\n);\n\nparameter width = 6;\n\ninput  [width-1 : 0] gin;\noutput [width-1 : 0] bout;\n\nreg    [width-1 : 0] breg;\ninteger i;\nassign bout = breg;\n\nalways @(gin)\nbegin\n    breg[width-1] = gin[width-1];\n    if (width > 1)\n    begin\n        for (i=width-2; i >= 0; i=i-1)\n            breg[i] = breg[i+1] ^ gin[i];\n    end\nend\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes in four 1-bit inputs A, B, C, and D and outputs a 2-bit signal Y. The output Y is the sum of the inputs modulo 4. The module should be named `mod4sum` and should have the following interface:\n\n```verilog\nmodule mod4sum(\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [1:0] Y\n);\n```\n\nYou should use the provided code snippet as a reference.\n\n", "output": "module mod4sum(\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [1:0] Y\n);\n\n    always @ (A, B, C, D) begin\n        Y = {A, B} + {C, D};\n        if (Y >= 4) Y = Y - 4;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `counter` that implements a simple counter. The module has two inputs, `clk` and `reset`, and one output, `count`. The `count` output is a 4-bit binary number that increments on every rising edge of the `clk` input, unless the `reset` input is high, in which case the `count` output is set to 0. \n\nYour task is to create a new Verilog module `counter_top` that instantiates two instances of the `counter` module and connects them in such a way that the `count` outputs of both instances are added together to produce a 5-bit binary number that is output by `counter_top`. The `clk` input of both `counter` instances should be connected to the same input, and the `reset` input of both instances should be connected to the same input.\n\nYou should implement the `counter_top` module within 200 lines of Verilog code. Your implementation should be self-contained and should not make use of any external Verilog modules or libraries. You may use any Verilog language constructs that you deem appropriate.\n\n", "output": "module counter(\n  input clk,\n  input reset,\n  output [3:0] count\n);\n\nreg [3:0] count_reg;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count_reg <= 4'b0000;\n  end else begin\n    count_reg <= count_reg + 1;\n  end\nend\n\nassign count = count_reg;\n\nendmodule\n\n\nmodule counter_top(\n  input clk,\n  input reset,\n  output reg [4:0] count\n);\n\nwire [3:0] count1, count2;\n\ncounter c1(\n  .clk(clk),\n  .reset(reset),\n  .count(count1)\n);\n\ncounter c2(\n  .clk(clk),\n  .reset(reset),\n  .count(count2)\n);\n\nalways @(posedge clk) begin\n  count <= count1 + count2;\nend\n\nendmodule"}
{"instruction": "As a professional Verilog designer, create a pipelined module that implements a 16-bit barrel shifter. The module should have two inputs (data and shift_amount) and one output (shifted_data). \nThe shift_amount input should be a 4-bit unsigned value that determines the number of bits to shift the data input to the left. If the shift_amount input is greater than 15, the output should be 0. If the shift_amount input is less than or equal to 15, the output should be the data input shifted to the left by the number of bits specified by the shift_amount input. \nUse pipeline structure to achieve this functionality.", "output": "module barrel_shifter (\n    input [15:0] data,\n    input [3:0] shift_amount,\n    output reg [15:0] shifted_data\n);\n\nreg [15:0] shifted_data_reg1;\nreg [15:0] shifted_data_reg2;\nreg [15:0] shifted_data_reg3;\n\nalways @(*) begin\n    shifted_data_reg1 = data << shift_amount;\nend\n\nalways @(*) begin\n    shifted_data_reg2 = shifted_data_reg1 << 1;\nend\n\nalways @(*) begin\n    shifted_data_reg3 = shifted_data_reg2 << 1;\nend\n\nalways @(posedge clk) begin\n    if (shift_amount > 15) begin\n        shifted_data <= 0;\n    end else begin\n        shifted_data <= shifted_data_reg3;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 2-to-1 multiplexer using Verilog. The module should have the following inputs and outputs:\n\nInputs:\n- A (1-bit)\n- B (1-bit)\n- Sel (1-bit)\n\nOutputs:\n- Out (1-bit)\n\nIf Sel is 0, Out should be equal to A. If Sel is 1, Out should be equal to B.\n\nWrite a Verilog module that implements this functionality. Your module should be named \"mux_2to1\" and should have the same inputs and outputs as described above. You should also include any necessary declarations for power and ground signals.\n\n", "output": "module mux_2to1 (\n    input A,\n    input B,\n    input Sel,\n    output Out,\n    input VPB,\n    input VPWR,\n    input VGND,\n    input VNB\n);\n\nassign Out = (!Sel & A) | (Sel & B);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in a 4-bit binary input `data_in` and outputs a 4-bit binary output `data_out`. The output should be the inverse of the input, i.e. if the input is `1010`, the output should be `0101`. You should also include a control input `enable` which, when high, enables the module to perform the inversion operation. When `enable` is low, the output should be the same as the input. The module should be named `inv_module` and should be written in Verilog within 200 lines of code. \n\n", "output": "module inv_module (\n    input [3:0] data_in,\n    input enable,\n    output [3:0] data_out\n);\n\n    wire [3:0] inverted_data;\n\n    assign inverted_data = ~data_in;\n\n    assign data_out = enable ? inverted_data : data_in;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a D flip-flop with synchronous reset and clock enable behavior in Verilog. The D flip-flop should have the following behavior:\n- When the clock enable signal (ce) is high, the flip-flop should follow the input data (D) on the rising edge of the clock (Clk).\n- When the clock enable signal (ce) is low, the flip-flop should hold its current state.\n- When the synchronous reset signal (reset) is high, the flip-flop should be reset to 0 on the rising edge of the clock (Clk).\nYou should write a single module in Verilog that implements this behavior. Your module should have the following inputs and outputs:\n- D: the input data\n- Clk: the clock signal\n- reset: the synchronous reset signal\n- ce: the clock enable signal\n- Q: the output of the flip-flop\nYou may assume that all input signals are synchronous to the same clock signal, and that the clock signal has a 50% duty cycle.\n\n", "output": "module D_ff_with_ce_and_synch_reset_behavior(\n    input D, Clk, reset, ce,\n    output reg Q\n);\n\nalways @(posedge Clk) begin\n    if (reset) begin\n        Q <= 0;\n    end else if (ce) begin\n        Q <= D;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module named `sky130_fd_sc_hd__a2111oi_0` which has 10 input/output ports. The output port `Y` is connected to the output of an instance of another module named `sky130_fd_sc_hd__a2111oi`. The module `sky130_fd_sc_hd__a2111oi_0` has been instantiated in a larger Verilog design and is responsible for connecting the input ports of the instance of `sky130_fd_sc_hd__a2111oi`.\n\nYour task is to write the Verilog code for the `sky130_fd_sc_hd__a2111oi_0` module. The module takes 9 input ports and has 1 output port. The input ports are `A1`, `A2`, `B1`, `C1`, `D1`, `VPWR`, `VGND`, `VPB`, and `VNB`. The output port is `Y`. The `sky130_fd_sc_hd__a2111oi` module has 6 input ports and 1 output port, which are all connected to the corresponding input and output ports of `sky130_fd_sc_hd__a2111oi_0`.\n\nYour module should have the following behavior:\n- When `A1` and `A2` are both high, `Y` should be high.\n- When `A1` is low and `A2` is high, `Y` should be low.\n- When `A1` is high and `A2` is low, `Y` should be low.\n- When `A1` and `A2` are both low, `Y` should be high if `B1` is high and `C1` and `D1` are both low. Otherwise, `Y` should be low.\n\nYou should assume that all input signals are valid and that there are no timing constraints.\n\n", "output": "module sky130_fd_sc_hd__a2111oi_0 (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    assign Y = (A1 & A2) | (~A1 & ~A2 & B1 & ~C1 & ~D1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a clock generator with a reset signal. The module should output a clock signal and a reset signal that can be used to reset any other Verilog module in the design. The module should have two inputs: `sys_clk` and `sys_reset`. The `sys_clk` input is a clock signal with a frequency of 100 MHz, and the `sys_reset` input is a reset signal that is active-high.\n\nThe module should generate a clock signal with a frequency of 50 MHz by dividing the frequency of the `sys_clk` input by two. The clock signal should have a 50% duty cycle. Additionally, the module should assert the reset signal for the first 10 cycles of the generated clock signal. After the first 10 cycles, the reset signal should be deasserted and remain deasserted for the duration of the simulation.\n\nYour Verilog module should be named `clock_generator` and should have the following ports:\n\n- `sys_clk`: input, 1-bit\n- `sys_reset`: input, 1-bit\n- `clk_out`: output, 1-bit\n- `reset_out`: output, 1-bit\n\nYou should implement the `clock_generator` module within 200 lines of Verilog code.\n\n", "output": "module clock_generator(\n    input sys_clk,\n    input sys_reset,\n    output reg clk_out,\n    output reg reset_out\n);\n\nreg [3:0] counter;\n\nalways @(posedge sys_clk) begin\n    if (counter == 4'd9) begin\n        counter <= 4'd0;\n        reset_out <= 1'b0;\n    end else begin\n        counter <= counter + 4'd1;\n        reset_out <= 1'b1;\n    end\n    clk_out <= counter[0];\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit synchronous up-counter with parallel load capability. The module should have two inputs: a clock input and a parallel load input. When the parallel load input is high, the module should load a 4-bit value from its input pins. Otherwise, the module should increment its count value on each clock cycle.", "output": "module up_counter (\n    input clk,\n    input load,\n    input [3:0] load_value,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            count <= load_value;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a clock gate with an enable input and a positive-edge triggered D flip-flop with an enable input. The module should have four inputs and one output:\n- `CLK`: a clock input\n- `EN`: an enable input for the clock gate\n- `TE`: an enable input for the flip-flop\n- `D`: the data input for the flip-flop\n- `ENCLK`: the output of the clock gate, which should be connected to the clock input of the flip-flop\n\nThe clock gate should be implemented using the following logic:\n- When `EN` is high, `ENCLK` should be equal to `CLK`\n- When `EN` is low, `ENCLK` should be low\n\nThe flip-flop should be implemented using a positive-edge triggered D flip-flop with asynchronous reset, and should be enabled when `TE` is high. The output of the flip-flop should be connected to a wire `Q`.\n\nYour task is to implement a Verilog module that satisfies these requirements.\n\n", "output": "module clock_gate_d_ff_en(input CLK, input EN, input TE, input D, output reg Q);\n  wire ENCLK;\n\n  assign ENCLK = EN ? CLK : 1'b0; // Clock gate implementation\n\n  always @(posedge ENCLK) begin // Positive-edge triggered D flip-flop with asynchronous reset\n    if (!TE) begin\n      Q <= 1'b0;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 3-bit binary-to-gray code converter. The module should have the following inputs and outputs:\n- `bin_in`: a 3-bit binary input\n- `gray_out`: a 3-bit gray code output\n\nImplement the module using behavioral modeling.\n\n", "output": "module bin2gray(\n    input [2:0] bin_in,\n    output [2:0] gray_out\n);\n\n// Implement the gray code conversion using behavioral modeling\nalways @(*) begin\n    gray_out[2] = bin_in[2];\n    gray_out[1] = bin_in[2] ^ bin_in[1];\n    gray_out[0] = bin_in[1] ^ bin_in[0];\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 2-input buffer that can buffer the input signal and output it to the output port. The module should have the following interface:\n\nInputs:\n- A (1-bit input): The input signal to be buffered.\n\nOutputs:\n- X (1-bit output): The buffered output signal.\n\nThe module should be named \"my_buffer\" and should be contained within 200 lines of Verilog code. The module should also include the following voltage supply signals:\n- VPWR: Voltage supply signal for positive power.\n- VGND: Voltage supply signal for ground.\n- VPB: Voltage supply signal for positive power of buffer.\n- VNB: Voltage supply signal for negative power of buffer.\n\nAssume that the input signal is valid and stable and that the output signal should be identical to the input signal.\n\n", "output": "module my_buffer (\n    X,\n    A,\n    VPWR,\n    VGND,\n    VPB,\n    VNB\n);\n\n    output X;\n    input A;\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign X = A;\n\nendmodule"}
{"instruction": "Design a 16-bit Gray code counter using Verilog. The module should have a clock input and a reset input. The counter should count in Gray code sequence from 0 to 65535 and then start over. You are only allowed to use D flip-flops and XOR gates to implement this counter.", "output": "module gray_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [15:0]   Q\n);\n\n  reg [15:0] next_state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      Q <= 16'b0;\n      next_state <= 16'b0;\n    end\n    else begin\n      Q <= next_state;\n      next_state <= Q ^ ({Q[14:0],1'b0});\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with implementing a verilog module that takes in a 4-bit input `in` and a 2-bit input `sel`, and outputs a 2-bit value `out` based on the following truth table:\n\n| in | sel | out |\n|----|-----|-----|\n| 0  | 00  | 00  |\n| 1  | 00  | 01  |\n| 0  | 01  | 11  |\n| 1  | 01  | 10  |\n| 0  | 10  | 10  |\n| 1  | 10  | 11  |\n| 0  | 11  | 01  |\n| 1  | 11  | 00  |\n\nYou should use a case statement to implement this logic.\n\n", "output": "module sel_logic(\n  input [3:0] in,\n  input [1:0] sel,\n  output reg [1:0] out\n);\n\n  always @*\n  begin\n    case({in, sel})\n      4'b0000: out = 2'b00;\n      4'b0001: out = 2'b01;\n      4'b0100: out = 2'b11;\n      4'b0101: out = 2'b10;\n      4'b1000: out = 2'b10;\n      4'b1001: out = 2'b11;\n      4'b1100: out = 2'b01;\n      4'b1101: out = 2'b00;\n      default: out = 2'b00;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in a clock signal, a 126-bit input signal `a`, and outputs a single bit `q`. The module should have a register `g_r` that stores the input signal `a` and a 7-bit register `sel` that stores the 7 least significant bits of `a`. \n\nThe output `q` should be equal to the value of the `sel` bit of the 128-bit wire `g_extend`, which is a concatenation of the 126-bit register `g_r` with two additional bits `1'b1` and `1'b0` in that order.\n\nWrite a Verilog module that implements the above requirements. \n\n", "output": "module sub (\n   input clk,\n   input [125:0] a,\n   output reg q\n   );\n\n   reg [125:0] g_r;\n\n   wire [127:0] g_extend = { g_r, 1'b1, 1'b0 };\n\n   reg [6:0] sel;\n   wire g_sel = g_extend[sel];\n\n   always @ (posedge clk) begin\n      g_r <= a;\n      sel <= a[6:0];\n      q <= g_sel;\n   end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 4-to-2 multiplexer with an active-low enable signal. The module should have 4 input ports (A0, A1, A2, A3), 2 select ports (S0, S1), and 1 output port (X). When the enable signal (EN) is high, the output should be set to 0. When the enable signal is low, the output should be selected based on the select inputs (S0, S1). If S0 and S1 are both low, the output should be A0. If S0 is low and S1 is high, the output should be A1. If S0 is high and S1 is low, the output should be A2. If S0 and S1 are both high, the output should be A3.\n\nYour module should be named \"mux_4to2\" and should be contained within 200 lines of Verilog code.\n\n", "output": "module mux_4to2 (\n    X,\n    A0,\n    A1,\n    A2,\n    A3,\n    S0,\n    S1,\n    EN\n);\n\n    output X;\n    input A0;\n    input A1;\n    input A2;\n    input A3;\n    input S0;\n    input S1;\n    input EN;\n\n    wire X0, X1;\n\n    assign X0 = (S0 & S1) ? A3 : (S0 ? A2 : (S1 ? A1 : A0));\n    assign X1 = (EN == 1'b0) ? X0 : 1'b0;\n    assign X = X1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a Verilog module that generates the first 12 numbers of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. In this case, the first two numbers are 1 and 1, so the sequence goes 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144.\n\nYour module should have a clock input, a reset input, and an output bus of 8 bits. The module should output the Fibonacci sequence on the output bus, one number at a time. Once all 12 numbers have been output, the module should reset and start outputting the sequence again from the beginning.\n\nYour module should be implemented in a single module with no more than 200 lines of Verilog code. You should also ensure that your module passes the following test: the output of your module should match the expected output (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144) for the first 12 clock cycles after reset.\n\n", "output": "module fibonacci(\n    input clk,\n    input reset,\n    output reg [7:0] out\n);\n\nreg [7:0] a, b, c;\nreg [3:0] cnt;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        a <= 8'h01;\n        b <= 8'h01;\n        c <= 8'h00;\n        cnt <= 4'h0;\n    end else begin\n        c <= a + b;\n        a <= b;\n        b <= c;\n        if (cnt == 4'hB) begin\n            out <= c;\n            cnt <= 4'h0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a processor. The module should take in two 8-bit inputs, A and B, and output a 9-bit result, C. The output should be the sum of A and B, with an additional carry bit if the sum exceeds 255 (the maximum value for an 8-bit number).\n\nYour module should be named \"adder\" and should be written in Verilog. The module should include the following ports:\n\n- A (input, 8 bits)\n- B (input, 8 bits)\n- C (output, 9 bits)\n\nYour module should be able to handle all possible combinations of A and B inputs, and should output the correct sum and carry bit for each case.\n\nWrite a Verilog module named \"adder\" that takes in two 8-bit inputs, A and B, and outputs a 9-bit result, C, as described above.\n\n", "output": "module adder(\n    input [7:0] A,\n    input [7:0] B,\n    output reg [8:0] C\n);\n\nalways @(*) begin\n    C = A + B;\n    if (C > 255) begin\n        C = C + 1;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Here is a Karnaugh map for a 4-variable input function F(A,B,C,D).\n\nCD\\ AB | 00 | 01 | 11 | 10 |\n-------|----|----|----|----|\n  00   |  0 |  1 |  1 |  0 |\n  01   |  1 |  0 |  0 |  1 |\n  11   |  1 |  0 |  0 |  1 |\n  10   |  0 |  1 |  1 |  0 |\n\nImplement this combinational function using a Verilog module. The module should have four inputs A, B, C, and D, and one output F. You can use any gates or operators available in Verilog to implement the function. Your module should be named \"karnaugh_map\" and should include the following I/O definition:", "output": "module karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @(*) begin\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b1;\n      4'b0011: F = 1'b0;\n      4'b0100: F = 1'b1;\n      4'b0101: F = 1'b0;\n      4'b0110: F = 1'b0;\n      4'b0111: F = 1'b1;\n      4'b1000: F = 1'b0;\n      4'b1001: F = 1'b1;\n      4'b1010: F = 1'b1;\n      4'b1011: F = 1'b0;\n      4'b1100: F = 1'b0;\n      4'b1101: F = 1'b1;\n      4'b1110: F = 1'b1;\n      4'b1111: F = 1'b0;\n    endcase\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit synchronous up/down counter with parallel load. The module should have four inputs (clk, rst_n, up_down, and load_data[3:0]) and one output (count[3:0]). The module should increment or decrement the count based on the up_down input and should load the count with the load_data input when the load signal is high. The count should be synchronous to the clock signal.", "output": "module up_down_counter (\n    input clk,\n    input rst_n,\n    input up_down,\n    input [3:0] load_data,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            count <= 4'b0000;\n        end\n        else begin\n            if (up_down) begin\n                count <= count + 1;\n            end\n            else begin\n                count <= count - 1;\n            end\n            \n            if (load_data != 4'b0000) begin\n                count <= load_data;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that performs a certain operation on three input values A, B, and C. The module takes in a 9-bit input value Op and three 5-bit input values A, B, and C. The module outputs a 5-bit value O.\n\nThe operation is performed as follows:\n- The 9th bit of Op determines whether the output value should be equal to A or the result of the operation.\n- The 8th to 5th bits of Op are used to multiply A, B, and C by a certain factor.\n- The 4th and 3rd bits of Op are used to multiply B by a certain factor.\n- The 2nd and 1st bits of Op are used to multiply C by a certain factor.\n- The output value is the sum of the three multiplied values, unless the 9th bit of Op is set to 1, in which case it is equal to A.\n\nDesign a verilog module that performs this operation and outputs the result.\n\n", "output": "module InnerBlend(input [8:0] Op, input [4:0] A, input [4:0] B, input [4:0] C, output [4:0] O);\n  wire OpOnes = Op[4];\n  wire [7:0] Amul = A * Op[7:5];\n  wire [6:0] Bmul = B * Op[3:2];\n  wire [6:0] Cmul = C * Op[1:0];\n  wire [7:0] At =  Amul;\n  wire [7:0] Bt = (OpOnes == 0) ? {Bmul, 1'b0} : {3'b0, B};\n  wire [7:0] Ct = (OpOnes == 0) ? {Cmul, 1'b0} : {3'b0, C};\n  wire [8:0] Res = {At, 1'b0} + Bt + Ct;\n  assign O = Op[8] ? A : Res[8:4];\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock divider module that takes an input clock signal and outputs a new clock signal that is a fraction of the original clock frequency. The module should have two inputs: `clk` and `reset`, and one output: `newClk`. The `clk` input is a square wave with a frequency of 100 MHz. The `reset` input is an active-high signal that resets the module when asserted. The `newClk` output should be a square wave with a frequency of 10 MHz.\n\nDesign a Verilog module that implements this clock divider and test it using a testbench. The testbench should assert the `reset` signal for 20,000 clock cycles and then deassert it. After the reset signal is deasserted, the testbench should wait for 100,000 clock cycles and then check that the `newClk` output has a frequency of 10 MHz.\n\nYour Verilog module should be no longer than 200 lines of code.\n\n", "output": "module clockDivider(\n    input clk,\n    input reset,\n    output reg newClk\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        counter <= 0;\n        newClk <= 0;\n    end else begin\n        counter <= counter + 1;\n        if (counter == 9) begin\n            counter <= 0;\n            newClk <= ~newClk;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a clock gate circuit. The module should have four inputs and one output. The inputs are CLK, EN, TE, and a 63-bit register ADD_W63_0_8. The output is ENCLK. \n\nThe module should behave as follows:\n- When EN is low, the output ENCLK should be low, regardless of the value of CLK.\n- When EN is high and TE is low, the output ENCLK should be high when CLK is high and low when CLK is low.\n- When EN is high and TE is high, the output ENCLK should be low, regardless of the value of CLK.\n\nYou can assume that the inputs are already synchronized with the same clock and that the register ADD_W63_0_8 has already been initialized.\n\nYour task is to implement the verilog module that meets the above requirements. The module should be named SNPS_CLOCK_GATE_HIGH_RegisterAdd_W63_0_8.\n\n", "output": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W63_0_8 ( CLK, EN, ENCLK, TE, ADD_W63_0_8 );\n  input CLK, EN, TE;\n  input [62:0] ADD_W63_0_8;\n  output ENCLK;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .D(ADD_W63_0_8[0]), .ECK(ENCLK) );\n\n  always @ (posedge CLK) begin\n    if (EN == 1'b0) begin\n      ENCLK <= 1'b0;\n    end else if (TE == 1'b0) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to create a verilog module for a 1-bit register with asynchronous reset and set. The module should have four inputs: D (data input), S (set input), R (reset input), and CLK (clock input), and two outputs: Q (output) and QN (inverted output). \n\nThe module should implement the following behavior:\n- When the reset input R is asserted, the output Q should be set to 0 and QN should be set to 1.\n- When the set input S is asserted, the output Q should be set to 1 and QN should be set to 0.\n- The output Q should follow the input D when neither S nor R are asserted.\n- The output QN should be the inverse of Q.\n\nUse the given code snippet as a reference to write your verilog module.\n\n", "output": "module asynch_reset_set_reg (\n  input D,\n  input S,\n  input R,\n  input CLK,\n  output Q,\n  output QN\n);\n\nreg Q;\n\nalways @(posedge CLK or negedge R or negedge S) begin\n  if (!R) begin\n    Q <= 1'b0;\n  end else if (!S) begin\n    Q <= 1'b1;\n  end else begin\n    Q <= D;\n  end\nend\n\nassign QN = ~Q;\n\nendmodule"}
{"instruction": "\n\nYou have been given a Verilog code snippet for a module named `sky130_fd_sc_ls__dlrtn_1`. The module has 8 input and output ports, namely `Q`, `RESET_B`, `D`, `GATE_N`, `VPWR`, `VGND`, `VPB`, and `VNB`. Your task is to implement the module that will use these ports to perform a specific function.\n\nThe module `sky130_fd_sc_ls__dlrtn_1` has the following functionality:\n\n- `Q` is an output port that represents the output of the module.\n- `RESET_B` is an input port that is used to reset the module.\n- `D` is an input port that represents the data input to the module.\n- `GATE_N` is an input port that is used to enable or disable the module.\n- `VPWR`, `VGND`, `VPB`, and `VNB` are input ports that represent the power and ground connections.\n\nYour task is to implement the `sky130_fd_sc_ls__dlrtn_1` module that will use these ports to perform the following function:\n\n- When `RESET_B` is high, the output `Q` should be low.\n- When `RESET_B` is low and `GATE_N` is high, the output `Q` should be equal to the input `D`.\n- When `RESET_B` is low and `GATE_N` is low, the output `Q` should be high.\n\nYou are required to implement the module in Verilog within 200 lines of code.\n\n", "output": "module sky130_fd_sc_ls__dlrtn_1 (\n    Q      ,\n    RESET_B,\n    D      ,\n    GATE_N ,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    reg Q_int;\n\n    always @(*) begin\n        if(RESET_B == 1'b1) begin\n            Q_int = 1'b0;\n        end\n        else if(GATE_N == 1'b1) begin\n            Q_int = D;\n        end\n        else begin\n            Q_int = 1'b1;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a basic encryption algorithm on an input data stream. The module should include a shift register that stores the last 8 bits of data input, and a 16-bit key that is XORed with the input data. The output of the module should be the result of the XOR operation.\n\nThe module should have the following inputs and outputs:\n- `input wire clk`: the clock signal\n- `input wire rst`: the reset signal\n- `input wire [7:0] data_in`: the input data stream\n- `input wire [15:0] key`: the encryption key\n- `output wire [7:0] data_out`: the encrypted output data stream\n\nThe module should have the following behavior:\n- On the rising edge of the clock signal, if the reset signal is high, the shift register should be cleared and the output data should be set to 0.\n- Otherwise, the input data should be XORed with the key, and the result should be stored in the shift register. The output data should be the value of the shift register.\n\n", "output": "module encryption_module (\n    input wire clk,\n    input wire rst,\n    input wire [7:0] data_in,\n    input wire [15:0] key,\n    output wire [7:0] data_out\n);\n\n    reg [7:0] shift_register = 8'h00;\n    wire [7:0] xor_result;\n    \n    assign xor_result = data_in ^ key[7:0];\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            shift_register <= 8'h00;\n            data_out <= 8'h00;\n        end\n        else begin\n            shift_register <= {shift_register[6:0], xor_result};\n            data_out <= shift_register;\n        end\n    end\n    \nendmodule"}
{"instruction": "\nYou have been tasked to design a verilog module that takes in a 4-bit input signal and outputs a 2-bit signal based on the following conditions:\n- If the input signal is less than 4, the output signal should be '00'\n- If the input signal is between 4 and 7 (inclusive), the output signal should be '01'\n- If the input signal is between 8 and 11 (inclusive), the output signal should be '10'\n- If the input signal is greater than 11, the output signal should be '11'\n\nYour module should be named `signal_converter` and should have the following ports:\n- `input_signal` : a 4-bit input signal\n- `output_signal` : a 2-bit output signal\n\nYou may assume that the input signal is always a positive integer.\n\n", "output": "module signal_converter(\n    input [3:0] input_signal,\n    output reg [1:0] output_signal\n);\n\nalways @(*) begin\n    if (input_signal < 4) begin\n        output_signal = 2'b00;\n    end else if (input_signal < 8) begin\n        output_signal = 2'b01;\n    end else if (input_signal < 12) begin\n        output_signal = 2'b10;\n    end else begin\n        output_signal = 2'b11;\n    end\nend\n\nendmodule"}
{"instruction": "Create a priority encoder for 8-bit inputs. The module should take an 8-bit binary number as input and produce a 3-bit binary number as output. The output should indicate the position of the first bit that is high in the input binary number. If there are no high bits in the input number, the output should be zero. The module must be designed using a combinational logic approach.", "output": "module priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos );\n\n    always @(*) begin\n        case(in)\n            8'b00000001: pos = 0;\n            8'b00000010: pos = 1;\n            8'b00000100: pos = 2;\n            8'b00001000: pos = 3;\n            8'b00010000: pos = 4;\n            8'b00100000: pos = 5;\n            8'b01000000: pos = 6;\n            8'b10000000: pos = 7;\n            default: pos = 0;\n        endcase\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements clock buffer drivers. \nA clock buffer driver is a type of digital circuit that receives a clock signal and produces a buffered version of that signal. \nThis module should have the following inputs and outputs:\n\nInputs: \n- clk_in: the input clock signal\n- en: an enable signal that is used to enable or disable the clock buffer driver\n\nOutputs: \n- clk_out: the buffered output clock signal\n\nYour module should implement the following functionality:\n- When the enable signal is high (en=1), the buffered output signal (clk_out) should be identical to the input clock signal (clk_in).\n- When the enable signal is low (en=0), the buffered output signal (clk_out) should be held low.\n\nTo implement the module, you should use Verilog code to define a D flip-flop that receives the input clock signal and the enable signal. \nThe state of the D flip-flop should be determined by the enable signal: when the enable signal is high, the output of the D flip-flop should be the input clock signal; when the enable signal is low, the output of the D flip-flop should be held low. \nFinally, you should use an output buffer to amplify the output signal.", "output": "module clk_buffer_driver (\n  input clk_in, \n  input en,\n  output clk_out\n);\n\n  reg d_ff;\n  assign clk_out = d_ff;\n\n  always @(posedge clk_in or negedge en) begin\n    if (~en) begin\n      d_ff <= 1'b0;\n    end else begin\n      d_ff <= clk_in;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module to implement a 4-to-1 multiplexer. The module should have the following inputs and outputs:\n\nInputs:\n- `a`, `b`, `c`, and `d`: Four single-bit data inputs to be multiplexed\n- `sel`: A single-bit selection input that determines which data input is selected and outputted\n\nOutputs:\n- `out`: The selected data input based on the value of `sel`\n\nWrite the verilog code for the 4-to-1 multiplexer module. \n\n", "output": "module mux4to1 (\n  input wire a,\n  input wire b,\n  input wire c,\n  input wire d,\n  input wire sel,\n  output reg out\n);\n\nalways @ (sel, a, b, c, d) begin\n  case (sel)\n    2'b00: out = a;\n    2'b01: out = b;\n    2'b10: out = c;\n    2'b11: out = d;\n  endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit input signal `IN` and outputs a 8-bit signal `OUT`. The output signal `OUT` should be the result of concatenating the input signal `IN` with itself. For example, if `IN` is `0101`, then `OUT` should be `01010101`.\n\nDesign a verilog module that satisfies the above requirements. The module should be named `Concatenate` and have the following ports:\n\n- `input [3:0] IN`: a 4-bit input signal\n- `output [7:0] OUT`: an 8-bit output signal\n\n", "output": "module Concatenate(IN, OUT);\n\n   input [3:0] IN;\n   output [7:0] OUT;\n\n   assign OUT = {IN, IN};\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-input multiplexer. The module should have four input ports, A, B, C, and D, and one output port, Y. Additionally, the module should have a select input port, S, which determines which input port is selected and passed to the output port Y. The select input S is a two-bit input, with S[1] being the most significant bit and S[0] being the least significant bit. The truth table for the 4-input multiplexer is as follows:\n```\nS[1] | S[0] | Y\n-----|------|---\n  0  |  0   | A\n  0  |  1   | B\n  1  |  0   | C\n  1  |  1   | D\n```\nImplement the 4-input multiplexer module using verilog.\n\n", "output": "module mux4(input [3:0] A, B, C, D, input [1:0] S, output reg Y);\n\nalways @(*) begin\n    case(S)\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a pipelined module that performs 2-to-4 priority encoding. The module should take in two inputs and output a 2-bit value indicating the highest input that is high (00 for both inputs low, 01 for input 1 high, 10 for input 2 high, 11 for both inputs high). Use pipeline structure to achieve this functionality.", "output": "module priority_encoder (\n    input [1:0] in,\n    output reg [1:0] out\n);\n\nreg [1:0] stage1_out;\nreg [1:0] stage2_out;\n\nalways @(*) begin\n    stage1_out[0] = in[0] | in[1];\n    stage1_out[1] = in[0] & in[1];\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @(*) begin\n    if (stage2_out[1] == 1'b1) begin\n        out <= 2'b10;\n    end else if (stage2_out[0] == 1'b1) begin\n        out <= 2'b01;\n    end else begin\n        out <= 2'b00;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit parity generator. The module should take four inputs, in1, in2, in3, and in4, and produce a single output, parity. The output should be 1 if the number of inputs that are 1 is odd, and 0 if the number of inputs that are 1 is even.", "output": "module parity_generator (\n  input in1,\n  input in2,\n  input in3,\n  input in4,\n  output reg parity\n);\n\n  always @ (in1, in2, in3, in4) begin\n    if ((in1 + in2 + in3 + in4) % 2 == 0)\n      parity <= 0;\n    else\n      parity <= 1;\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Implement a 3-input XOR gate using Verilog HDL. The XOR gate should output 1 if and only if an odd number of inputs are 1. You should use only basic gates (AND, OR, NOT) in your design.", "output": "module xor_gate (\n  input a,\n  input b,\n  input c,\n  output reg out\n);\n\n  always @ (a or b or c)\n  begin\n    if ((a & b & ~c) || (a & ~b & c) || (~a & b & c))\n      out = 1;\n    else\n      out = 0;\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a D-latch with reset functionality. The module should have the following inputs and outputs:\n\n- `D`: input data signal\n- `RESET_B`: asynchronous reset signal (active low)\n- `GATE_N`: gating signal (active low)\n- `VPWR`: power supply voltage\n- `VGND`: ground voltage\n- `VPB`: power supply voltage for the output buffer\n- `VNB`: ground voltage for the output buffer\n- `Q`: output data signal\n- `Q_N`: complement output data signal\n\nThe module should follow the following specifications:\n\n- When `RESET_B` is low, both `Q` and `Q_N` should be set to 0.\n- When `RESET_B` is high and `GATE_N` is low, the output should follow the input `D`.\n- When `RESET_B` is high and `GATE_N` is high, the output should remain unchanged.\n\nYour module should be implemented within 200 lines of Verilog code.\n\n", "output": "module d_latch (\n    input D,\n    input RESET_B,\n    input GATE_N,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output Q,\n    output Q_N\n);\n\n    wire Q_int, Q_N_int;\n    wire GATE;\n    assign GATE = ~GATE_N;\n    \n    sky130_fd_sc_lp__dlrbn base (\n        .Q(Q_int),\n        .Q_N(Q_N_int),\n        .RESET_B(RESET_B),\n        .D(D),\n        .GATE_N(GATE_N),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n    \n    assign Q = (GATE) ? Q_int : Q;\n    assign Q_N = (GATE) ? Q_N : Q_N_int;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in a 32-bit input and a 2-bit byte_num input, and outputs a 32-bit value with the byte_num-th byte set to 0x01. If byte_num is 0, the output should have the first byte set to 0x01, if byte_num is 1, the output should have the second byte set to 0x01, and so on. If byte_num is 3, the output should have the fourth byte set to 0x01. All other bytes in the output should be the same as the corresponding bytes in the input.\n\nYour module should be named \"byte_setter\" and should have the following interface:\n\n```\nmodule byte_setter (\n    input [31:0] in,\n    input [1:0] byte_num,\n    output [31:0] out\n);\n```\n\nAssume that the input will always be a valid 32-bit value, and that byte_num will always be a valid 2-bit value.\n\nYou should implement the module within 200 lines of Verilog code.\n\n", "output": "module byte_setter (\n    input [31:0] in,\n    input [1:0] byte_num,\n    output [31:0] out\n);\n\n    assign out = in;\n    \n    always @(*) begin\n        case (byte_num)\n            2'b00: out[7:0] = 8'h01;\n            2'b01: out[15:8] = 8'h01;\n            2'b10: out[23:16] = 8'h01;\n            2'b11: out[31:24] = 8'h01;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary adder with carry-in and carry-out. The module should have the following inputs and outputs:\n\nInputs:\n- `A`: a 4-bit binary number\n- `B`: a 4-bit binary number\n- `Cin`: a single bit representing the carry-in\n\nOutputs:\n- `Sum`: a 4-bit binary number representing the sum of `A` and `B`\n- `Cout`: a single bit representing the carry-out\n\nYou may use any standard verilog operators and modules, but you may not use any pre-built adder modules.\n\n", "output": "module binary_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [3:0] xor_out;\n  wire [3:0] and_out;\n  wire [3:0] or_out;\n\n  // Calculate the XOR of A and B\n  assign xor_out = A ^ B;\n\n  // Calculate the AND of A and B\n  assign and_out = A & B;\n\n  // Calculate the OR of the AND and the shifted XOR\n  assign or_out = {xor_out[3], or_out[2:0]} | and_out;\n\n  // Calculate the sum\n  assign Sum = xor_out ^ Cin;\n\n  // Calculate the carry-out\n  assign Cout = or_out[3];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit up-counter. The counter should increment on the positive edge of the clock signal and reset to zero when the reset signal is high. \n\nTo implement this module, you can use 4 D flip-flops and connect their Q outputs to the D inputs of the next flip-flop. The first D flip-flop should be connected to the input signal, and the output of the last D flip-flop should be the counter output.", "output": "module up_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  reg [3:0] next_count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      next_count <= 4'b0000;\n    end\n    else begin\n      next_count <= count + 1;\n    end\n  end\n\n  assign count = next_count;\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements Fletcher's checksum generator and checker. \nFletcher's checksum is a hash function used to detect errors in data transmission or storage. \nThe checksum is calculated by dividing the data into blocks and then adding the values of each block together. \nThe result is a 16-bit checksum that can be used to verify the integrity of the data.\n\nYour module should have the following inputs and outputs:\n\nInputs: a set of n 8-bit data blocks (data1, data2, ..., datan)\nOutputs: a 16-bit Fletcher's checksum (checksum)\n\nYour module should implement the following functionality:\n\nThe circuit should divide the data into blocks of size 8 bits.\nFor each block, the circuit should calculate two 8-bit checksum values (s1 and s2) using the Fletcher's algorithm.\nThe 16-bit checksum should be calculated by concatenating s1 and s2.\nThe circuit should output the 16-bit checksum.\n\nTo implement Fletcher's algorithm, you should use Verilog code to calculate s1 and s2 for each block of data. \nYou should then use these values to calculate the final 16-bit checksum. \nThe Verilog code should be designed in such a way that it can handle any number of data blocks.", "output": "module fletcher (\n  input [n*8-1:0] data,\n  output reg [15:0] checksum\n);\n\nparameter n = 4; // number of data blocks\n\nreg [7:0] s1 [0:n-1];\nreg [7:0] s2 [0:n-1];\n\ninteger i, j;\n\nalways @(*) begin\n  for (i = 0; i < n; i = i + 1) begin\n    s1[i] = 0;\n    s2[i] = 0;\n    for (j = i*8; j < (i+1)*8; j = j + 1) begin\n      s1[i] = s1[i] + data[j];\n      s2[i] = s2[i] + s1[i];\n    end\n  end\n  checksum = {s1[n-1], s2[n-1]};\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit binary number and outputs the corresponding BCD (binary-coded decimal) value. If the input is greater than 9, the output should be invalid.", "output": "module bcd_converter (\n    input [3:0] in,\n    output reg [3:0] out,\n    output invalid\n);\n\nalways @(*) begin\n    case (in)\n        4'b0000: out = 4'b0000;\n        4'b0001: out = 4'b0001;\n        4'b0010: out = 4'b0010;\n        4'b0011: out = 4'b0011;\n        4'b0100: out = 4'b0100;\n        4'b0101: out = 4'b0101;\n        4'b0110: out = 4'b0110;\n        4'b0111: out = 4'b0111;\n        4'b1000: out = 4'b1000;\n        4'b1001: out = 4'b1001;\n        default: begin\n            out = 4'bxxxx;\n            invalid = 1;\n        end\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module that will take in 4 input signals and output a single signal. The module should be named `my_module` and should have the following ports:\n\n- `input [3:0] data_in`: A 4-bit input signal\n- `output data_out`: A single output signal\n\nInside the module, you should declare the following signals:\n\n- `reg [3:0] data_reg`: A 4-bit register\n- `wire [3:0] data_wire`: A 4-bit wire\n\nThe module should have the following behavior:\n\n- On the rising edge of the clock signal, the value of `data_in` should be stored in `data_reg`\n- The value of `data_reg` should be assigned to `data_wire`\n- If the value of `data_wire` is less than or equal to 5, `data_out` should be set to 1. Otherwise, `data_out` should be set to 0.\n\n", "output": "module my_module(\n    input clk,\n    input [3:0] data_in,\n    output reg data_out\n);\n\n    reg [3:0] data_reg;\n    wire [3:0] data_wire;\n\n    always @(posedge clk) begin\n        data_reg <= data_in;\n    end\n\n    assign data_wire = data_reg;\n\n    always @(*) begin\n        if (data_wire <= 5) begin\n            data_out = 1;\n        end else begin\n            data_out = 0;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module called \"shifter\" that implements a fixed-width shifter. The module takes in three inputs: A (a 32-bit input), B (a 32-bit input), and ctrl (a 2-bit input). The module outputs a 32-bit value called \"dout\". The module is composed of five instances of a \"fix_shifter\" module, each with a different shift width. The shifter module is designed to shift the value of B by a variable amount, depending on the value of A and ctrl.\n\nYour task is to design the \"fix_shifter\" module that is used in the \"shifter\" module. The \"fix_shifter\" module should take in three inputs: A (a 2-bit input), B (a 32-bit input), and ctrl (a 2-bit input). The module should output a 32-bit value called \"dout\". The \"fix_shifter\" module should shift the value of B by a fixed amount, depending on the value of A and ctrl. The shift amount should be equal to 2^A if ctrl is 2'b00, 2^(A+1) if ctrl is 2'b01, 2^(A+2) if ctrl is 2'b10, and 2^(A+3) if ctrl is 2'b11.\n\nYou should implement the fix_shifter module using only combinational logic. You may not use any sequential logic, such as registers or flip-flops.\n\n", "output": "module fix_shifter(\n    output [31:0] dout,\n    input [31:0] B,\n    input [1:0] ctrl,\n    input [1:0] A\n);\n\nwire [31:0] shifted;\n\nassign shifted = (ctrl == 2'b00) ? (B << A) :\n                 (ctrl == 2'b01) ? (B << (A + 1)) :\n                 (ctrl == 2'b10) ? (B << (A + 2)) :\n                                   (B << (A + 3));\nassign dout = shifted;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a pipelined module that can perform the same functionality as a D flip-flop, but using a T flip-flop instead. The module must have a clock input, a data input, and a single output that represents the state of the T flip-flop. The T flip-flop should be implemented using pipeline structure.", "output": "module t_ff_pipeline (\n    input clk,\n    input d,\n    output reg q\n);\n\nreg t1, t2;\n\nalways @(posedge clk) begin\n    t1 <= d;\nend\n\nalways @(posedge clk) begin\n    t2 <= t1;\nend\n\nalways @(posedge clk) begin\n    q <= t2 ^ q;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a register adder. The module should have four inputs: clk (clock), rst (reset), load (load input), and D (data input). The module should also have one output: Q (output register).\n\nThe register adder should load the data input when the load input is high. The data should be added to the contents of the output register when the load input is low. The output register should be reset to 0 when the reset input is high.\n\nThe Verilog module should be self-contained and should not rely on any external modules. Additionally, the module should be no more than 200 lines of code.\n\nPlease write a Verilog module that meets these specifications.\n\n", "output": "module register_adder(\n    input clk, rst, load,\n    input [7:0] D,\n    output reg [7:0] Q\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        Q <= 8'b0;\n    end else if (load) begin\n        Q <= D;\n    end else begin\n        Q <= Q + D;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been hired by a company to design a new module for their system. The module should be able to take in a data signal and output a processed signal. The module should also have power inputs for various voltage levels. You must design a verilog module that meets these requirements.\n\nYour module should be named `data_processing_module` and should have the following inputs and outputs:\n\n**Inputs:**\n- `data_in` (1 bit)\n- `power_in` (4 bits)\n\n**Outputs:**\n- `data_out` (1 bit)\n\nThe `power_in` input is a 4-bit signal that represents the following power inputs:\n- `power_in[0]` represents `VPB`\n- `power_in[1]` represents `VPWR`\n- `power_in[2]` represents `VGND`\n- `power_in[3]` represents `VNB`\n\nYour module should perform the following operations on the `data_in` signal:\n- If `data_in` is 0, `data_out` should be 0.\n- If `data_in` is 1, `data_out` should be 1.\n\nHowever, the output should only be valid if the power inputs are correct. The power inputs should be valid if:\n- `VPB` is high (1)\n- `VPWR` is high (1)\n- `VGND` is low (0)\n- `VNB` is low (0)\n\nIf the power inputs are not valid, the output should be X (undefined).\n\nYour module should be contained within 200 lines of verilog code.\n\n", "output": "module data_processing_module (\n    input data_in,\n    input [3:0] power_in,\n    output reg data_out\n);\n\n    always @(*) begin\n        if (data_in == 1'b1) begin\n            if (power_in == 4'b1010) begin\n                data_out <= 1'b1;\n            end\n            else begin\n                data_out <= 1'bx;\n            end\n        end\n        else begin\n            if (power_in == 4'b1010) begin\n                data_out <= 1'b0;\n            end\n            else begin\n                data_out <= 1'bx;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes in two 8-bit unsigned inputs, `a` and `b`, and outputs their product, `p`. The output should be a 16-bit unsigned number. \n\nThe module should have the following inputs and outputs:\n- `a`: an 8-bit unsigned number\n- `b`: an 8-bit unsigned number\n- `p`: a 16-bit unsigned number\n\nYou may not use any built-in Verilog operators for multiplication or division. \n\n", "output": "module unsigned_multiplier(\n  input [7:0] a,\n  input [7:0] b,\n  output [15:0] p\n);\n\n  reg [7:0] a_reg;\n  reg [15:0] p_reg;\n\n  integer i, j;\n\n  always @(*) begin\n    a_reg = a;\n    p_reg = 0;\n\n    for (i = 0; i < 8; i = i + 1) begin\n      for (j = 0; j < 8; j = j + 1) begin\n        if ((i + j) < 16) begin\n          p_reg[i + j] = p_reg[i + j] + a_reg[i] * b[j];\n        end\n      end\n    end\n  end\n\n  assign p = p_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two inputs and produces one output. The module should be named \"multiplier\" and should have the following ports:\n\n- `input [7:0] a`: an 8-bit input\n- `input [7:0] b`: an 8-bit input\n- `output reg [15:0] result`: a 16-bit output\n\nThe module should multiply the two inputs `a` and `b` and store the result in `result`. You should use a sequential block to implement the multiplication.\n\n", "output": "module multiplier (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n\n    always @ (a, b) begin\n        result = a * b;\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit binary number and outputs the Gray code equivalent of the number. Gray code is a binary numeral system where two successive values differ in only one bit. To convert a binary number to Gray code, exclusive-or each bit with the bit to its right. The most significant bit is not exclusive-ored with anything. Use a combinational always block to implement the module.", "output": "module gray_code (\n    input [3:0] a,\n    output reg [3:0] gray\n);\n\nalways @(*) begin\n    gray[3] = a[3];\n    gray[2] = a[3] ^ a[2];\n    gray[1] = a[2] ^ a[1];\n    gray[0] = a[1] ^ a[0];\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a new module for an arithmetic logic unit (ALU) in Verilog. The ALU will take in two 13-bit inputs and a 5-bit operation code (OP) and output a 13-bit result based on the operation specified by the OP. The module you are designing should be able to handle the following operations:\n\n- Addition\n- Subtraction\n- Bitwise AND\n- Bitwise OR\n- Bitwise XOR\n- Shift left\n- Shift right\n\nYou should write a Verilog module to implement this ALU. Your module should have the following inputs and outputs:\n\n- Inputs:\n  - `a` (13-bit signed integer)\n  - `b` (13-bit signed integer)\n  - `op` (5-bit operation code)\n- Outputs:\n  - `result` (13-bit signed integer)\n\nYour module should implement the following operations based on the value of `op`:\n\n- `op` = 00000 (Addition): `result` should be the sum of `a` and `b`.\n- `op` = 00001 (Subtraction): `result` should be the difference between `a` and `b`.\n- `op` = 00010 (Bitwise AND): `result` should be the bitwise AND of `a` and `b`.\n- `op` = 00011 (Bitwise OR): `result` should be the bitwise OR of `a` and `b`.\n- `op` = 00100 (Bitwise XOR): `result` should be the bitwise XOR of `a` and `b`.\n- `op` = 00101 (Shift left): `result` should be `a` shifted left by the number of bits specified by the 3 least significant bits of `b`.\n- `op` = 00110 (Shift right): `result` should be `a` shifted right by the number of bits specified by the 3 least significant bits of `b`.\n\nYou should assume that all arithmetic operations should be signed, and that the shift operations should preserve the sign bit.\n\n", "output": "module alu (a, b, op, result);\n  input signed [12:0] a, b;\n  input [4:0] op;\n  output signed [12:0] result;\n  \n  always @(*) begin\n    case (op)\n      5'b00000: result = a + b;\n      5'b00001: result = a - b;\n      5'b00010: result = a & b;\n      5'b00011: result = a | b;\n      5'b00100: result = a ^ b;\n      5'b00101: result = (b[2:0] > 0) ? (a << b[2:0]) : a;\n      5'b00110: result = (b[2:0] > 0) ? (a >> b[2:0]) : a;\n      default: result = 0;\n    endcase\n  end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements bitwise logical operators (AND, OR, XOR, NOT) for two n-bit input signals.\nYour module should have the following inputs and outputs:\n\nInputs: two n-bit input signals (in1, in2)\nOutputs: four n-bit output signals (out_AND, out_OR, out_XOR, out_NOT)\n\nYour module should implement the following functionality:\n- The out_AND should output the bitwise AND operation result of the in1 and in2.\n- The out_OR should output the bitwise OR operation result of the in1 and in2.\n- The out_XOR should output the bitwise XOR operation result of the in1 and in2.\n- The out_NOT should output the bitwise NOT operation result of the in1.\n\nTo implement the bitwise logical operators, you should use Verilog code to define the logic of AND, OR, XOR, and NOT operations between the two input signals. \nYou should then use these operations to compute the output signals.\n\nTo finish this task, you can start by defining the inputs and outputs of the module, and then implementing the logic for each bitwise operation. \nFor example, to implement the AND operation, you can use the \"&\" operator in Verilog to compute the bitwise AND of the two input signals. \nSimilarly, you can use the \"|\" operator for OR, \"^\" operator for XOR, and \"~\" operator for NOT. \nAfter implementing the logic for all four operations, you can connect them to the output signals using continuous assignment statements.", "output": "module bitwise_ops (\n  input [n-1:0] in1,\n  input [n-1:0] in2,\n  output [n-1:0] out_AND,\n  output [n-1:0] out_OR,\n  output [n-1:0] out_XOR,\n  output [n-1:0] out_NOT\n);\n\nparameter n = 8; // number of input bits\n\nassign out_AND = in1 & in2;\nassign out_OR = in1 | in2;\nassign out_XOR = in1 ^ in2;\nassign out_NOT = ~in1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a D flip-flop with asynchronous reset. The module should have the following inputs and outputs:\n\n- `clk`: a clock input\n- `reset`: an asynchronous reset input\n- `d`: a data input\n- `q`: a data output\n- `qn`: the complement of the data output\n\nThe module should have the following behavior:\n\n- When `reset` is asserted, both `q` and `qn` should be set to 0.\n- On the rising edge of `clk`, the value of `d` should be latched into `q` and `qn` should be the complement of `q`.\n\nWrite the verilog code for this module and simulate it using a testbench.\n\n", "output": "module d_ff_async_reset (clk, reset, d, q, qn);\n    input clk, reset, d;\n    output q, qn;\n    reg q, qn;\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q <= 0;\n            qn <= 1;\n        end\n        else begin\n            q <= d;\n            qn <= ~d;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in three inputs `CLK`, `EN`, and `TE` and outputs a single value `ENCLK`. The module should be named `clock_gate_high` and should be written in Verilog within 200 lines of code.\n\nThe `CLK` input is a clock signal that is used to synchronize the module. The `EN` input is a control signal that enables the module. The `TE` input is a control signal that sets the output to a high value.\n\nThe output `ENCLK` should be high when both `EN` and `TE` are high and the `CLK` signal is high. Otherwise, `ENCLK` should be low.\n\nYou can assume that all inputs and outputs are single-bit signals.\n\nWrite a Verilog module `clock_gate_high` that meets the above requirements.\n\n", "output": "module clock_gate_high (\n  input CLK, EN, TE,\n  output ENCLK\n);\n\n  assign ENCLK = (EN & TE & CLK);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a counter, a bus, and a multiplexer. The module should be named `counter_bus_mux` and should have the following input and output ports:\n\n- `data0x`: a 4-bit input used to load the initial value of the counter.\n- `data1x`: a 4-bit input used to increment the counter.\n- `sel`: a single-bit input used to select between the two inputs.\n- `result`: a 4-bit output representing the current value of the counter.\n\nThe `counter_bus_mux` module should implement the following behavior:\n\n- When `sel` is 0, the module should load the value of `data0x` into the counter.\n- When `sel` is 1, the module should increment the counter by the value of `data1x`.\n- The output `result` should always represent the current value of the counter.\n\nYou must implement this module in Verilog, and your implementation must be contained within a single module that is no longer than 200 lines of code.\n\n", "output": "module counter_bus_mux (\n\tdata0x,\n\tdata1x,\n\tsel,\n\tresult);\n\n\tinput\t[3:0]  data0x;\n\tinput\t[3:0]  data1x;\n\tinput\t  sel;\n\toutput\t[3:0]  result;\n\n\treg [3:0] counter;\n\n\talways @(*) begin\n\t\tif (sel == 1'b0) begin\n\t\t\tcounter <= data0x;\n\t\tend else begin\n\t\t\tcounter <= counter + data1x;\n\t\tend\n\tend\n\n\tassign result = counter;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a dual-port RAM module in Verilog that has a capacity of 32x256. The module should have two ports, one for writing and one for reading, and should be able to perform read and write operations simultaneously. The module should have the following inputs and outputs:\n\nInputs:\n- `data`: 32-bit input data for write operation.\n- `rdaddress`: 8-bit read address.\n- `rdclock`: read clock input.\n- `rden`: read enable input.\n- `wraddress`: 8-bit write address.\n- `wrclock`: write clock input.\n- `wren`: write enable input.\n\nOutputs:\n- `q`: 32-bit output data for read operation.\n\nYou should use the provided code snippet as a reference and create a module that meets the above requirements. Your module should be self-contained and should not exceed 200 lines of Verilog code.\n\n", "output": "module dual_port_ram (\n  input [31:0] data,\n  input [7:0] rdaddress,\n  input rdclock,\n  input rden,\n  input [7:0] wraddress,\n  input wrclock,\n  input wren,\n  output reg [31:0] q\n);\n\n  reg [31:0] mem [0:255];\n\n  always @(posedge wrclock) begin\n    if (wren) begin\n      mem[wraddress] <= data;\n    end\n  end\n\n  always @(posedge rdclock) begin\n    if (rden) begin\n      q <= mem[rdaddress];\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a memory module that can store 16-bit data words, with a capacity of 8192 words. The memory module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `wr_en`: a write enable signal\n- `rd_en`: a read enable signal\n- `addr`: a 13-bit address signal\n- `data_in`: a 16-bit data input signal\n\nOutputs:\n- `data_out`: a 16-bit data output signal\n\nYour memory module should be implemented using a single block RAM module. The module should be synchronous with the rising edge of the clock signal. On the rising edge of the clock, if `wr_en` is high, the data at `data_in` should be written to the memory location specified by the `addr` signal. On the rising edge of the clock, if `rd_en` is high, the data at the memory location specified by the `addr` signal should be output on `data_out`.\n\n", "output": "module memory_module(\n    input clk,\n    input wr_en,\n    input rd_en,\n    input [12:0] addr,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\n    reg [15:0] memory [0:8191];\n    wire [15:0] data_out;\n\n    always @(posedge clk) begin\n        if (wr_en) begin\n            memory[addr] <= data_in;\n        end\n        if (rd_en) begin\n            data_out <= memory[addr];\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit barrel shifter with a rotate left operation. The module should have two inputs (data and shift) and one output (out). The barrel shifter should shift the data input left or right by the amount specified by the shift input. If the shift input is greater than 3, the module should perform a rotate left operation, where the bits that are shifted out of the left side of the register are shifted back in on the right side. The output should be the value of the register after the final shift or rotate operation.", "output": "module barrel_shifter (\n    input [3:0] data,\n    input [2:0] shift,\n    output [3:0] out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(*) begin\n        if (shift > 3) begin\n            shift_reg[0] = data[3];\n            shift_reg[1] = data[0];\n            shift_reg[2] = data[1];\n            shift_reg[3] = data[2];\n        end else begin\n            shift_reg = data << shift;\n        end\n    end\n\n    assign out = shift_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-bit counter with a synchronous reset. The counter should count up to a maximum value of 6 and then reset to zero. The counter should have an enable input that allows it to count only when enabled.", "output": "module counter_3bit (\n  input clk,\n  input reset,\n  input enable,\n  output reg[2:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 3'b0;\n    end else if (enable) begin\n      if (count == 3'b110) begin\n        count <= 3'b0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Develop a 4-to-1 multiplexer with a 2-bit selector that selects one of the four 8-bit inputs and outputs the selected 8-bit data.", "output": "module mux_4to1_8bit (\n  input [7:0] in0,\n  input [7:0] in1,\n  input [7:0] in2,\n  input [7:0] in3,\n  input [1:0] sel,\n  output reg [7:0] out\n);\n\nalways @*\nbegin\n  case(sel)\n    2'b00: out = in0;\n    2'b01: out = in1;\n    2'b10: out = in2;\n    2'b11: out = in3;\n  endcase\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a D flip-flop with synchronous reset and set inputs, and active-low outputs. The module should be named \"dff_res_set\" and should have the following inputs and outputs:\n- input wire clk: the clock signal\n- input wire rst: the synchronous reset signal (active-high)\n- input wire set: the synchronous set signal (active-high)\n- input wire d: the data input\n- output reg q: the output signal\n- output reg qn: the complement of the output signal\n\nThe module should implement the following behavior:\n- On the rising edge of the clock signal, if the reset signal is high, the output should be set to 0 and the complement output to 1.\n- On the rising edge of the clock signal, if the set signal is high, the output should be set to 1 and the complement output to 0.\n- On the rising edge of the clock signal, if neither the reset nor the set signal is high, the output should be set to the value of the data input and the complement output to the complement of the data input.\n\nYou may use any verilog constructs you wish, except for behavioral constructs (such as \"always\" blocks) and UDPs.\n\n", "output": "module dff_res_set(\n    input wire clk,\n    input wire rst,\n    input wire set,\n    input wire d,\n    output reg q,\n    output reg qn\n);\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        q <= 0;\n        qn <= 1;\n    end else if (set) begin\n        q <= 1;\n        qn <= 0;\n    end else begin\n        q <= d;\n        qn <= ~d;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module in Verilog that takes in three input signals and outputs a single signal. The module should be named \"tkg_c3\" and it should have the following ports:\n- output port \"o\" which should be a single bit signal\n- input port \"i0\" which should be a single bit signal\n- input port \"i1\" which should be a single bit signal\n- input port \"i2\" which should be a single bit signal\n\nThe module should use a sub-module called \"C3\" to compute the output signal. The C3 sub-module should take in three input signals and output a single signal. The C3 sub-module should implement the following Boolean equation:\no = i0 & i1 | i0 & i2 | i1 & i2\n\nYou should write the Verilog code for the tkg_c3 module. Your code should be contained within a single module and should be no more than 200 lines of code.\n\n", "output": "module tkg_c3 (output o, input i0, i1, i2);\n\tC3 I0 (o, i0, i1, i2);\nendmodule\n\nmodule C3 (output o, input i0, i1, i2);\n\twire a, b, c, d, e;\n\t\n\tand (a, i0, i1);\n\tand (b, i0, i2);\n\tand (c, i1, i2);\n\tor (d, a, b);\n\tor (e, d, c);\n\t\n\tassign o = e;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a current source and sink. \nA current source is a circuit element that produces a constant current regardless of the voltage across it, while a current sink is an element that draws a constant current regardless of the voltage across it. \nThe inputs to the circuit are the voltage across the circuit element and the output is the current through the circuit element.\nYour module should have the following inputs and outputs:\n\nInputs: \n- V: the voltage across the circuit element\n- Iset: the set current value of the source/sink\n- enable: a control signal to enable/disable the source/sink\n\nOutputs: \n- I: the current through the circuit element\n\nYour module should implement the following functionality:\n- When enable is high, the module should act as a current source or sink, depending on the value of Iset. If Iset is positive, the module should act as a current source with a constant current of Iset. If Iset is negative, the module should act as a current sink with a constant current of -Iset.\n- When enable is low, the module should act as an open circuit, with zero current flowing through it.\n\nTo implement the current source/sink, you should use Verilog code to calculate the current through the circuit element based on the voltage across it and the set current value. \nYou should then use this calculation to generate the output current. \nYou should also use the enable signal to control whether the circuit element acts as a current source/sink or an open circuit.", "output": "module current_source_sink (\n  input V,\n  input signed [31:0] Iset,\n  input enable,\n  output reg signed [31:0] I\n);\n\n  always @(*) begin\n    if (enable) begin\n      if (Iset > 0) begin\n        I <= Iset;\n      end else begin\n        I <= -Iset;\n      end\n    end else begin\n      I <= 0;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements inverse trigonometric functions, specifically arcsine, arccosine, and arctangent. \nThe module should have the following inputs and outputs:\n\nInputs: a single input signal (x)\nOutputs: three output signals (arcsin_x, arccos_x, arctan_x)\n\nTo implement the inverse trigonometric functions, you should use Verilog code to calculate the corresponding angles in radians. \nYou can use the following formulas:\n\narcsin_x = asin(x)\narccos_x = acos(x)\narctan_x = atan(x)\n\nTo implement these functions, you can use the built-in Verilog functions for sine, cosine, and tangent (sin, cos, and tan). \nYou should then use these functions to calculate the corresponding inverse trigonometric functions. \nNote that the output signals should be in radians.", "output": "module inv_trig (\n  input x,\n  output arcsin_x,\n  output arccos_x,\n  output arctan_x\n);\n\n  parameter PI = 3.141592653589793;\n\n  // Calculate arcsine\n  assign arcsin_x = asin(x);\n\n  // Calculate arccosine\n  assign arccos_x = acos(x);\n\n  // Calculate arctangent\n  assign arctan_x = atan(x);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes in a 32-bit input and outputs a 64-bit output. The module should perform the following operations on the input:\n- Shift the input left by 4 bits\n- Add 0x12345678 to the shifted input\n- XOR the result with a 64-bit key\n\nThe key is a constant value and should be defined within the module. Your module should be named \"shift_add_xor\" and should have the following interface:\n- input [31:0] in\n- output [63:0] out\n\nYour module should be self-contained and should not rely on any external modules. The module should be implemented within 200 lines of Verilog code.\n\n", "output": "module shift_add_xor(\n\tinput [31:0] in,\n\toutput [63:0] out\n);\n\n\tparameter KEY = 64'h0123456789ABCDEF;\n\n\treg [63:0] shifted_input;\n\treg [63:0] result;\n\n\talways @(*) begin\n\t\tshifted_input = {in, 4'b0000};\n\t\tresult = shifted_input + 64'h12345678;\n\t\tresult = result ^ KEY;\n\tend\n\n\tassign out = result;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that can perform binary addition on two 8-bit numbers. The module should have two 8-bit inputs, A and B, and one 9-bit output, C. The output should be the sum of A and B, with the least significant bit in position 0 and the most significant bit in position 8.\n\nThe module should have a single clock input, clk, and a single reset input, rst. When rst is asserted, the module should reset to 0. When rst is deasserted, the module should begin adding A and B on the rising edge of clk.\n\nIf the sum of A and B is greater than 255, the module should set the carry bit, C[8], to 1. Otherwise, C[8] should be set to 0.\n\nYour task is to design the verilog code for this module. Your module should be named \"adder\" and should be contained within 200 lines of verilog code.\n\n", "output": "module adder (\n  input clk, rst,\n  input [7:0] A, B,\n  output reg [8:0] C\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      C <= 0;\n    end else begin\n      C <= A + B;\n      if (C > 255) begin\n        C <= C - 256;\n        C[8] <= 1;\n      end else begin\n        C[8] <= 0;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 8-bit inputs, `A` and `B`, and outputs the result of their bitwise XOR operation. You should also include a 1-bit input `EN` that acts as an enable signal. When `EN` is high, the module should perform the XOR operation and output the result. When `EN` is low, the output should remain constant at 0.\n\nIn addition, you should ensure that the design is fully synthesizeable and meets the following requirements:\n- The module should be named `xor_8bit_en`.\n- The inputs and output should be named `A`, `B`, `EN`, and `OUT`, respectively.\n- The module should use only combinational logic (no sequential logic).\n- The design should meet timing requirements for a clock frequency of 50MHz.\n- The design should have a low area footprint.\n\n", "output": "module xor_8bit_en (\n    OUT,\n    A,\n    B,\n    EN\n);\n\n    output reg [7:0] OUT;\n    input [7:0] A;\n    input [7:0] B;\n    input EN;\n\n    always @(*) begin\n        if (EN) begin\n            OUT = A ^ B;\n        end\n        else begin\n            OUT = 8'b0;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two inputs, A1 and A2, and one input B1. The module should output a single bit, Y. You are also provided with voltage supply signals, VPWR, VGND, VPB, and VNB, which you should use in your design.\n\nThe module should implement the following logic:\n- If A1 is high, Y should be high.\n- If A1 is low and A2 is high, Y should be high.\n- If A1 and A2 are both low and B1 is high, Y should be high.\n- In all other cases, Y should be low.\n\nWrite the verilog code for the module using the provided inputs and logic.\n\n", "output": "module my_module (\n    input A1,\n    input A2,\n    input B1,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = (A1 || (A2 && !A1) || (!A1 && !A2 && B1)) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an absolute value calculator. \nAn absolute value calculator is a type of digital circuit that takes an input number and returns its absolute value. \nThe input can be a signed or unsigned number, and the output should always be a positive number.\n\nYour module should have the following inputs and outputs:\n\nInputs: a signed or unsigned input number (in)\nOutputs: an unsigned output number (out)\n\nYour module should implement the following functionality:\nIf the input number is positive, the output should be equal to the input.\nIf the input number is negative, the output should be equal to the absolute value of the input (i.e., the negative sign should be removed).\n\nTo implement the absolute value calculator, you should use Verilog code to check the sign of the input number. \nIf the input number is positive, you should simply pass it through to the output. \nIf the input number is negative, you should use Verilog code to remove the negative sign and pass the absolute value to the output.\n\nYou can use the Verilog built-in function $signed() to convert the input into a signed number, and the Verilog built-in function $unsigned() to convert the output into an unsigned number.", "output": "module abs_value (\n  input signed [31:0] in,\n  output reg [31:0] out\n);\n\n  always @(*) begin\n    if (in < 0) begin\n      out = -in;\n    end\n    else begin\n      out = in;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a priority encoder. A priority encoder is a combinational circuit that encodes the highest-priority active input into an n-bit binary code. In this module, there are 8 inputs and 3 outputs. The inputs are \"in0\" to \"in7\", and the outputs are \"out0\", \"out1\", and \"out2\". The output \"out0\" is the least significant bit of the binary code, and \"out2\" is the most significant bit. If more than one input is active, the input with the highest priority will be encoded. The priority order is \"in7\" > \"in6\" > \"in5\" > \"in4\" > \"in3\" > \"in2\" > \"in1\" > \"in0\". If no input is active, \"out0\", \"out1\", and \"out2\" will be set to 0. Implement this module using a case statement.", "output": "module priority_encoder (\n  input [7:0] in,\n  output reg [2:0] out\n);\n\n  always @* begin\n    case(in)\n      8'b10000000: out = 3'b000;\n      8'b01000000: out = 3'b001;\n      8'b00100000: out = 3'b010;\n      8'b00010000: out = 3'b011;\n      8'b00001000: out = 3'b100;\n      8'b00000100: out = 3'b101;\n      8'b00000010: out = 3'b110;\n      8'b00000001: out = 3'b111;\n      default: out = 3'b000;\n    endcase\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with creating a Verilog module that implements a 4-bit shift register with a parallel load capability. The module should have three inputs and one output:\n\n- `load`: a single bit input that controls whether the input data should be loaded into the shift register or not.\n- `shift`: a single bit input that controls whether the shift register should shift its contents or not.\n- `data_in`: a 4-bit input that contains the data to be loaded into the shift register.\n- `data_out`: a 4-bit output that contains the current contents of the shift register.\n\nIf `load` is high, the contents of `data_in` should be loaded into the shift register. If `shift` is high, the contents of the shift register should be shifted to the left (i.e., the contents of each bit should be moved one position to the left, with the leftmost bit being shifted out and lost). If both `load` and `shift` are high, the contents of `data_in` should be loaded into the shift register and then shifted to the left.\n\n", "output": "module shift_register(load, shift, data_in, data_out);\n    input load, shift;\n    input [3:0] data_in;\n    output [3:0] data_out;\n\n    reg [3:0] shift_reg;\n\n    always @(*) begin\n        if (load)\n            shift_reg <= data_in;\n        else if (shift)\n            shift_reg <= {shift_reg[2:0], 1'b0};\n    end\n\n    assign data_out = shift_reg;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a multiplexer module in Verilog. The module should have two 1-bit inputs, `D0` and `D1`, and one control input, `ctrl`. The output of the module, `S`, should be equal to `D0` when `ctrl` is 0, and equal to `D1` when `ctrl` is 1.\n\nYou must implement the module using only one module within 200 lines of Verilog code. Your module should include the following:\n\n- A module declaration with the appropriate inputs and outputs\n- Appropriate wire declarations to connect the inputs and outputs\n- A LUT3 instantiation to implement the multiplexer logic\n\nYou may assume that the LUT3 is already provided and instantiated in the code snippet below. The LUT3 has an 8-bit initialization value of `8'hB8`.\n\nYour task is to complete the module by filling in the appropriate Verilog code.\n\n```verilog\nmodule Multiplexer_AC__parameterized68\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  // TODO: Fill in appropriate wire declarations\n\n  LUT3 #(\n    .INIT(8'hB8)) \n    \\S[0]_INST_0 \n       (.I0(D1),\n        .I1(ctrl),\n        .I2(D0),\n        .O(S));\nendmodule\n```\n\n", "output": "module Multiplexer_AC__parameterized68\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  wire [0:0]D0_wire;\n  wire [0:0]D1_wire;\n  wire [0:0]S_wire;\n  wire ctrl_wire;\n\n  assign D0_wire = D0;\n  assign D1_wire = D1;\n  assign ctrl_wire = ctrl;\n\n  LUT3 #(\n    .INIT(8'hB8)) \n    \\S[0]_INST_0 \n       (.I0(D1_wire),\n        .I1(ctrl_wire),\n        .I2(D0_wire),\n        .O(S_wire));\n\n  assign S = S_wire;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that receives a 4-bit input and stores it in a 16-bit array. The array should be shifted left by one position on each clock cycle, with the new input bit being stored in the least significant bit of the array. The output of the module should be the entire 16-bit array.\n\nDesign a Verilog module named `shift_register` that takes the following inputs:\n- `clk`: a clock signal\n- `inp`: a 4-bit input signal\n\nThe module should have the following outputs:\n- `arr_out`: a 16-bit output signal representing the array after each shift\n\nYou should assume that `arr_out` is initialized to zero.\n\nYour module should be self-contained and should not require any external modules or functions. It should be no longer than 200 lines of Verilog code.\n\n", "output": "module shift_register (\n    input wire clk,\n    input wire [3:0] inp,\n    output wire [15:0] arr_out\n);\n\n    logic [15:0] arr;\n\n    always @(posedge clk) begin\n        arr[15:1] <= arr[14:0];\n        arr[0] <= inp[0];\n    end\n\n    always @(posedge clk) begin\n        arr[15:1] <= arr[14:0];\n        arr[0] <= inp[1];\n    end\n\n    always @(posedge clk) begin\n        arr[15:1] <= arr[14:0];\n        arr[0] <= inp[2];\n    end\n\n    always @(posedge clk) begin\n        arr[15:1] <= arr[14:0];\n        arr[0] <= inp[3];\n    end\n\n    assign arr_out = arr;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock gating circuit that will be used in a larger system. The circuit should take in three inputs: a clock signal (`CLK`), an enable signal (`EN`), and a test enable signal (`TE`). The circuit should output an enable clock signal (`ENCLK`), which should be high only when both the `EN` and `TE` signals are high.\n\nDesign a Verilog module that implements this circuit. Your module should be named `clock_gate` and should have the following inputs and outputs:\n\nInputs:\n- `CLK`: a 1-bit clock signal\n- `EN`: a 1-bit enable signal\n- `TE`: a 1-bit test enable signal\n\nOutputs:\n- `ENCLK`: a 1-bit enable clock signal\n\nAssume that all inputs will be synchronous to the same clock and that the `ENCLK` output should also be synchronous to this clock.\n\nYour module should be self-contained and should not require any additional modules or libraries.\n\n", "output": "module clock_gate (CLK, EN, TE, ENCLK);\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK;\n\n  always @ (posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK <= 1'b1;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a memory block generator module for a digital circuit. The module should be able to store and retrieve data from a memory block. The memory block should have a width of 3 bits and a depth of 8192 words. The module should have the following inputs and outputs:\n\n- `clka`: a clock input\n- `addra`: a 13-bit address input\n- `dina`: a 3-bit data input\n- `wea`: a write enable input\n- `douta`: a 3-bit data output\n\nWrite a Verilog module that implements the memory block generator described above. The memory block should be initialized to all zeros at the start of the simulation. The module should have the following behavior:\n\n- On the rising edge of `clka`, if `wea` is high, the data at the address specified by `addra` should be updated with the value of `dina`.\n- On the rising edge of `clka`, if `wea` is low, the data at the address specified by `addra` should be output on `douta`.\n- The module should be able to handle multiple read and write requests in the same clock cycle.\n- The module should handle out-of-bounds addresses by ignoring the request.\n\n", "output": "module memory_block_generator\n   (douta,\n    clka,\n    addra,\n    dina,\n    wea);\n  output [2:0]douta;\n  input clka;\n  input [12:0]addra;\n  input [2:0]dina;\n  input [0:0]wea;\n\n  reg [2:0] mem [0:8191];\n  \n  always @(posedge clka) begin\n    if (wea) begin\n      mem[addra[12:1]][addra[0]] <= dina;\n    end else begin\n      douta <= mem[addra[12:1]][addra[0]];\n    end\n  end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create two Verilog modules that implement half and full subtractors. \nA half subtractor is a digital circuit that can subtract two bits and produces a difference and a borrow output. \nA full subtractor is similar to a half subtractor, but it also takes into account any borrow input from a previous subtraction.\nYour half subtractor module should have the following inputs and outputs:\n\nInputs: two bits (a and b)\nOutputs: a difference (diff) and a borrow (bout)\nYour full subtractor module should have the following inputs and outputs:\n\nInputs: three bits (a, b, and bin)\nOutputs: a difference (diff) and a borrow (bout)\nThe modules should implement the following functionality:\n\nFor the half subtractor:\nThe difference output should be the result of subtracting b from a.\nThe borrow output should be 1 if a is less than b, and 0 otherwise.\n\nFor the full subtractor:\nThe difference output should be the result of subtracting b and bin from a.\nThe borrow output should be 1 if a is less than b and bin, and 0 otherwise.\nTo implement the subtractors, you should use Verilog code to define the subtraction operation as a Boolean function of the input signals. \nYou should then use this function to compute the difference output and the borrow output for each subtractor.", "output": "module half_subtractor (\n  input a,\n  input b,\n  output diff,\n  output bout\n);\n  \n  assign diff = a ^ b;\n  assign bout = a < b;\n\nendmodule\n\nmodule full_subtractor (\n  input a,\n  input b,\n  input bin,\n  output diff,\n  output bout\n);\n  \n  wire temp_diff, temp_bout;\n  \n  half_subtractor hs1(.a(a), .b(b), .diff(temp_diff), .bout(temp_bout));\n  half_subtractor hs2(.a(temp_diff), .b(bin), .diff(diff), .bout(bout));\n  \n  assign bout = bout | temp_bout;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in two 4-bit binary numbers and outputs the larger of the two numbers. If the two numbers are equal, the output should be either one of the inputs. The output should also be a 4-bit binary number.", "output": "module larger_number(\n    input [3:0] num1,\n    input [3:0] num2,\n    output reg [3:0] larger\n);\n\n    always @(*) begin\n        if(num1 > num2) begin\n            larger = num1;\n        end\n        else if(num2 > num1) begin\n            larger = num2;\n        end\n        else begin\n            larger = num1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit binary adder. The module should have two input ports, A and B, and one output port, S. The module should also have a carry-out port, C_out, which should output a 1 if the addition results in a carry-out, and a 0 otherwise. Your module should be named \"binary_adder\".\n\n", "output": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C_out\n);\n\nwire [4:0] temp; // Temporary signal to hold the sum\n\n// Add the two input values, and store the result in the temporary signal\nassign temp = {1'b0, A} + {1'b0, B};\n\n// Assign the output signals\nassign S = temp[3:0];\nassign C_out = temp[4];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4:1 multiplexer that takes four inputs and one select signal and outputs the selected input. The inputs and select signal are all 1-bit wide. The module should be named `mux4to1` and should have the following ports:\n\n- `out`: output, 1-bit wide\n- `in0`: input, 1-bit wide\n- `in1`: input, 1-bit wide\n- `in2`: input, 1-bit wide\n- `in3`: input, 1-bit wide\n- `sel`: input, 2-bit wide\n\nThe module should be implemented using a behavioral style of coding. You should use a case statement to select the output based on the select signal. If the select signal is invalid, the output should be set to 0.\n\n", "output": "module mux4to1 (\n    out,\n    in0,\n    in1,\n    in2,\n    in3,\n    sel\n);\n\n    output out;\n    input in0;\n    input in1;\n    input in2;\n    input in3;\n    input [1:0] sel;\n\n    reg out;\n\n    always @(*) begin\n        case (sel)\n            2'b00: out = in0;\n            2'b01: out = in1;\n            2'b10: out = in2;\n            2'b11: out = in3;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in three inputs, A, B, and C, and outputs the result of the XOR operation between the three inputs. The module should be named \"my_xor3\" and should be contained within 200 lines of Verilog code. \n\nYour module should have the following interface:\n\n```\nmodule my_xor3 (\n    input A,\n    input B,\n    input C,\n    output X\n);\n```\n\nThe module should implement the XOR operation using only AND, OR, and NOT gates. You are not allowed to use the XOR operator (^) or any other built-in Verilog XOR functionality. \n\nAssume that A, B, and C are single-bit inputs and X is a single-bit output. You may use multiple intermediate signals to help with the implementation.\n\n", "output": "module my_xor3 (\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    wire AB, BC, AC;\n    \n    and AB_gate (AB, A, B);\n    and BC_gate (BC, B, C);\n    and AC_gate (AC, A, C);\n    \n    or AB_BC_gate (X, AB, BC);\n    or X_AC_gate (X, X, AC);\n    \n    not X_gate (X, X);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a clock gating circuit. The module should have three inputs: `CLK`, `GATE`, `VPB`, `VPWR`, `VGND`, and `VNB`. The `CLK` input is the clock signal to be gated, while `GATE` is the gating signal. The `VPB`, `VPWR`, `VGND`, and `VNB` inputs are power supply signals, with `VPB` being the positive power supply, `VPWR` being the negative power supply, `VGND` being the ground signal, and `VNB` being the negative bias voltage. \n\nThe module should have one output, `GCLK`, which is the gated clock signal. When `GATE` is high, the output `GCLK` should be the same as the input `CLK`. When `GATE` is low, the output `GCLK` should be low as well. \n\nImplement the module using Verilog and ensure that it is self-contained, meaning that it should not require any other modules to function. \n\n", "output": "module clock_gating (\n    input CLK,\n    input GATE,\n    input VPB,\n    input VPWR,\n    input VGND,\n    input VNB,\n    output GCLK\n);\n\n    wire gated_clk;\n\n    assign gated_clk = (GATE == 1'b1) ? CLK : 1'b0;\n    assign GCLK = gated_clk;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that performs a 4-bit unsigned multiplication using a shift-and-add algorithm. The module should have two inputs: a 4-bit multiplier and a 4-bit multiplicand. The module should have one output: an 8-bit product. Use a for loop to implement the shift-and-add algorithm.", "output": "module unsigned_multiplier (\n    input [3:0] multiplier,\n    input [3:0] multiplicand,\n    output reg [7:0] product\n);\n\n    integer i, j;\n\n    always @(*) begin\n        product = 0;\n        for (i = 0; i < 4; i = i + 1) begin\n            if (multiplier[i] == 1) begin\n                for (j = 0; j < 4; j = j + 1) begin\n                    if (multiplicand[j] == 1) begin\n                        product[i+j] = product[i+j] + 1;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit input and outputs the binary value of the input with the most significant bit (MSB) set to the value of the least significant bit (LSB). The module should use a behavioral design approach and implement the modification using an if statement and bitwise operators.", "output": "module msb_lsb (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        if (in[0] == 1'b0) begin\n            out = {1'b0, in[3:1]};\n        end else begin\n            out = {1'b1, in[3:1]};\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a module that generates a pulse of a specified duration on the rising edge of a clock signal. The duration of the pulse should be determined by a 12-bit input value that represents the number of clock cycles the pulse should last. The module should have an input signal that loads the duration value, and an output signal that goes high for the duration of the pulse. The pulse should only be generated when an enable signal is high, and should stop immediately when the enable signal goes low.", "output": "module pulse_generator (\n  input clk,\n  input reset,\n  input enable,\n  input [11:0] duration,\n  output reg pulse\n);\n\n  reg [11:0] count;\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 0;\n      pulse <= 0;\n    end else if (enable) begin\n      if (count < duration) begin\n        count <= count + 1;\n        pulse <= 1;\n      end else begin\n        count <= 0;\n        pulse <= 0;\n      end\n    end else begin\n      count <= 0;\n      pulse <= 0;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit binary counter with asynchronous reset. The module should have one input (CLK), one input (RESET), and one output (Q). When RESET is high, Q should be reset to 0. When CLK transitions from low to high, Q should increment by 1.", "output": "module binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that performs a 4-bit arithmetic right shift. The module should take a 4-bit input and shift the bits to the right by a specified amount. The sign bit should be preserved.", "output": "module arithmetic_right_shift (\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    output reg [3:0] data_out\n);\n\n    always @(*) begin\n        case (shift_amount)\n            2'b00: data_out = data_in;\n            2'b01: data_out = {data_in[3], data_in[3:1]};\n            2'b10: data_out = {data_in[3:2], data_in[3:2]};\n            2'b11: data_out = {data_in[3:3], data_in[3:2]};\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been asked to design a 4-bit comparator module that takes two 4-bit inputs, A and B, and outputs a 2-bit signal that indicates whether A is greater than, less than, or equal to B. You are to implement this using a combination of logical and arithmetic operations in Verilog.\n\nThe module should have the following interface:\n\n```\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [1:0] result\n);\n```\n\nThe `result` output should be 2 bits wide and should take the following values:\n\n- `2'b00` if A is equal to B\n- `2'b01` if A is greater than B\n- `2'b10` if A is less than B\n\nYou may not use any built-in Verilog comparison operators (e.g. `>`, `<`, `==`) in your solution. You may use any other Verilog operators and constructs.\n\n", "output": "module comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [1:0] result\n);\n\n    always @(*) begin\n        if (A[3] == 1 && B[3] == 0) begin\n            result = 2'b01;\n        end else if (A[3] == 0 && B[3] == 1) begin\n            result = 2'b10;\n        end else begin\n            if (A[3:0] > B[3:0]) begin\n                result = 2'b01;\n            end else if (A[3:0] < B[3:0]) begin\n                result = 2'b10;\n            end else begin\n                result = 2'b00;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit binary number and outputs the two's complement of the number. Two's complement is a method of representing negative numbers in binary. To find the two's complement of a number, invert all the bits and add 1. For example, the two's complement of binary 0110 is 1010.", "output": "module twos_complement (\n    input signed [3:0] binary,\n    output signed [3:0] twos_comp\n);\n\nassign twos_comp = ~binary + 1;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that uses a single NOT gate to implement a digital circuit that performs a 2's complement operation on an 8-bit binary number. The input port should be named \"in\", and the output port should be named \"out\".", "output": "module twos_complement(\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = ~in + 1;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a shifter circuit. A shifter circuit is a type of digital circuit that shifts the bits of an input signal to the left or right by a specified number of positions. There are three types of shifts - left shift, right shift, and arithmetic shift. \n\nYour module should have the following inputs and outputs:\nInputs: \n- a single input signal (in)\n- a control signal (ctrl) that determines the type of shift (0 for left shift, 1 for right shift, 2 for arithmetic shift)\n- a shift amount (shift_amt) that determines the number of positions to shift the input signal (should be a positive integer)\n\nOutputs:\n- a single output signal (out) that is the result of shifting the input signal\n\nTo implement the shifter circuit, you should use Verilog code to define the shift operation as a function of the input signal and the shift amount. For left shift and right shift, you should simply shift the bits of the input signal by the specified number of positions. For arithmetic shift, you should shift the bits of the input signal to the left or right by the specified number of positions and then fill the vacant bits with the sign bit of the original input signal. \n\nYou should use conditional statements and logical operators in your Verilog code to implement the different shift operations based on the value of the control signal.", "output": "module shifter (\n  input [7:0] in,\n  input [1:0] ctrl,\n  input [3:0] shift_amt,\n  output [7:0] out\n);\n\n  reg [7:0] shifted;\n\n  always @(*) begin\n    case (ctrl)\n      2'b00: shifted = in << shift_amt; // left shift\n      2'b01: shifted = in >> shift_amt; // right shift\n      2'b10: begin // arithmetic shift\n        if (in[7] == 1) begin // if input signal is negative\n          shifted = { {shift_amt{in[7]}}, in[7:shift_amt] };\n        end else begin // if input signal is positive\n          shifted = in >> shift_amt;\n        end\n      end\n    endcase\n    out = shifted;\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in three input signals, A1, A2, and B1, and outputs a single signal Y. The module should be named \"three_input_gate\" and should be written in Verilog.\n\nThe module should perform the following logic:\n\n- If A1 and A2 are both 1, Y should be 1\n- If A1 and A2 are both 0, Y should be 0\n- If B1 is 1, Y should always be 1, regardless of the values of A1 and A2\n\nWrite a Verilog module that implements this logic. Your module should only use the signals provided in the code snippet above.\n\n", "output": "module three_input_gate (\n    input  A1,\n    input  A2,\n    input  B1,\n    output Y\n);\n\n    assign Y = (A1 & A2) | B1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a clock gate. The module should have four inputs:\n\n- `CLK`: a clock signal\n- `EN`: an enable signal\n- `TE`: a transparent enable signal\n- `ENCLK`: an output signal that should be the gated version of the input clock signal\n\nThe module should implement a transparent latch that is controlled by the `EN` and `TE` signals. When `EN` is high, the latch should be enabled and the output signal `ENCLK` should follow the input clock signal `CLK`. When `EN` is low and `TE` is high, the latch should be transparent and the output signal `ENCLK` should follow the input signal `TE`. When both `EN` and `TE` are low, the latch should be disabled and the output signal `ENCLK` should be low.\n\nYour module should be named `clock_gate` and should be contained within 200 lines of Verilog code.\n\n", "output": "module clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  reg latch_out;\n\n  always @(*) begin\n    if (EN) begin\n      latch_out <= CLK;\n    end else if (TE) begin\n      latch_out <= TE;\n    end else begin\n      latch_out <= 1'b0;\n    end\n  end\n\n  assign ENCLK = latch_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 2-input NOR gate. The module should have three ports: two input ports (i0, i1) and one output port (o). The module should output a logic low (0) when either of its input is logic high (1), and a logic high (1) otherwise.\n\nDesign a Verilog module that implements this functionality. Your module should be self-contained, meaning that it should not rely on any other modules.\n\n", "output": "module nor_gate (output reg o, input i0, i1);\n    always @ (i0 or i1)\n        o = ~(i0 | i1);\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 32-bit input signal `data_in` and outputs a 16-bit signal `data_out`. The module should perform the following operations on the input signal:\n1. If the first 8 bits of `data_in` are all 1's, set the first 4 bits of `data_out` to 1's and the last 12 bits to 0's.\n2. If the last 8 bits of `data_in` are all 0's, set the last 4 bits of `data_out` to 1's and the first 12 bits to 0's.\n3. If neither of the above conditions are met, set the first 8 bits of `data_out` to the first 8 bits of `data_in` and the last 8 bits of `data_out` to the last 8 bits of `data_in`.\n\nAssume that the input signal `data_in` is always valid and that the output signal `data_out` should be updated on every positive edge of the clock signal `clk`.\n\nDeclare all input and output signals as `reg`.\n\n", "output": "module data_transformer (\n    input clk,\n    input [31:0] data_in,\n    output [15:0] data_out\n);\n\nreg [7:0] first_eight_bits;\nreg [7:0] last_eight_bits;\n\nalways @(posedge clk) begin\n    if (data_in[31:24] == 8'hFF) begin\n        first_eight_bits <= 8'hFF;\n        last_eight_bits <= 8'h00;\n    end else if (data_in[7:0] == 8'h00) begin\n        first_eight_bits <= 8'h00;\n        last_eight_bits <= 8'h0F;\n    end else begin\n        first_eight_bits <= data_in[31:24];\n        last_eight_bits <= data_in[7:0];\n    end\nend\n\nassign data_out = {first_eight_bits, last_eight_bits};\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 4-to-1 multiplexer using Verilog. The multiplexer should have 4 data inputs (D0, D1, D2, D3), 2 select inputs (S0, S1), and 1 output (Y). The select inputs determine which data input is sent to the output. If S0 and S1 are both 0, then D0 is sent to the output. If S0 is 0 and S1 is 1, then D1 is sent to the output. If S0 is 1 and S1 is 0, then D2 is sent to the output. If S0 and S1 are both 1, then D3 is sent to the output.\n\nDesign a Verilog module that implements this 4-to-1 multiplexer. Your module should be named \"mux_4_to_1\" and should have the following ports:\n\n- D0, D1, D2, D3 (input): 4 data inputs\n- S0, S1 (input): 2 select inputs\n- Y (output): 1 output\n\nYour module should use an \"always\" block to determine which data input is sent to the output based on the select inputs.\n\n", "output": "module mux_4_to_1(\r\n    input D0, D1, D2, D3,\r\n    input S0, S1,\r\n    output reg Y\r\n);\r\n\r\n    always @* begin\r\n        case ({S1,S0})\r\n            2'b00: Y = D0;\r\n            2'b01: Y = D1;\r\n            2'b10: Y = D2;\r\n            2'b11: Y = D3;\r\n        endcase\r\n    end\r\n\r\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 2-bit input, `data`, and outputs a 1-bit signal, `q`, and a 1-bit signal, `zero`. The `q` signal should be the most significant bit of the `data` input, while the `zero` signal should be high if both bits of the `data` input are low.\n\nDesign a Verilog module that implements this functionality. The module should be named `two_bit_encoder` and should have the following inputs and outputs:\n\nInputs:\n- `data`: a 2-bit input signal\n\nOutputs:\n- `q`: a 1-bit output signal representing the most significant bit of the `data` input\n- `zero`: a 1-bit output signal that is high if both bits of the `data` input are low\n\nYour module should be synthesizable and should not use any non-synthesizable constructs or features.\n\n", "output": "module two_bit_encoder (\n    input [1:0] data,\n    output reg q,\n    output reg zero\n);\n\n    always @(*) begin\n        q = data[1];\n        zero = ~(|data);\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module to implement a simple 8-bit adder. The module should have two 8-bit inputs (A and B) and one 8-bit output (C). The module should also have two input wires, clk and rst, which represent the clock and reset signals, respectively. The output should update only on the positive edge of clk. The module should implement the following logic:\n\n- When rst is high, C should be set to 0.\n- When rst is low and clk is high, C should be set to the sum of A and B.\n\nWrite the verilog code for this module.\n\n", "output": "module simple_adder(\n    input clk, rst,\n    input [7:0] A, B,\n    output reg [7:0] C\n);\n\nalways @(posedge clk) begin\n    if(rst) begin\n        C <= 0;\n    end else begin\n        C <= A + B;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a 2:1 multiplexer using Verilog. The multiplexer should take two inputs, A and B, and a select signal S, and output either A or B based on the value of S. You should implement the multiplexer using only combinational logic, without using any pre-built multiplexer modules.\n\nDesign a module named \"mux_2to1\" that takes three input signals: A, B, and S, and one output signal MO. Your module should use the following logic equation to compute the output signal MO:\n\nMO = (S == 1'b1) ? B : A;\n\nYour module should have the following interface:\n\n```\nmodule mux_2to1(\n  input A,\n  input B,\n  input S,\n  output MO\n);\n```\n\nYou should also write a testbench to verify the functionality of your module. The testbench should apply all possible input combinations and verify that the output MO is correct.\n\n", "output": "module mux_2to1(\n  input A,\n  input B,\n  input S,\n  output MO\n);\n\n  assign MO = (S == 1'b1) ? B : A;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit binary counter with a synchronous reset input and an enable input. The counter should increment on every positive edge of the clock signal when the enable input is high. When the reset input is high, the counter should be reset to 0. The module should have four output signals, representing the four bits of the counter.", "output": "module binary_counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\nYou are tasked with designing a Verilog module for a 4-bit adder with the following interface:\n- Two 4-bit inputs, A and B\n- One 4-bit output, SUM\n- One input, CIN, representing a carry-in bit\n- One output, COUT, representing a carry-out bit\n\nThe module should implement the following logic:\n- The SUM output should be the sum of A, B, and CIN\n- The COUT output should be 1 if the sum of A, B, and CIN is greater than 9, and 0 otherwise\n\nDesign a Verilog module that meets these requirements.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] SUM,\n    output COUT\n);\n\nwire [3:0] sum_temp;\nassign sum_temp = A + B + CIN;\nassign SUM = sum_temp[3:0];\nassign COUT = (sum_temp > 4'h9) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a memory encryption and decryption block. \nThe memory encryption and decryption block encrypts and decrypts data stored in memory using an encryption algorithm. \nThe module should have the following inputs and outputs:\n\nInputs: \n- clk: clock signal\n- reset: reset signal\n- data_in: input data to be encrypted or decrypted\n- key: encryption or decryption key\n- enable: enable signal for encryption or decryption\n\nOutputs: \n- data_out: output data after encryption or decryption\n\nYour module should implement the following functionality:\n- When the enable signal is low, the output should be the same as the input (i.e., no encryption or decryption is performed).\n- When the enable signal is high, the input data should be encrypted or decrypted using the key.\n- The encryption and decryption algorithm used should be a simple bitwise XOR operation between the input data and the key.\n- The key should be a user-defined input to the module.\n\nTo implement the memory encryption and decryption block, you should use Verilog code to define the XOR operation between the input data and the key when the enable signal is high. \nYou should then use this function to generate the output data. \nYou should also include logic to ensure that the output data is the same as the input data when the enable signal is low. \nFinally, you should ensure that the circuit is synchronous to the clock signal and that it can be reset using the reset signal.", "output": "module mem_encrypt_decrypt (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [7:0] key,\n  input enable,\n  output [7:0] data_out\n);\n\n  reg [7:0] encrypted_data;\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      data_out <= 0;\n      encrypted_data <= 0;\n    end else begin\n      if (enable) begin\n        encrypted_data <= data_in ^ key;\n        data_out <= encrypted_data;\n      end else begin\n        data_out <= data_in;\n      end\n    end\n  end\n  \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit counter with an enable input and a reset input. The counter should count up to 9 and then reset back to 0. The enable input should allow the counter to increment when it is high, and the reset input should reset the counter to 0 when it is high. The module should contain an always block that is triggered on any change in the inputs. Inside the always block, a case statement should be used to determine whether to increment the counter, reset the counter, or do nothing based on the inputs.", "output": "module counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    count <= 4'b0;\n  end else begin\n    case ({enable, count})\n      2'b00, 4'b1001: count <= 4'b0;\n      2'b01: count <= count + 1;\n    endcase\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes two inputs `A` and `B` and generates an output `X` based on the following conditions:\n- If both `A` and `B` are high, then `X` should be high.\n- If both `A` and `B` are low, then `X` should be low.\n- If `A` is high and `B` is low, then `X` should be high.\n- If `A` is low and `B` is high, then `X` should be low.\n\nYou should implement this module using only `and` and `not` gates. You are not allowed to use any other gates or operators.\n\nThe module should be named `two_input_logic` and should have the following interface:\n- `A` and `B`: input ports of type `logic`\n- `X`: output port of type `logic`\n\nYou should write the verilog code for the `two_input_logic` module.\n\n", "output": "module two_input_logic (\n    A,\n    B,\n    X\n);\n\n    // Module ports\n    input  A;\n    input  B;\n    output X;\n\n    // Local signals\n    wire not_A;\n    wire not_B;\n    wire and1_out;\n    wire and2_out;\n    wire or_out;\n\n    //  Name        Output      Other arguments\n    not not_A_gate (not_A, A);\n    not not_B_gate (not_B, B);\n    and and1_gate   (and1_out, A, not_B);\n    and and2_gate   (and2_out, not_A, B);\n    or  or_gate     (or_out, and1_out, and2_out);\n    not not_out     (X, or_out);\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in 3 inputs and 1 output. The inputs are A, B, and C, and the output is X. The module should implement the following logic:\n\n- If A = 1, then X should be equal to B.\n- If A = 0, then X should be equal to C.\n\nYou can assume that A, B, and C are all 1-bit inputs.\n\nDesign the verilog module that implements this logic.\n\n", "output": "module conditional_output(\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    assign X = (A == 1) ? B : C;\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that implements a 4-bit up-counter with synchronous reset and enable inputs. The module should have two inputs: `clk` and `rst`. The `rst` input is synchronous and active high, and when asserted, the counter should reset to zero. The `en` input is synchronous and active high, and when asserted, the counter should increment on the positive edge of the `clk` signal. The module should have one output `count` which represents the current count value. \n\nUse the following template to implement the module:\n\n```\nmodule up_counter_4bit(clk, rst, en, count);\n\n\t// I/O declarations\n\n\t// insert your code here\n\n\t// Counter declaration\n\n\t// insert your code here\n\t\n\t// Counter logic\n\n\t// insert your code here\n\nendmodule\n```\n\n", "output": "module up_counter_4bit(clk, rst, en, count);\n\n\t// I/O declarations\n\tinput clk, rst, en;\n\toutput reg [3:0] count;\n\n\t// Counter logic\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tcount <= 4'b0000;\n\t\tend else if (en) begin\n\t\t\tcount <= count + 1;\n\t\tend\n\tend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a digital circuit that performs bitwise AND operation on two 2-bit inputs A and B. The module should have the following inputs and outputs:\n\nInputs:\n- A (2-bit input)\n- B (2-bit input)\n\nOutputs:\n- Y (2-bit output)\n\nYour module should be named `bitwise_and`. The module should implement the following truth table:\n\n| A | B | Y |\n|---|---|---|\n| 0 | 0 | 0 |\n| 0 | 1 | 0 |\n| 1 | 0 | 0 |\n| 1 | 1 | 1 |\n\nYou should implement the module using only combinational logic, without using any sequential elements like registers or flip-flops. You are allowed to use basic logic gates (AND, OR, NOT), as well as any other combinational logic gates available in Verilog.\n\nYou should also write a testbench to verify the correctness of your module. The testbench should generate all possible input combinations of A and B, and check that the output Y matches the expected output based on the truth table above.\n\n", "output": "module bitwise_and(\n  input [1:0] A,\n  input [1:0] B,\n  output [1:0] Y\n);\n\n  assign Y = A & B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in 5 inputs and outputs a single value. The module should be named `five_to_one` and should have the following inputs and outputs:\n\n- Inputs: `A`, `B`, `C`, `D`, and `E`, all of which are single-bit wires.\n- Output: `Y`, a single-bit wire.\n\nThe `Y` output should be the result of the following logic:\n\n- If `A` is 1, `Y` should be 1.\n- If `B` is 1, `Y` should be 1.\n- If `C` is 1, `Y` should be 1.\n- If `D` is 1 and `E` is 0, `Y` should be 1.\n- If `D` is 0 and `E` is 1, `Y` should be 1.\n- If none of the above conditions are met, `Y` should be 0.\n\nYou should write a Verilog module that implements this logic. Your module should be contained within 200 lines of code, and should be named `five_to_one`.\n\n", "output": "module five_to_one (\n    input A,\n    input B,\n    input C,\n    input D,\n    input E,\n    output reg Y\n);\n\nalways @(*) begin\n    if (A) begin\n        Y = 1;\n    end else if (B) begin\n        Y = 1;\n    end else if (C) begin\n        Y = 1;\n    end else if (D && !E) begin\n        Y = 1;\n    end else if (!D && E) begin\n        Y = 1;\n    end else begin\n        Y = 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock divider module that converts a 50 MHz input clock into a 1 Hz output clock. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a 50 MHz clock signal\n- `rst`: a synchronous reset signal\n\nOutputs:\n- `clk_out`: a 1 Hz clock signal\n\nThe module should count the number of cycles of the input clock and toggle the output clock signal every 25 million cycles of the input clock. The module should also be able to reset the counter and output clock signal synchronously.\n\nWrite a Verilog module that implements the clock divider described above. \n\n", "output": "module clock_divider(input clk, input rst, output reg clk_out);\n\n\t//Lleva la cuenta de los ciclos de reloj transcurridos\n   reg [25:0] counter;\n\t\t\n\tinitial \n\t\tbegin\n\t\t\tcounter <= 26'd0;\n\t\t\tclk_out <= 1'b1;\n\t\tend\n\t\t\t\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tbegin\n\t\t\t\tcounter <= 26'd0;\n\t\t\t\tclk_out <= 1'b1; //reset output clock to 1\n\t\t\tend\t\n\t\telse\n\t\t\tif(counter == 26'd25000000) //convert 50 MHz to 1 Hz\n\t\t\t\tbegin\n\t\t\t\t\tcounter <= 26'd0;\n\t\t\t\t\tclk_out <= ~clk_out; //toggle output clock\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcounter <= counter+1;\n\t\t\t\tend\n\tend\t\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a random number generator. \nA random number generator is a type of digital circuit that can produce a sequence of random numbers. \nYour module should have the following inputs and outputs:\n\nInputs: a clock signal (clk) and a reset signal (rst)\nOutputs: a random number (rand_num)\nThe module should also have the following parameters:\n\nw: the width of the random number (in bits)\nYour module should implement the following functionality:\n\nThe circuit should generate a random number every clock cycle.\nThe random number should be w bits wide and should be output on the rand_num signal.\nThe circuit should be resettable using the rst signal.\nTo implement the random number generator, you should use a linear feedback shift register (LFSR). \nAn LFSR is a shift register whose input bit is a linear function of its previous state. \nYou can use the LFSR to generate a pseudo-random sequence of numbers. \nYou should use Verilog code to implement the LFSR and connect it to the clk and rst signals. \nYou should also use Verilog code to extract the output random number from the LFSR.", "output": "module RNG (\n  input clk,\n  input rst,\n  output reg [w-1:0] rand_num\n);\n\nparameter w = 8; // width of the random number\n\nreg [w-1:0] lfsr_reg;\nreg feedback;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    lfsr_reg <= 0;\n  end else begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[2] ^ lfsr_reg[3];\n    lfsr_reg <= {feedback, lfsr_reg[w-2:1]};\n  end\nend\n\nassign rand_num = lfsr_reg;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module in Verilog that takes in five inputs, A1, A2, A3, B1, and C1, and produces one output, Y. The module should also take in four power inputs, VPB, VPWR, VGND, and VNB. Your module should be able to perform the following logic function: \n\nIf A1 is high, Y should be high regardless of the other inputs. If A1 is low, then Y should be high if A2 and A3 are both high or if B1 and C1 are both high. Otherwise, Y should be low. \n\nYou should write a Verilog module that implements this logic function. Your module should be self-contained and should not require any external modules. You should limit your module to 200 lines of Verilog code.\n\n", "output": "module logic_function (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  B1,\n    input  C1,\n    output Y,\n\n    input  VPB,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    wire a2_and_a3;\n    wire b1_and_c1;\n\n    assign a2_and_a3 = A2 & A3;\n    assign b1_and_c1 = B1 & C1;\n\n    assign Y = (A1) ? 1'b1 : ((a2_and_a3 | b1_and_c1) ? 1'b1 : 1'b0);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that takes in two 8-bit inputs, A and B, and outputs their quotient and remainder as two 8-bit values. The module should use a combinational circuit to perform the division. If the divisor (B) is zero, the quotient and remainder outputs should be zero. The module should also have a valid output that indicates when the quotient and remainder outputs are valid.", "output": "module division_module (\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder,\n    output reg valid\n);\n\nalways @(*) begin\n    if (B == 0) begin\n        quotient <= 8'b0;\n        remainder <= 8'b0;\n        valid <= 1'b1;\n    end else begin\n        quotient <= A / B;\n        remainder <= A % B;\n        valid <= 1'b1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit binary number and outputs its two's complement representation. The module should be named \"twos_complement\" and should have the following inputs and outputs:\n\nInputs:\n- A 4-bit binary number, \"in\"\n\nOutputs:\n- The 2's complement representation of \"in\", \"out\"\n\nThe module should use the following logic to compute the 2's complement representation of \"in\":\n1. Invert all bits of \"in\"\n2. Add 1 to the inverted value\n3. Output the resulting value as \"out\"\n\nYou should implement this module in Verilog.\n\n", "output": "module twos_complement(\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    // Invert all bits of \"in\"\n    wire [3:0] inverted = ~in;\n\n    // Add 1 to the inverted value\n    wire [3:0] added = inverted + 1;\n\n    // Output the resulting value as \"out\"\n    assign out = added;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a sequential logic circuit. The module should have 4 input ports and 1 output port. The input ports are named `SET_B`, `D`, `GATE`, and `SLEEP_B`. The output port is named `Q`.\n\nYour module should implement the `sky130_fd_sc_lp__srdlstp_1` module, which is a low-power, low-leakage, and high-density sequential element. This module has the following inputs and outputs:\n\n- `Q`: output port of the module\n- `SET_B`: asynchronous active low set input\n- `D`: data input\n- `GATE`: clock enable input\n- `SLEEP_B`: asynchronous active low sleep input\n\nIn addition, you should also include the following voltage supply signals in your module:\n\n- `KAPWR`: power supply for the module\n- `VPWR`: power supply for the module\n- `VGND`: ground supply for the module\n- `VPB`: power supply for the bias generator\n- `VNB`: ground supply for the bias generator\n\nYour module should be designed to be no more than 200 lines of verilog code.\n\n", "output": "module my_module (\n    Q      ,\n    SET_B  ,\n    D      ,\n    GATE   ,\n    SLEEP_B\n);\n\n    output Q      ;\n    input  SET_B  ;\n    input  D      ;\n    input  GATE   ;\n    input  SLEEP_B;\n\n    // Voltage supply signals\n    supply1 KAPWR;\n    supply1 VPWR ;\n    supply0 VGND ;\n    supply1 VPB  ;\n    supply0 VNB  ;\n\n    sky130_fd_sc_lp__srdlstp_1 base (\n        .Q(Q),\n        .SET_B(SET_B),\n        .D(D),\n        .GATE(GATE),\n        .SLEEP_B(SLEEP_B)\n    );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with an asynchronous set input. The module should have three inputs: D (data input), C (clock input), and S (set input). The module should have one output, Q (flip-flop output).\n\nThe D flip-flop should behave according to the following truth table:\n\n| C | D | S | Q |\n|---|---|---|---|\n| 0 | X | X | Q |\n| 1 | 0 | 0 | Q |\n| 1 | 0 | 1 | 1 |\n| 1 | 1 | 0 | D |\n| 1 | 1 | 1 | 1 |\n\nWhere X means don't care.\n\nThe module should be implemented using Verilog and should be self-contained, meaning that no additional modules should be used in the implementation.\n\n", "output": "module dffns(\n    output reg Q,\n    input D,\n    input C,\n    input S\n);\n\n    always @(negedge C or negedge S)\n        if (!S)\n            Q <= 1'b1;\n        else\n            Q <= D;\n\nendmodule"}
{"instruction": "\n\nYou are required to implement a module that performs the addition of two 8-bit numbers using the Verilog hardware description language. The module should take two 8-bit inputs and produce an 8-bit output that represents the sum of the two inputs. You should also implement a carry-out bit that indicates if there is an overflow in the addition operation. \n\nYou should implement the addition operation using a combinational logic circuit. Your module should have the following interface:\n\n```\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum,\n    output carry_out\n);\n```\n\nWhere `A` and `B` are the 8-bit input signals, `sum` is the 8-bit output signal that represents the sum of `A` and `B`, and `carry_out` is a single bit output signal that indicates if there is an overflow in the addition operation. \n\n", "output": "module adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum,\n    output carry_out\n);\n\n    wire[8:0] temp_sum;\n\n    assign temp_sum = {1'b0, A} + {1'b0, B};\n\n    assign sum = temp_sum[7:0];\n    assign carry_out = temp_sum[8];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module to implement a 4-bit synchronous up-counter with active-low asynchronous reset and a synchronous load input. The counter should increment on the positive edge of the clock signal and the load input should be active-high. When the load input is high, the counter should load the value present on the data input on the next positive clock edge. When the reset input is active-low, the counter should reset to zero. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `reset`: the asynchronous reset input\n- `load`: the load input\n- `data`: the data input for loading a value\n\nOutputs:\n- `count`: the 4-bit output of the counter\n\nYou are required to write a Verilog module that implements this counter.\n\n", "output": "module up_counter(clk, reset, load, data, count);\n\n\tinput clk, reset, load;\n\tinput [3:0] data;\n\toutput reg [3:0] count;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset == 0) begin\n\t\t\tcount <= 4'b0;\n\t\tend\n\t\telse if (load == 1) begin\n\t\t\tcount <= data;\n\t\tend\n\t\telse begin\n\t\t\tcount <= count + 1;\n\t\tend\n\tend\n\t\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a Johnson counter state machine. \nA Johnson counter is a type of digital circuit that cycles through a sequence of states, and can be used for applications such as frequency division, timing, and control.\n\nYour module should have the following inputs and outputs:\n\nInputs: a clock signal (clk)\nOutputs: a set of n output signals (out1, out2, ..., outn)\nThe module should also have the following parameters:\n\nn: the number of output signals\nYour module should implement the following functionality:\n\nThe circuit should have n states, each of which is represented by a unique combination of the output signals.\nThe circuit should cycle through the states in a pre-defined sequence, determined by the Johnson counter algorithm.\nThe output signals should change on each clock cycle, according to the current state of the Johnson counter.\nTo implement the Johnson counter state machine, you should use Verilog code to define the sequence of states as a set of Boolean functions of the current state and the clock signal. \nYou should then use these functions to connect the current state to the next state, and to determine the output signals for each state.\nFinally, you should use the clock signal to trigger the state transitions and output updates on each clock cycle.\n\nYour module should be named johnson_counter and have the following input and output definitions:\n  \n  module johnson_counter (\n    input clk,\n    output [n-1:0] out\n  );\n\n  parameter n = 4; // number of output signals", "output": "module johnson_counter (\n  input clk,\n  output [n-1:0] out\n);\n\n  parameter n = 4; // number of output signals\n\n  reg [n-1:0] state;\n  wire [n-1:0] next_state;\n\n  assign out = state;\n\n  always @ (posedge clk) begin\n    state <= next_state;\n  end\n\n  assign next_state[0] = state[n-1] ^ state[0];\n  assign next_state[1] = state[0] ^ state[1];\n  assign next_state[2] = state[1] ^ state[2];\n  assign next_state[3] = state[2] ^ state[3];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit shift register with parallel load functionality. The module should have four inputs: data_in, load, shift_left, and shift_right. When load is high, the value of data_in should be loaded into the shift register. When shift_left is high, the contents of the shift register should be shifted left by one bit. When shift_right is high, the contents of the shift register should be shifted right by one bit. The module should have one output: data_out, which should output the current value of the shift register.", "output": "module shift_register (\n    input [3:0] data_in,\n    input load,\n    input shift_left,\n    input shift_right,\n    output [3:0] data_out\n);\n\nreg [3:0] shift_reg;\n\nalways @ (posedge load) begin\n    shift_reg <= data_in;\nend\n\nalways @ (posedge shift_left) begin\n    shift_reg <= {shift_reg[2:0], 1'b0};\nend\n\nalways @ (posedge shift_right) begin\n    shift_reg <= {1'b0, shift_reg[3:1]};\nend\n\nassign data_out = shift_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-bit Gray code counter that counts from 0 through 7, inclusive, with a period of 8. The counter should reset to 0 when the reset input is active high synchronous. Gray code is a binary numeral system where two successive values differ in only one bit. Implement the counter using a combinational circuit that converts binary to Gray code.", "output": "module gray_code_counter (\n  input clk,\n  input reset,\n  output reg [2:0] count_gray\n);\n\n  reg [2:0] count_bin;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_bin <= 3'b000;\n      count_gray <= 3'b000;\n    end\n    else begin\n      count_bin <= count_bin + 1;\n      count_gray <= {count_bin[2], count_bin[2]^count_bin[1], count_bin[1]^count_bin[0]};\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a 2-bit counter that counts up on each rising edge of the clock signal. The module should have the following ports:\n\n- `clk`: input clock signal\n- `rst`: asynchronous reset input (active low)\n- `count`: 2-bit output representing the current count value\n\nImplement the module using a synchronous reset D flip-flop for each bit of the counter. Ensure that the counter resets to 0 when the reset input is asserted.\n\n", "output": "module counter_2bit(\n    input clk,\n    input rst,\n    output reg [1:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 2'b00;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a verilog module `multiplier` with the following inputs and outputs:\n\nInputs:\n- `a` (32-bit): an unsigned integer\n- `b` (32-bit): an unsigned integer\n\nOutputs:\n- `result` (64-bit): the product of `a` and `b`\n\nThe module should implement a combinational multiplier that takes `a` and `b` and returns their product as a 64-bit unsigned integer.\n\nWrite the verilog code for the `multiplier` module.\n\n", "output": "module multiplier(\n  input [31:0] a,\n  input [31:0] b,\n  output [63:0] result\n);\n\n  wire [31:0] a_lo;\n  wire [31:0] a_hi;\n  wire [31:0] b_lo;\n  wire [31:0] b_hi;\n\n  assign a_lo = a[15:0];\n  assign a_hi = a[31:16];\n  assign b_lo = b[15:0];\n  assign b_hi = b[31:16];\n\n  wire [63:0] p0;\n  wire [63:0] p1;\n  wire [63:0] p2;\n\n  assign p0 = a_lo * b_lo;\n  assign p1 = a_hi * b_lo;\n  assign p2 = a_lo * b_hi;\n\n  assign result = (p0 + (p1 << 16) + (p2 << 16)) + (a_hi * b_hi) << 32;\n\nendmodule"}
{"instruction": "\n\nYou are working on a project that requires you to design a digital circuit using Verilog. The circuit includes a module called `sirv_aon_porrst`, which is responsible for generating a power-on reset signal for the system. \n\nThe `sirv_aon_porrst` module has one output port called `porrst_n`, which is an active-low signal. When the circuit is first powered on, `porrst_n` is set to 0 to indicate that the system is in a reset state. After a certain period of time, the reset signal is released and `porrst_n` is set to 1 to indicate that the system is ready for operation.\n\nHowever, there is one problem: the `sirv_aon_porrst` module needs to work on both FPGA and ASIC platforms. In an FPGA, there is no PORRST circuit, so the `porrst_n` output should be tied high. On an ASIC, the `porrst_n` output should be generated by the module.\n\nYour task is to write a Verilog module that implements the `sirv_aon_porrst` module. The module should be able to distinguish between an FPGA and ASIC platform and generate the correct `porrst_n` signal accordingly.\n\nYou are not allowed to use any external libraries or modules. Your solution should be self-contained and should not exceed 200 lines of Verilog code.\n\n", "output": "module sirv_aon_porrst(\n  output porrst_n\n);\n\n  `ifdef FPGA_SOURCE\n      // In FPGA, we have no PORRST circuit\n      assign porrst_n = 1'b1;\n  `else\n      // Generate PORRST signal using circuit\n      reg [31:0] counter = 0;\n      always @(posedge clk) begin\n        if (counter < 100) begin\n          counter <= counter + 1;\n          porrst_n <= 1'b0;\n        end else begin\n          porrst_n <= 1'b1;\n        end\n      end\n  `endif\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a module in Verilog that takes in 5 input signals and produces 1 output signal. The module should be named `my_module` and should have the following ports:\n\n- `input [7:0] a`\n- `input [7:0] b`\n- `input [7:0] c`\n- `input [7:0] d`\n- `input [7:0] e`\n- `output [7:0] out`\n\nThe module should perform the following operation on the inputs:\n\n1. Take the bitwise AND of `a` and `b`, and store the result in a temporary variable `temp1`.\n2. Take the bitwise OR of `c` and `d`, and store the result in a temporary variable `temp2`.\n3. Take the bitwise XOR of `temp1` and `temp2`, and store the result in `out`.\n4. Add `e` to `out`, and store the result in `out`.\n\nImplement the `my_module` module in Verilog, ensuring that it is no more than 200 lines long.\n\n", "output": "module my_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    input [7:0] e,\n    output [7:0] out\n);\n\n    wire [7:0] temp1;\n    wire [7:0] temp2;\n\n    assign temp1 = a & b;\n    assign temp2 = c | d;\n\n    assign out = temp1 ^ temp2;\n    assign out = out + e;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that generates a clock signal with a period of 2 clock cycles. The module should have one input, `clk`, which is the system clock, and one output, `genclk`, which is the generated clock signal. The generated clock signal should have a duty cycle of 50% and should be in phase with the system clock.\n\nWrite a verilog module that meets these requirements. \n\n", "output": "module clock_generator (\n   input clk,\n   output reg genclk\n);\n\nreg [7:0] cyc; \ninitial cyc = 0;\nwire genthiscyc = ( (cyc % 2) == 1 );\n\nalways @ (posedge clk) begin\n   cyc <= cyc + 8'h1;\n   genclk <= genthiscyc;\nend\n\nalways @ (posedge genclk) begin\n   cyc <= 0;\nend\n\nendmodule"}
{"instruction": "\n\nYou have been given the task to design a Verilog module that takes in a 12-bit signed input `src` and outputs a 12-bit signed output `dst`. Your task is to write a Verilog module named `signed_add` that performs the following operation on the input `src`:\n\n- Adds 4 to the input `src`.\n- If the result is less than -2048, then the output `dst` should be set to -2048.\n- If the result is greater than 2047, then the output `dst` should be set to 2047.\n- Otherwise, the output `dst` should be set to the result of the addition.\n\nYou must ensure that your Verilog module is self-contained and should not rely on any external modules. Additionally, your module should not exceed 200 lines of Verilog code.\n\nWrite a Verilog module named `signed_add` that takes in a 12-bit signed input `src` and outputs a 12-bit signed output `dst` that satisfies the above requirements.\n\n", "output": "module signed_add(\n    output wire logic signed [11:0] dst,\n    input  wire logic signed [11:0] src\n);\n\n    logic signed [11:0] temp;\n    always_comb begin\n        temp = src + 4;\n        if (temp < -2048)\n            dst = -2048;\n        else if (temp > 2047)\n            dst = 2047;\n        else\n            dst = temp;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a pipelined multiplier that takes two 8-bit unsigned numbers as inputs and produces a 16-bit unsigned result. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a synchronous active-high reset signal\n- `a`: an 8-bit unsigned number\n- `b`: an 8-bit unsigned number\n\nOutputs:\n- `result`: a 16-bit unsigned number\n\nThe multiplier should use the standard shift-and-add algorithm, with the following requirements:\n- The multiplication should be pipelined, with a latency of one clock cycle\n- The module should use unsigned arithmetic\n- The module should handle overflow and wraparound correctly\n- The module should be designed to be synthesizable and meet timing requirements\n\nDesign the verilog module for the pipelined multiplier.\n\n", "output": "module pipelined_multiplier (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n\nreg [7:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        a_reg <= 8'h00;\n        b_reg <= 8'h00;\n        result <= 16'h0000;\n    end else begin\n        a_reg <= a;\n        b_reg <= b;\n        result <= {8'h00, a_reg} * {8'h00, b_reg};\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a Verilog module that simulates a circuit that behaves like a dual-edge triggered flip-flop. The circuit should be triggered on both edges of the clock, but should only use positive edge-triggered flip-flops and combinational logic to achieve this functionality. Additionally, the module should have a reset input that asynchronously resets the flip-flop to its initial state.", "output": "module dual_edge_ff (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n        q1 <= 0;\n        q2 <= 0;\n    end else begin\n        q1 <= d;\n        q2 <= q1;\n    end\nend\n\nalways @(negedge clk or negedge reset) begin\n    if (reset == 0) begin\n        q <= 0;\n    end else begin\n        q <= q2;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a 2-input NAND gate with an enable input. The module should have three inputs: A, B, and EN. The output of the module should be low (0) when both A and B are high (1) and EN is also high (1). Otherwise, the output should be high (1).\n\nDesign a Verilog module that implements this behavior. The module should be named \"nand2_en\" and should have the following interface:\n\n```\nmodule nand2_en (\n    output Z,\n    input A,\n    input B,\n    input EN\n);\n```\n\nYour implementation should only use basic logic gates (NOT, AND, OR, XOR) and should not use any other modules or libraries.\n\n", "output": "module nand2_en (\n    output Z,\n    input A,\n    input B,\n    input EN\n);\n\n    wire nand1_out;\n    wire nand2_out;\n    wire and_out;\n\n    // Implement NAND1 gate\n    assign nand1_out = ~(A & B);\n\n    // Implement NAND2 gate\n    assign nand2_out = ~(nand1_out & EN);\n\n    // Implement AND gate\n    assign and_out = A & B;\n\n    // Implement final output\n    assign Z = nand2_out & and_out;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit shift register with parallel load. The module should have two inputs, data_in and load, and one output, data_out. When load is high, the value of data_in should be loaded into the shift register. When load is low, the value of data_in should be shifted into the shift register. The initial value of the shift register should be 0000. The output data_out should be the value of the shift register after the shifting or loading operation.", "output": "module shift_register (\n  input clk,\n  input reset,\n  input [3:0] data_in,\n  input load,\n  output reg [3:0] data_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      data_out <= 4'b0000;\n    end else if (load) begin\n      data_out <= data_in;\n    end else begin\n      data_out <= {data_out[2:0], data_in};\n    end\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-to-2 priority encoder. The module should have four inputs (A, B, C, and D) and two outputs (Y and V). Y should be a 2-bit vector that represents the highest priority input. If multiple inputs are high at the same time, the input with the highest index should take priority. V should be a 1-bit vector that is high when at least one input is high. Use an if-else statement to implement the priority logic.", "output": "module priority_encoder (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [1:0] Y,\n    output reg V\n);\n\n    always @ (A or B or C or D) begin\n        if (A) begin\n            Y = 2'b00;\n            V = 1'b1;\n        end else if (B) begin\n            Y = 2'b01;\n            V = 1'b1;\n        end else if (C) begin\n            Y = 2'b10;\n            V = 1'b1;\n        end else if (D) begin\n            Y = 2'b11;\n            V = 1'b1;\n        end else begin\n            Y = 2'b00;\n            V = 1'b0;\n        end\n    end\n\nendmodule"}
{"instruction": "Create an XOR gate using a non-clocked always block. The module should take two input bits and produce a single output bit. Use an if-else statement to implement the XOR gate functionality in the Verilog code.", "output": "module xor_gate(\n    input a,\n    input b,\n    output reg out_if_else\n);\n\nalways @(*) begin\n    if(a != b) begin\n        out_if_else = 1;\n    end\n    else begin\n        out_if_else = 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that can perform a binary multiplication operation on two 8-bit unsigned integers. The module should have two input ports, `A` and `B`, and one output port, `P`. The module should also have a control input port, `start`, which when set to 1, initiates the multiplication operation. The module should only output the result, `P`, when the operation is complete. \n\nThe multiplication operation should be performed using a shift-and-add algorithm. The algorithm should be implemented using a loop, and the loop should terminate when all the bits of the second input, `B`, have been processed. The module should use combinational logic only, and should not use any sequential logic.\n\nAssume that the input values are valid and that overflow will not occur during the multiplication operation.\n\n", "output": "module binary_multiplier(\n    input [7:0] A,\n    input [7:0] B,\n    input start,\n    output reg [15:0] P\n);\n\n    reg [7:0] B_temp;\n    reg [3:0] i;\n    reg [7:0] A_temp;\n    reg [15:0] P_temp;\n    \n    always @(*) begin\n        P_temp = 0;\n        A_temp = A;\n        B_temp = B;\n        if (start) begin\n            for(i=0; i<8; i=i+1) begin\n                if (B_temp[0] == 1) begin\n                    P_temp = P_temp + (A_temp << i);\n                end\n                B_temp = B_temp >> 1;\n            end\n            P = P_temp;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `one_level_bpred` that implements a one-level branch predictor. The module has five inputs and two outputs. The inputs are:\n- `clk`: a clock signal\n- `reset`: a reset signal\n- `brn_addr_bpred_i`: the address of the branch instruction being executed\n- `brn_ex_mem_bpred_i`: a signal indicating whether the branch was taken or not\n- `brn_fdback_addr_bpred_i`: the address of the branch instruction whose prediction is being fed back\n- `brn_fdback_bpred_i`: the actual outcome of the branch instruction whose prediction is being fed back\n- `brn_btb_addr_bpred_i`: the address of the branch target buffer (BTB) entry for the current branch instruction\n\nThe module has two outputs:\n- `brn_takeness_bpred_o`: a signal indicating whether the branch should be taken or not\n- `brn_target_addr_bpred_o`: the predicted target address of the branch instruction if it is taken, or 0 otherwise\n\nThe `one_level_bpred` module has a branch history table (BHT) that consists of `NUM_ENTRIES` 2-bit saturating counters. The `brn_addr_bpred_i` input is used to index into the BHT to obtain the 2-bit saturating counter for the corresponding branch instruction. The `brn_pred_bits` wire is used to store the value of the counter for the current branch instruction.\n\nThe `brn_takeness_bpred` wire is set to the most significant bit of the `brn_pred_bits` wire. If `brn_takeness_bpred` is 1, the branch is predicted to be taken and the `brn_target_addr_bpred` wire is set to the corresponding entry in the BTB. If `brn_takeness_bpred` is 0, the branch is predicted not to be taken and `brn_target_addr_bpred` is set to 0.\n\nThe `one_level_bpred` module also has a BTB that consists of `NUM_ENTRIES` entries. Each entry contains the target address of a branch instruction and is indexed using the same index as the corresponding BHT entry. The `brn_btb_addr_bpred_i` input is used to obtain the target address of the current branch instruction from the BTB.\n\nYour task is to implement the `two_bit_sat_counter` module that implements a 2-bit saturating counter. The module should have the following inputs and outputs:\n- `count_i`: the current value of the counter (2 bits)\n- `op`: the operation to perform on the counter (1 bit)\n- `count`: the updated value of the counter (2 bits)\n\nThe `op` input is 1 if the branch instruction was taken and 0 otherwise. If `count_i` is 2'b00 and `op` is 1, `count` should be set to 2'b01. If `count_i` is 2'b01 and `op` is 1, `count` should be set to 2'b10. If `count_i` is 2'b10 and `op` is 0, `count` should be set to 2'b01. If `count_i` is 2'b01 and `op` is 0, `count` should be set to 2'b00.\n\nNote that the `two_bit_sat_counter` module should be designed to be used within the `one_level_bpred` module.\n\n", "output": "module two_bit_sat_counter (\n    input [1:0] count_i,\n    input op,\n    output [1:0] count\n);\n\n    always @*\n    begin\n        case (count_i)\n            2'b00: count = op ? 2'b01 : 2'b00;\n            2'b01: count = op ? 2'b10 : 2'b00;\n            2'b10: count = op ? 2'b10 : 2'b01;\n            2'b11: count = op ? 2'b11 : 2'b10;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that will serve as a voltage level shifter. The module should have four inputs: `VPWR`, `VGND`, `VPB`, and `VNB`. The `VPWR` input should be a voltage level that represents the power supply voltage, while the `VGND` input should be a voltage level that represents the ground voltage. The `VPB` and `VNB` inputs should be voltage levels that represent the signal that needs to be shifted.\n\nYour task is to design a Verilog module that will shift the voltage levels of `VPB` and `VNB` to match the voltage levels of `VPWR` and `VGND`, respectively. The module should have four outputs: `VPB_OUT`, `VNB_OUT`, `VPWR_OUT`, and `VGND_OUT`. The `VPB_OUT` and `VNB_OUT` outputs should be the shifted versions of the `VPB` and `VNB` inputs, respectively. The `VPWR_OUT` and `VGND_OUT` outputs should be the same as the `VPWR` and `VGND` inputs, respectively.\n\nAssume that the voltage levels of `VPWR` and `VGND` are fixed at 1.8V and 0V, respectively. The voltage levels of `VPB` and `VNB` can be either 1.8V or 0V.\n\nDesign a Verilog module that satisfies the above requirements. Your module should be self-contained and should not rely on any external modules. Your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module voltage_level_shifter (\n    VPWR,\n    VGND,\n    VPB,\n    VNB,\n    VPB_OUT,\n    VNB_OUT,\n    VPWR_OUT,\n    VGND_OUT\n);\n\n    input VPWR;\n    input VGND;\n    input VPB;\n    input VNB;\n    output VPB_OUT;\n    output VNB_OUT;\n    output VPWR_OUT;\n    output VGND_OUT;\n\n    assign VPWR_OUT = VPWR;\n    assign VGND_OUT = VGND;\n\n    assign VPB_OUT = (VPB == 1'b1) ? VPWR : VGND;\n    assign VNB_OUT = (VNB == 1'b1) ? VPWR : VGND;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit wide, 2-to-1 multiplexer using only 2-input XOR gates. The module should have three inputs (a, b, and sel) and one 4-bit output (out). If sel is 0, the module should output the a input. If sel is 1, the module should output the b input.", "output": "module xor_multiplexer_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input sel,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        out[0] = a[0] ^ (sel & b[0]);\n        out[1] = a[1] ^ (sel & b[1]);\n        out[2] = a[2] ^ (sel & b[2]);\n        out[3] = a[3] ^ (sel & b[3]);\n    end\n\nendmodule"}
{"instruction": "\n\nDesign a Verilog module for a 4-to-1 multiplexer with an 8-bit data width. The module should have four 8-bit data inputs, two 1-bit select inputs, and one 8-bit output. The output should be selected based on the values of the select inputs as follows:\n\n- if sel = 0, output should be equal to d0\n- if sel = 1, output should be equal to d1\n- if sel = 2, output should be equal to d2\n- if sel = 3, output should be equal to d3\n\nThe module should be named \"mux4_8bit\" and should use a parameter to define the data width. The module should use a combinational logic block to determine the output value based on the select inputs.\n\n", "output": "module mux4_8bit #(parameter WIDTH = 8)\n             (input      [WIDTH-1:0] d0, d1, d2, d3,\n              input      [1:0]       sel, \n              output reg [WIDTH-1:0] y);\n\n   always @(*)\n      case(sel)\n         2'b00: y = d0;\n         2'b01: y = d1;\n         2'b10: y = d2;\n         2'b11: y = d3;\n      endcase\nendmodule"}
{"instruction": "\nYou are tasked with implementing a memory module in Verilog that utilizes a pre-defined block memory module. The block memory module, `ram_8x512_hi`, has 8-bit input and output ports, and can store up to 512 8-bit values. Your module should have the following ports:\n- `clk`: a clock input\n- `addr`: a 9-bit address input\n- `din`: an 8-bit data input\n- `dout`: an 8-bit data output\n- `en`: an enable input\n- `we`: a write enable input\n\nWhen `en` is high, the module should output the value stored at the memory location specified by `addr`. When `we` is high, the module should write the value on the `din` input to the memory location specified by `addr`. \n\nYour module should be implemented in no more than 200 lines of Verilog code.\n\n", "output": "module my_ram(\n    input clk,\n    input [8:0] addr,\n    input [7:0] din,\n    output [7:0] dout,\n    input en,\n    input we\n);\n\n    wire [7:0] mem_out;\n    wire [7:0] mem_in = din;\n    reg [7:0] dout_reg;\n    \n    ram_8x512_hi mem_inst (\n        .clk(clk),\n        .addr(addr),\n        .din(mem_in),\n        .dout(mem_out),\n        .en(en),\n        .we(we)\n    );\n    \n    always @(posedge clk) begin\n        if (en) begin\n            dout_reg <= mem_out;\n        end\n    end\n    \n    assign dout = dout_reg;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 3-to-8 decoder. The module should have three input bits and eight output bits. The output bit corresponding to the input value should be high, while all other output bits should be low. \n\nCreate a module named `decoder_3to8` that meets these requirements. Your module should be written in Verilog and should be self-contained, meaning that any necessary input and output definitions should be included in the module.\n\nIn addition, your module should be designed to be easily testable. You should include a test plan that covers all possible input combinations and verifies that the output is correct.\n\n", "output": "module decoder_3to8(\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out = (in == 3'b000) ? 8'b00000001 :\n             (in == 3'b001) ? 8'b00000010 :\n             (in == 3'b010) ? 8'b00000100 :\n             (in == 3'b011) ? 8'b00001000 :\n             (in == 3'b100) ? 8'b00010000 :\n             (in == 3'b101) ? 8'b00100000 :\n             (in == 3'b110) ? 8'b01000000 :\n             (in == 3'b111) ? 8'b10000000 :\n             8'b00000000;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a pipeline register. A pipeline register is a type of digital circuit that is used in pipelined systems to synchronize data between stages. \nYour module should have the following inputs and outputs:\nInputs: a data signal (data_in), a clock signal (clk), and a reset signal (reset).\nOutputs: a data signal (data_out).\nYour module should implement the following functionality:\nThe circuit should store the data_in signal on the rising edge of the clock signal and hold it until the next rising edge of the clock signal.\nThe circuit should reset the data_out signal to zero when the reset signal is high.\nTo implement the pipeline register, you should use Verilog code to define the behavior of the data_in and data_out signals based on the clock and reset signals. \nYou should then use these signals to synchronize the data between stages in a pipelined system.", "output": "module pipeline_register (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  output [31:0] data_out\n);\n\n  reg [31:0] data_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_reg <= 0;\n    end else begin\n      data_reg <= data_in;\n    end\n  end\n\n  assign data_out = data_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a System on Chip (SoC) that generates a clock signal using a Phase-Locked Loop (PLL). The module should have the following inputs and outputs:\n\nInputs:\n- `refclk`: the reference clock signal to the PLL\n- `rst`: the reset signal to the PLL\n\nOutputs:\n- `outclk_0`: the output clock signal generated by the PLL\n- `locked`: a signal indicating whether the PLL is locked onto the reference clock or not\n\nYou should use the code snippet provided as a reference for your design. The PLL in the code snippet has the following characteristics:\n- The PLL is a fractional-N PLL\n- The reference clock frequency is 50.0 MHz\n- The output clock frequency is 130.000000 MHz\n- The duty cycle of the output clock is 50%\n- There is only one output clock (outclk_0)\n\nYour task is to design a module that uses the provided PLL to generate the output clock signal and indicate whether the PLL is locked onto the reference clock or not.\n\nYour module should be named `pll_generator` and should have the following interface:\n\nInputs:\n- `clk_in`: the reference clock signal to the PLL\n- `rst`: the reset signal to the PLL\n\nOutputs:\n- `clk_out`: the output clock signal generated by the PLL\n- `locked`: a signal indicating whether the PLL is locked onto the reference clock or not\n\nYour module should use the provided PLL module and any other necessary logic to generate the output clock signal and indicate whether the PLL is locked onto the reference clock or not.\n\n", "output": "module pll_generator(\n    input clk_in,\n    input rst,\n    output clk_out,\n    output locked\n);\n\n    wire outclk_0;\n    \n    // Instantiate the provided PLL module\n    soc_system_pll_stream pll_inst(\n        .refclk(clk_in),\n        .rst(rst),\n        .outclk_0(outclk_0),\n        .locked(locked)\n    );\n    \n    // Output the generated clock signal\n    assign clk_out = outclk_0;\n    \nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes four inputs and one output. The inputs are A1, A2, B1, and a clock signal. The output is X. The module should implement a D flip-flop with asynchronous reset and active-high enable. The D input of the flip-flop is the logical AND of A1 and A2, and the clock signal is used to trigger the flip-flop. The reset signal is asynchronous and active-low, and the enable signal is active-high. The module should be named \"dff_async_reset_enable\".\n\n", "output": "module dff_async_reset_enable (\n    input A1,\n    input A2,\n    input B1,\n    input clk,\n    input reset_n,\n    input enable,\n    output reg X\n);\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        X <= 0;\n    end else if (enable) begin\n        X <= A1 & A2;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit adder with carry-in and carry-out functionality. The module should take two 4-bit inputs, A and B, and output a 4-bit sum, S, and a carry-out bit, C_out. The module should also have a carry-in input, C_in, which allows for the addition of multi-bit numbers.\n\nYour module should be named \"four_bit_adder\" and should contain the following inputs and outputs:\n\nInputs:\n- A (4-bit input)\n- B (4-bit input)\n- C_in (1-bit input)\n\nOutputs:\n- S (4-bit output)\n- C_out (1-bit output)\n\nYour module should implement the following logic:\n- The least significant bit of A and B should be added together along with the carry-in bit, C_in, to produce the least significant bit of the sum, S_0, and the carry-out bit, C_1.\n- The second least significant bit of A and B should be added together along with the carry-out bit, C_1, to produce the second least significant bit of the sum, S_1, and the carry-out bit, C_2.\n- This process should be repeated for the remaining two bits of A and B to produce the final sum, S, and carry-out bit, C_out.\n\nYour module should be designed in a way that minimizes the number of logic gates used and should be contained within 200 lines of Verilog code.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input C_in,\n    output [3:0] S,\n    output C_out\n);\n\nwire [3:0] sum;\nwire [4:0] carry;\n\nassign sum[0] = A[0] ^ B[0] ^ C_in;\nassign carry[1] = (A[0] & B[0]) | (A[0] & C_in) | (B[0] & C_in);\nassign sum[1] = A[1] ^ B[1] ^ carry[1];\nassign carry[2] = (A[1] & B[1]) | (A[1] & carry[1]) | (B[1] & carry[1]);\nassign sum[2] = A[2] ^ B[2] ^ carry[2];\nassign carry[3] = (A[2] & B[2]) | (A[2] & carry[2]) | (B[2] & carry[2]);\nassign sum[3] = A[3] ^ B[3] ^ carry[3];\nassign C_out = carry[4];\n\nassign S = sum;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in six input signals and outputs a single signal. The inputs are named A1, A2, B1, B2, and C1 and are all of type `input`. The output is named Y and is of type `output`. The module should be named `six_signal_module`.\n\nThe module should perform the following logic:\n- If A1 and A2 are both high, Y should be high.\n- If B1 and B2 are both high, Y should be high.\n- If C1 is high and either A1 or A2 are high, Y should be high.\n- In all other cases, Y should be low.\n\nDesign a Verilog module that meets the above requirements. Your solution should be self-contained and should not require any additional modules. You are free to use any Verilog constructs that you feel are appropriate.\n\n", "output": "module six_signal_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    output Y\n);\n\n    assign Y = (A1 & A2) | (B1 & B2) | (C1 & (A1 | A2));\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that can generate voltage supply signals for a circuit. The module should have four supply signals: `VPWR`, `VGND`, `VPB`, and `VNB`. \n\n`VPWR` should be a supply signal with a voltage of 1V. `VGND` should be a supply signal with a voltage of 0V. `VPB` should be a supply signal with a voltage of 1.2V, and `VNB` should be a supply signal with a voltage of -1.2V.\n\nDesign a Verilog module that can generate these four supply signals. Your module should be self-contained and should not require any external inputs. Your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module supply_signals();\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // assign values to the supply signals\n    assign VPWR = 1;\n    assign VGND = 0;\n    assign VPB = 1.2;\n    assign VNB = -1.2;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that receives data and outputs it on a read port. The module should have the following inputs and outputs:\n\nInputs:\n- `address` (2-bit): address of the data to be read\n- `clk` (1-bit): clock signal\n- `in_port` (1-bit): input data\n- `reset_n` (1-bit): reset signal\n\nOutputs:\n- `readdata` (32-bit): output data\n\nThe module should have the following behavior:\n- On reset (`reset_n` low), `readdata` should be set to 0.\n- On each positive edge of the clock (`clk`), the data on `in_port` should be read.\n- If the `address` is 0, the data read from `in_port` should be output on `readdata`.\n\nWrite a Verilog module that implements the above behavior.\n\n", "output": "module receive_data (\n  input [1:0] address,\n  input clk,\n  input in_port,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  wire clk_en;\n  wire data_in;\n  wire read_mux_out;\n\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {1 {(address == 0)}} & data_in;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      readdata <= 0;\n    end\n    else if (clk_en) begin\n      readdata <= {32'b0 | read_mux_out};\n    end\n  end\n\n  assign data_in = in_port;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a clock gate with the following specifications:\n\nInputs:\n- `CLK`: clock input\n- `EN`: enable input\n- `TE`: transparent enable input\n\nOutput:\n- `ENCLK`: gated clock output\n\nThe module should implement a clock gate that gates the clock input (`CLK`) with the enable input (`EN`). The gated clock output (`ENCLK`) should be high only when the enable input (`EN`) is high. Additionally, the module should have a transparent enable input (`TE`) that, when high, allows the clock input (`CLK`) to pass through to the gated clock output (`ENCLK`) regardless of the enable input (`EN`).\n\nYou must implement this module within 200 lines of Verilog code.\n\n", "output": "module clock_gate (\n    input CLK,\n    input EN,\n    input TE,\n    output ENCLK\n);\n\n    reg gated_clk;\n\n    always @ (posedge CLK) begin\n        if (EN && !TE) begin\n            gated_clk <= 1'b1;\n        end else if (TE) begin\n            gated_clk <= CLK;\n        end else begin\n            gated_clk <= 1'b0;\n        end\n    end\n\n    assign ENCLK = gated_clk & EN;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a module that slows down the internal oscillator output to a rate of approximately 0.5 Hz. The module should have four inputs and one output. The inputs are:\n\n- `rstn` : active low reset signal\n- `osc_clk` : internal oscillator clock signal\n- `led` : 8-bit output signal\n- `clk` : output clock signal\n\nThe module should have the following functionality:\n\n- The module should have a gray counter `gc1` which counts from 0 to 255 and outputs the count value on the `led` signal.\n- The module should have a counter `c_delay` which is used to slow down the internal oscillator output to a rate of approximately 0.5 Hz.\n- The counter `c_delay` should be a 23-bit register which counts from 0 to 8,388,607.\n- The internal oscillator output should be connected to the `osc_clk` signal.\n- The output clock signal `clk` should be generated by taking the most significant bit of the `c_delay` counter.\n\nWrite a verilog module that implements the above functionality.\n\n", "output": "module slow_oscillator(\n    input rstn,\n    input osc_clk,\n    output reg [7:0] led,\n    output reg clk\n);\n\n    reg [22:0] c_delay;\n    \n    // Gray counter\n    grey_counter gc1(.clk(osc_clk), .q(led));\n    \n    // Counter to slow down the internal oscillator output\n    always @(posedge osc_clk or negedge rstn) begin\n        if (~rstn) begin\n            c_delay <= 23'h000000;\n        end else begin\n            c_delay <= c_delay + 1;\n        end\n    end\n    \n    // Output clock signal\n    assign clk = c_delay[22];\n    \nendmodule"}
{"instruction": "\n\nYou are working on a project that requires the implementation of a D Flip-Flop with asynchronous reset using Verilog. You need to create a module called `DFFARX1` that takes three inputs: `D` (data input), `CLK` (clock input), and `RSTB` (asynchronous reset input), and two outputs: `Q` (output) and `QN` (complement output). The module should be implemented within 200 lines of Verilog code.\n\nYour task is to implement the `DFFARX1` module that meets the following requirements:\n\n- When `RSTB` is low, both `Q` and `QN` should be set to 0.\n- When `RSTB` is high, the output `Q` should follow the input `D` when there is a rising edge on `CLK`.\n- The complement output `QN` should always be the inverse of the output `Q`.\n\nYou should assume that all inputs and outputs are 1-bit signals.\n\n", "output": "module DFFARX1 (D,CLK,RSTB,Q,QN);\n\n input D;\n input CLK;\n input RSTB;\n output Q;\n output QN;\n\n reg Qtemp;\n\n always @(posedge CLK or negedge RSTB) begin\n   if (~RSTB) begin\n     Qtemp <= 1'b0;\n   end else begin\n     Qtemp <= D;\n   end\n end\n\n assign QN = ~Qtemp;\n assign Q = Qtemp;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a clock gate module that will take in a clock signal, an enable signal, and a test enable signal, and output an enable clock signal. The module should only allow the clock signal to pass through when both the enable signal and the test enable signal are high. You are given a code snippet to use as a starting point:\n\n```\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W31_0_3 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\ninitial $sdf_annotate(\"FPU_Interface2_ASIC_fpu_syn_constraints_clk10.tcl_GATED_KOA_2STAGE_syn.sdf\"); \n endmodule\n```\n\nYour task is to complete the module so that it meets the following requirements:\n\n1. When the enable signal and the test enable signal are both low, the output enable clock signal should be low.\n2. When the enable signal is high and the test enable signal is low, the output enable clock signal should be low.\n3. When the enable signal is low and the test enable signal is high, the output enable clock signal should be low.\n4. When both the enable signal and the test enable signal are high, the output enable clock signal should be the same as the input clock signal.\n\nYou may assume that the input signals are valid and will not change more than once per clock cycle.\n\nWrite the Verilog code for the completed module. Your solution should be within 200 lines of code.\n\n", "output": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W31_0_3 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK_reg;\n\n  always @(posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK_reg <= CLK;\n    end else begin\n      ENCLK_reg <= 1'b0;\n    end\n  end\n\n  assign ENCLK = ENCLK_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock gating module for a register. The module should have four inputs: `CLK`, `EN`, `TE`, and `ENCLK`. The `CLK` input is the clock signal, `EN` is the enable signal, `TE` is the transparent enable signal, and `ENCLK` is the gated clock output. The module should be designed such that when `EN` is high, the clock signal should be gated and passed through to the output `ENCLK`. When `EN` is low, the output should be held at its previous value, regardless of the clock signal. The `TE` signal should enable transparent mode, where the output will follow the input clock signal regardless of the `EN` signal.\n\nDesign a module in Verilog that implements the above functionality. The module should be named `clock_gate` and should have the inputs and outputs as specified above. The module should be synthesizable and should not use any non-synthesizable constructs or system tasks. You may use any Verilog constructs that are synthesizable.\n\n", "output": "module clock_gate(\n    input CLK,\n    input EN,\n    input TE,\n    output reg ENCLK\n);\n\nreg gated_clk;\n\nalways @ (posedge CLK) begin\n    if (EN & !TE) begin\n        gated_clk <= 1'b1;\n    end else begin\n        gated_clk <= 1'b0;\n    end\nend\n\nalways @ (*) begin\n    if (TE) begin\n        ENCLK = CLK;\n    end else begin\n        ENCLK = gated_clk ? CLK : ENCLK;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a digital circuit that implements a 4-bit binary counter. The counter should have a synchronous reset input, an enable input, and a clock input. The counter should output its current value on a 4-bit output bus. \n\nYour task is to design a Verilog module that implements this counter. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock input\n- `reset`: a synchronous reset input\n- `enable`: an enable input\n\nOutputs:\n- `count`: a 4-bit output bus that represents the current count value\n\nThe counter should count from 0 to 15 and then wrap around to 0. The counter should only increment when the `enable` input is high. When the `reset` input is high, the counter should be reset to 0.\n\nYou should implement this counter using only combinational logic and sequential logic (flip-flops).\n\n", "output": "module binary_counter (\n  input clk,\n  input reset,\n  input enable,\n  output [3:0] count\n);\n\n  reg [3:0] count_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_reg <= 0;\n    end else begin\n      if (enable) begin\n        if (count_reg == 4'b1111) begin\n          count_reg <= 0;\n        end else begin\n          count_reg <= count_reg + 1;\n        end\n      end\n    end\n  end\n\n  assign count = count_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder with carry-in and carry-out functionality. The module should take in two 4-bit inputs, A and B, and a carry-in signal, Cin. It should output a 4-bit sum, S, and a carry-out signal, Cout. The adder should be implemented using only combinational logic, and should be contained within a single module that is no more than 200 lines of Verilog code.\n\nThe module should be named `four_bit_adder` and should have the following inputs and outputs:\n\nInputs:\n- `A` (4-bit input)\n- `B` (4-bit input)\n- `Cin` (1-bit input)\n\nOutputs:\n- `S` (4-bit output)\n- `Cout` (1-bit output)\n\nYou may use any Verilog operators and constructs that you see fit, but you should not use any pre-defined Verilog modules or functions.\n\nWrite a Verilog module that satisfies the above requirements.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] sum;\nwire [3:0] carry;\n\nassign sum = A + B + Cin;\nassign carry = ((A & B) | (A & Cin) | (B & Cin));\n\nassign S = sum;\nassign Cout = carry[3];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements comparators for unsigned and signed numbers. \nA comparator is a digital circuit that compares two input numbers and outputs a signal indicating whether the first number is greater than, less than, or equal to the second number. \nYour module should have the following inputs and outputs:\n\nInputs: two unsigned or signed numbers (num1, num2) and a select signal (sel) that determines whether to compare them as unsigned or signed numbers.\nOutputs: three signals (eq, gt, lt), indicating whether the first number is equal to, greater than, or less than the second number.\n\nTo implement the comparators, you should use Verilog code to compare the two input numbers as unsigned or signed numbers based on the select signal. \nYou should then output the results of the comparison as the three output signals.\n\nFor the unsigned comparator, you should compare the two numbers bit by bit, starting from the most significant bit. \nIf the bits are equal, move to the next bit. If one bit is greater than the other, output the appropriate signal and terminate the comparison.\n\nFor the signed comparator, you should first check the sign of the two numbers. \nIf they have the same sign, you can compare them as unsigned numbers. \nIf they have different signs, output the appropriate signal based on the sign of the numbers and terminate the comparison.", "output": "module comparator (\n  input [31:0] num1,\n  input [31:0] num2,\n  input sel,\n  output eq,\n  output gt,\n  output lt\n);\n\n  wire signed [31:0] snum1, snum2;\n  assign snum1 = $signed(num1);\n  assign snum2 = $signed(num2);\n\n  wire [2:0] unsigned_result, signed_result;\n\n  assign unsigned_result = (num1 == num2) ? 3'b001 : (num1 > num2) ? 3'b010 : 3'b100;\n  assign signed_result = (snum1 == snum2) ? 3'b001 : (snum1 > snum2) ? 3'b010 : 3'b100;\n\n  assign {eq, gt, lt} = (sel == 0) ? unsigned_result : signed_result;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 3-input XNOR gate. The module should have three input ports (A, B, and C) and one output port (X). Additionally, the module should have four power input ports (VPB, VPWR, VGND, and VNB).\n\nYour task is to design a verilog module that meets these requirements. The module should be solvable by only one module within 200 lines of verilog code.\n\n", "output": "module xnor3 (\n    input  A   ,\n    input  B   ,\n    input  C   ,\n    output X   ,\n\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\nwire w1, w2, w3, w4, w5;\n\nand and1(w1, A, B);\nand and2(w2, A, C);\nand and3(w3, B, C);\nor or1(w4, w1, w2);\nor or2(w5, w4, w3);\nnot not1(X, w5);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple calculator that can perform basic arithmetic operations such as addition, subtraction, multiplication, and division. The calculator should have two input ports for the operands and a third input port to select the operation to be performed. The result of the operation should be output through a single output port.\n\nThe module should have the following input and output ports:\n- `input [7:0] operand1`: the first operand\n- `input [7:0] operand2`: the second operand\n- `input [1:0] operator`: the operation to be performed (00 for addition, 01 for subtraction, 10 for multiplication, and 11 for division)\n- `output [15:0] result`: the result of the operation\n\nYou may assume that the operands are always positive integers and that division by zero will not occur. You may also assume that the result of any operation will always fit within 16 bits.\n\n", "output": "module calculator(operand1, operand2, operator, result);\n\n\tinput [7:0] operand1, operand2;\n\tinput [1:0] operator;\n\toutput [15:0] result;\n\n\treg [15:0] temp_result;\n\n\talways @ (*)\n\tbegin\n\t\tcase (operator)\n\t\t\t2'b00: temp_result = operand1 + operand2; // addition\n\t\t\t2'b01: temp_result = operand1 - operand2; // subtraction\n\t\t\t2'b10: temp_result = operand1 * operand2; // multiplication\n\t\t\t2'b11: temp_result = operand1 / operand2; // division\n\t\tendcase\n\tend\n\n\tassign result = temp_result;\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that generates a random 8-bit number and stores it in a register. The module should have an input `clk` which is a 50 MHz clock signal and an output `out` which is the 8-bit random number. The module should generate a new random number on every rising edge of the clock signal. \n\n", "output": "module random_generator(\n  input clk,\n  output reg [7:0] out\n);\n\n  integer seed; // seed for random number generator\n\n  // initialize seed with time\n  initial begin\n    seed = $time;\n  end\n\n  // generate new random number on every rising edge of the clock\n  always @(posedge clk) begin\n    out = $random(seed);\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary counter with synchronous reset and enable signals. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: The clock signal.\n- `RST`: The synchronous reset signal. When high, the counter should reset to 0.\n- `EN`: The enable signal. When low, the counter should not increment.\n\nOutputs:\n- `Q`: A 4-bit output representing the current count value.\n\nThe module should have the following behavior:\n- On the rising edge of `CLK`, if `RST` is high, the counter should reset to 0.\n- On the rising edge of `CLK`, if `RST` is low and `EN` is high, the counter should increment by 1.\n- The counter should wrap around to 0 when it reaches 15 (0b1111).\n\nWrite a Verilog module that implements this behavior, using no more than 200 lines of code.\n\n", "output": "module binary_counter_4bit(\n  input CLK, RST, EN,\n  output reg [3:0] Q\n);\n\n  always @(posedge CLK) begin\n    if (RST) begin\n      Q <= 4'b0;\n    end else if (EN) begin\n      Q <= Q + 1;\n      if (Q == 4'hF) begin\n        Q <= 4'h0;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been given a Verilog code snippet that defines a module named `sky130_fd_sc_ms__a221o_1`. This module has one output port named `X` and five input ports named `A1`, `A2`, `B1`, `B2`, and `C1`. The module also instantiates another module named `sky130_fd_sc_ms__a221o` and connects its input and output ports to the input and output ports of the `sky130_fd_sc_ms__a221o_1` module.\n\nYour task is to write the Verilog code for the `sky130_fd_sc_ms__a221o` module. This module should have the same input and output ports as the `sky130_fd_sc_ms__a221o_1` module. The functionality of the `sky130_fd_sc_ms__a221o` module should be as follows:\n\n- If `A1` is high and `A2` is low, then `X` should be set to the value of `B1`.\n- If `A1` is low and `A2` is high, then `X` should be set to the value of `B2`.\n- If `A1` and `A2` are both high, then `X` should be set to the value of `C1`.\n- If `A1` and `A2` are both low, then `X` should be set to 0.\n\nWrite the Verilog code for the `sky130_fd_sc_ms__a221o` module that implements the above functionality. Your code should be self-contained and should not reference any other modules or variables.\n\n", "output": "module sky130_fd_sc_ms__a221o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    assign X = (A1 & ~A2) ? B1 :\n               (~A1 & A2) ? B2 :\n               (A1 & A2) ? C1 : 1'b0;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a pipelined D flip-flop module using combinational logic, \nwhere the module should have one input port for the clock signal, one input port for the data signal, and one output port for the output signal. \nThe output signal should change according to the input data signal on the rising edge of the clock signal. \nThe module must be designed using only logic gates and no sequential elements such as flip-flops or registers. \nUse pipeline structure to achieve this functionality.", "output": "module pipelined_d_ff (\n    input clk,\n    input d,\n    output reg q\n);\n\nreg d1, d2, d3;\n\nalways @(posedge clk) begin\n    d1 <= d;\nend\n\nalways @(posedge clk) begin\n    d2 <= d1;\nend\n\nalways @(posedge clk) begin\n    d3 <= d2;\nend\n\nalways @(posedge clk) begin\n    q <= d3;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-to-1 multiplexer (MUX4_1) using the following inputs and outputs:\n\nInputs:\n- x0: 1-bit input\n- x1: 1-bit input\n- x2: 1-bit input\n- x3: 1-bit input\n- s0: 1-bit select input\n- s1: 1-bit select input\n\nOutput:\n- y: 1-bit output\n\nThe MUX4_1 should select one of the four inputs (x0, x1, x2, or x3) based on the values of s0 and s1, and output the selected input to y. The selection should follow the following truth table:\n\ns1 | s0 | y\n---|---|---\n0 | 0 | x0\n0 | 1 | x1\n1 | 0 | x2\n1 | 1 | x3\n\nYou should implement the MUX4_1 module within 200 lines of Verilog code.\n\n", "output": "module MUX4_1 (\n    input x0,\n    input x1,\n    input x2,\n    input x3,\n    input s0,\n    input s1,\n    output reg y\n);\n\nalways @(*) begin\n    case ({s1, s0})\n        2'b00: y = x0;\n        2'b01: y = x1;\n        2'b10: y = x2;\n        2'b11: y = x3;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that implements a D flip-flop with a positive edge-triggered clock. The module should have three inputs: D (the data input), C (the clock input), and a reset input. The output of the module should be Q (the output of the flip-flop).\n\nYou are required to implement the D flip-flop using the following code snippet:\n\n```\nmodule  \\$_DFF_P_ (input D, C, output Q);\n   DFF _TECHMAP_REPLACE_\n     (.q(Q), .d(D), .ck(C));\nendmodule\n```\n\nYou must replace the `_TECHMAP_REPLACE_` placeholder with your own implementation of the D flip-flop using only Verilog code and within 200 lines of code. Your implementation should meet the following requirements:\n\n- The D flip-flop should be positive edge-triggered. This means that the output changes only on the rising edge of the clock signal.\n- The D flip-flop should have a reset input that asynchronously sets the output to 0 when the reset input is high.\n- The D flip-flop should have a synchronous set input that sets the output to 1 when the set input is high and the clock signal is high.\n\nYour implementation should be well-structured and easy to read, with clear and concise comments explaining the purpose of each section of code.\n\n", "output": "module dff_posedge_reset_set (input D, input C, input reset, input set, output Q);\n  reg Q;\n\n  always @(posedge C or posedge reset or posedge set) begin\n    if (reset) begin\n      Q <= 0;\n    end else if (set) begin\n      Q <= 1;\n    end else begin\n      Q <= D;\n    end\n  end\nendmodule"}
{"instruction": "\n\nCreate a Verilog module for a 4-bit binary counter with synchronous reset and enable. The counter should have a clock input and a reset input, both active high. It should also have an enable input, active high, that when asserted allows the counter to count on each clock cycle. When the enable input is de-asserted, the counter should freeze at its current value. The counter should output its current value on four output wires, with the least significant bit on the first wire and the most significant bit on the fourth wire.\n\n", "output": "module binary_counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 2x2 Karnaugh map function f with inputs x[1:4] and outputs y. The Karnaugh map is as follows:\n\n// x[1]x[2] // x[3]x[4]\n00 01 11 10\n// 00 | 1 | 0 | 0 | 1 |\n// 01 | 0 | 0 | 0 | 0 |\n// 11 | 1 | 1 | 1 | 0 |\n// 10 | 1 | 1 | 0 | 1 |\n\nThe module should take 4 input bits and produce a single output bit based on the Karnaugh map. Implement the function using logic gates, and minimize the number of gates used.", "output": "module karnaugh_map (\n  input [3:0] x,\n  output y\n);\n  wire w1, w2, w3, w4;\n  assign w1 = x[0] & x[1];\n  assign w2 = x[2] & x[3];\n  assign w3 = x[1] & x[3];\n  assign w4 = x[0] & x[2];\n  assign y = w1 | w2 | w3 | w4;\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit priority encoder. The module should have four inputs (I3, I2, I1, and I0) and two outputs (V and D). V should be 1 if any of the inputs are high, and D should be the binary value of the highest input. For example, if I3 is high, D should be 3 (0011 in binary).", "output": "module priority_encoder (\n    input [3:0] I,\n    output V,\n    output [1:0] D\n);\n\n    assign V = |I; // OR all inputs together to check if any are high\n    \n    always @* begin\n        casez(I) // case statement to determine highest input\n            4'b0001: D = 2'b00;\n            4'b0010: D = 2'b01;\n            4'b0100: D = 2'b10;\n            4'b1000: D = 2'b11;\n            default: D = 2'b00; // default case if no inputs are high\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit input and outputs a 2-bit value based on the following conditions:\n\n- If the input is 0, 1, or 2, output 00.\n- If the input is 3 or 4, output 01.\n- If the input is 5 or 6, output 10.\n- If the input is 7, output 11.\n\nDesign a Verilog module that implements this functionality using a case statement.\n\nThe module should have the following ports:\n\n- `input clk`: the clock signal\n- `input [3:0] b`: the 4-bit input\n- `output [1:0] so`: the 2-bit output\n\n", "output": "module two_bit_output(clk, b, so);\ninput clk;\ninput [3:0] b;\noutput [1:0] so;\nreg [1:0] so;\n\n\talways @(posedge clk)\n\t\tcase (b)\n\t\t\t4'b0000, 4'b0001, 4'b0010: so = 2'b00;\n\t\t\t4'b0011, 4'b0100: so = 2'b01;\n\t\t\t4'b0101, 4'b0110: so = 2'b10;\n\t\t\t4'b0111: so = 2'b11;\n\t\t\tdefault: so = 2'b00;\n\t\tendcase\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a 2-bit wide, 4-to-1 multiplexer. The module should have two select inputs, sel1 and sel0, and four data inputs, d0, d1, d2, and d3. When sel1sel0=00, choose d0. When sel1sel0=01, choose d1. When sel1sel0=10, choose d2. When sel1sel0=11, choose d3.", "output": "module mux_4to1_2bit (\n  input [1:0] sel1_sel0,\n  input [3:0] d0_d1_d2_d3,\n  output reg [1:0] out\n);\n\nalways @(*)\n  case(sel1_sel0)\n    2'b00: out = d0_d1_d2_d3[1:0];\n    2'b01: out = d0_d1_d2_d3[3:2];\n    2'b10: out = d0_d1_d2_d3[5:4];\n    2'b11: out = d0_d1_d2_d3[7:6];\n  endcase\n\nendmodule\n"}
{"instruction": "Create a half adder module that is capable of adding two bits together, without any carry-in. The module should produce both the sum and carry-out as output ports. However, you are only allowed to use a single XOR gate and a single AND gate to complete this task.", "output": "module half_adder(\n    input a, b,\n    output cout, sum\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module for a digital circuit. The module should take in one data signal `A` and one control signal `TE_B`, and output one data signal `Z`. Additionally, the module should have four power inputs: `VPB`, `VPWR`, `VGND`, and `VNB`. \n\nThe module should be named `data_buffer` and should be written in Verilog. The `A` signal should be 8 bits wide, and the `Z` signal should be 16 bits wide. The `TE_B` signal should be a single bit.\n\nThe module should perform the following functions:\n- When `TE_B` is high, the output `Z` should be equal to the input `A`.\n- When `TE_B` is low, the output `Z` should be 0.\n\nYou can assume that the power inputs will always be valid and that no other modules will be used in the implementation of this module.\n\n", "output": "module data_buffer (\n    input [7:0] A,\n    output reg [15:0] Z,\n    input TE_B,\n    input VPB,\n    input VPWR,\n    input VGND,\n    input VNB\n);\n\nalways @(*) begin\n    if (TE_B) begin\n        Z = {A, 8'b0};\n    end else begin\n        Z = 16'b0;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a Verilog module for a block memory generator. The module should have the following inputs and outputs:\n\nInputs:\n- `addra`: a 14-bit input representing the memory address\n- `clka`: a clock input\n- `dina`: a 12-bit input representing the data to be written to memory\n- `wea`: a write enable input\n\nOutputs:\n- `douta`: a 12-bit output representing the data read from memory at the specified address\n\nYou should use the provided code snippet as a starting point to create the module. Your module should be able to synthesize correctly using the `title2_blk_mem_gen_v8_3_5_synth` module.\n\nYour module should be able to store and retrieve data from memory correctly. If `wea` is high, the module should write the data from `dina` to the memory location specified by `addra`. If `wea` is low, the module should read the data from the memory location specified by `addra` and output it on `douta`.\n\nYou may assume that the memory is 2^14 words deep and each word is 12 bits wide.\n\nYour module should be no longer than 200 lines of Verilog code.\n\n", "output": "module block_mem_generator\n   (douta,\n    addra,\n    clka,\n    dina,\n    wea);\n    \n  output reg [11:0] douta;\n  input [13:0] addra;\n  input clka;\n  input [11:0] dina;\n  input wea;\n\n  reg [11:0] mem [0:16383];\n  \n  always @(posedge clka) begin\n    if(wea) begin\n      mem[addra] <= dina;\n    end else begin\n      douta <= mem[addra];\n    end\n  end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a D Flip-Flop with asynchronous reset and set signals, as well as an enable input. The module should have the following ports:\n\n- `D`: Data input\n- `C`: Clock input\n- `E`: Enable input\n- `R`: Asynchronous reset input\n- `S`: Asynchronous set input\n- `Q`: Output\n\nThe module should operate as follows:\n\n- When the reset input (`R`) is asserted (active low), the output (`Q`) should be set to 0.\n- When the set input (`S`) is asserted (active low), the output (`Q`) should be set to 1.\n- When the enable input (`E`) is asserted (active high), the output (`Q`) should follow the data input (`D`) on the rising edge of the clock input (`C`).\n- When the enable input (`E`) is de-asserted (active low), the output (`Q`) should hold its previous value regardless of the data input (`D`) or clock input (`C`).\n\nYou are required to implement the module within 200 lines of Verilog code. Your implementation should be correct and efficient.\n\n", "output": "module dffnsre(\n    output reg Q,\n    input D,\n    input C,\n    input E,\n    input R,\n    input S\n);\n    parameter [0:0] INIT = 1'b0;\n    initial Q = INIT;\n\n    always @(negedge C or negedge S or negedge R)\n    begin\n        if (!R)\n            Q <= 1'b0;\n        else if (!S)\n            Q <= 1'b1;\n        else if (E)\n            Q <= D;\n    end\n        \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that performs a bitwise XOR operation on two 8-bit inputs. The module should have two 8-bit input ports, \"A\" and \"B\", and one 8-bit output port, \"Y\". The module should also have a control input port, \"C\", which determines whether the XOR operation should be performed or not. If \"C\" is high, the XOR operation should be performed and the result should be output on \"Y\". If \"C\" is low, the output on \"Y\" should be the same as the input on \"A\". \n\nDesign the verilog module for the above requirements. \n\n", "output": "module bitwise_xor(input [7:0] A, input [7:0] B, input C, output reg [7:0] Y);\n\nalways @(*) begin\n    if(C) begin\n        Y = A ^ B;\n    end\n    else begin\n        Y = A;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit barrel shifter. The circuit should have two inputs (D and S) and one output (Q). The input D should be a 4-bit value, and the input S should be a 2-bit value that specifies the shift direction (00 for no shift, 01 for left shift, 10 for right shift, and 11 for circular shift). The output Q should be the shifted value of input D.", "output": "module barrel_shifter (\n    input [3:0] D,\n    input [1:0] S,\n    output reg [3:0] Q\n);\n\nalways @(*) begin\n    case(S)\n        2'b00: Q = D; // no shift\n        2'b01: Q = {D[2:0], 0}; // left shift\n        2'b10: Q = {0, D[3:1]}; // right shift\n        2'b11: Q = {D[1:0], D[3:2]}; // circular shift\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that will take two 13-bit inputs, A and B, and output two 27-bit values, Y and Z. The module should implement a multiplier that multiplies A and B together, and outputs the result as two separate values, Y and Z. \n\nThe module should also include a clock input, \"clk\", and should operate on the rising edge of the clock. \n\nYou should create a testbench for your module that verifies its functionality for various test cases. The testbench should include a comparison of the output of your module with expected values for each test case. \n\nYour module should be named \"multiplier\", and should have the following inputs and outputs:\n\nInputs:\n- A (13-bit)\n- B (13-bit)\n- clk (1-bit)\n\nOutputs:\n- Y (27-bit)\n- Z (27-bit)\n\n", "output": "module multiplier(\n    input clk,\n    input [12:0] A,\n    input [12:0] B,\n    output [26:0] Y,\n    output [26:0] Z\n);\n\nreg [25:0] Y_reg;\nreg [25:0] Z_reg;\nreg [12:0] A_reg;\nreg [12:0] B_reg;\nreg [10:0] i;\n\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    if(i == 0) begin\n        Y_reg <= 0;\n        Z_reg <= 0;\n    end\n    else begin\n        if(B_reg[0] == 1) begin\n            Y_reg <= Y_reg + (A_reg << (i-1));\n            Z_reg <= Z_reg + ((~A_reg + 1) << (i-1));\n        end\n    end\n    i <= i + 1;\nend\n\nassign Y = Y_reg;\nassign Z = Z_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a round and saturation block. \nA round and saturation block is a type of digital circuit that can be used to limit the range of a signal and avoid overflow or underflow. \nThe inputs to the circuit are the signal to be processed and the maximum and minimum values that the signal can take.\nYour module should have the following inputs and outputs:\n\nInputs: \n- signal: the input signal to be processed\n- max_val: the maximum value that the signal can take\n- min_val: the minimum value that the signal can take\n\nOutputs: \n- out: the processed signal, rounded and saturated to fall within the range defined by max_val and min_val.\n\nYour module should implement the following functionality:\n\n- If the input signal is greater than max_val, the output signal should be set to max_val.\n- If the input signal is less than min_val, the output signal should be set to min_val.\n- If the input signal is between min_val and max_val, the output signal should be rounded to the nearest integer.\n\nTo implement the round and saturation block, you should use Verilog code to compare the input signal to max_val and min_val. \nYou should then use conditional statements to set the output signal to the appropriate value, either max_val or min_val, if the input signal is outside the range. \nIf the input signal is within the range, you should use Verilog code to round the signal to the nearest integer. \nFinally, you should assign the processed signal to the output.", "output": "module round_sat (\n  input signed [15:0] signal,\n  input signed [15:0] max_val,\n  input signed [15:0] min_val,\n  output signed [15:0] out\n);\n\n  always @(*) begin\n    if (signal > max_val) begin\n      out = max_val;\n    end else if (signal < min_val) begin\n      out = min_val;\n    end else begin\n      out = $signed(signal + 0.5);\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in two 8-bit vectors and outputs their product. The module should be named \"vec_multiplier\". The inputs are named \"vector1\" and \"vector2\" and the output is named \"product\". The module should have a reset input \"rst\" which resets the output to 0. The module should have a clock input \"clk\" which is used to synchronize the computation of the product. Assume that both input vectors are signed numbers in 2's complement format. \n\nWrite the verilog code for the \"vec_multiplier\" module.\n\n", "output": "module vec_multiplier (\n  input clk, rst,\n  input signed [7:0] vector1,\n  input signed [7:0] vector2,\n  output reg signed [15:0] product\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      product <= 0;\n    end\n    else begin\n      product <= vector1 * vector2;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary adder. The module should have two 4-bit input ports (A and B) and one 4-bit output port (S) that represents the sum of A and B. The module should also have a single input port (Cin) and a single output port (Cout) that represent the carry-in and carry-out bits, respectively. The module should be synchronous, with a single clock input port (clk) and a single asynchronous reset input port (rst_n).\n\nDesign the module and provide the verilog code. \n\n", "output": "module binary_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input clk,\n  input rst_n,\n  output [3:0] S,\n  output Cout\n);\n\n  reg [3:0] S;\n  reg Cout;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      S <= 4'b0;\n      Cout <= 1'b0;\n    end else begin\n      {Cout, S} <= A + B + Cin;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module for a 4-bit synchronous counter that counts from 0 to 9 and then starts over. The counter should have a synchronous reset input and the counting should be enabled by a separate input. The output should be displayed on four separate LEDs connected to the four output ports of the module. Assume that the LEDs turn on when the corresponding output port is set to 1.\n\n", "output": "module sync_counter(\n    input clk, // clock input\n    input reset, // synchronous reset input\n    input enable, // counting enable input\n    output reg [3:0] count // 4-bit output\n);\n\nalways @(posedge clk) begin\n    if(reset) begin\n        count <= 4'b0; // reset to 0\n    end else if(enable) begin\n        if(count == 4'b1001) begin\n            count <= 4'b0; // reset to 0 after counting to 9\n        end else begin\n            count <= count + 1; // increment counter\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit multiplier. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` (1-bit): the clock signal\n- `a` (4-bit): the first operand\n- `b` (4-bit): the second operand\n\nOutputs:\n- `result` (8-bit): the result of multiplying `a` and `b`\n\nThe module should use registers to store the intermediate values, and should only update the output on the rising edge of the clock signal.\n\nWrite the verilog code for the multiplier module.\n\n", "output": "module multiplier(\n  input clk,\n  input [3:0] a,\n  input [3:0] b,\n  output [7:0] result\n);\n\n  reg [7:0] product_reg;   // register to hold the product\n  reg [3:0] a_reg;         // register to hold a\n  reg [3:0] b_reg;         // register to hold b\n\n  always @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n    product_reg <= a_reg * b_reg;   // multiply a and b and store in product_reg\n  end\n\n  assign result = product_reg;   // assign the product to the output\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit binary adder. The module should take two 4-bit inputs, A and B, and produce a 4-bit output, S, which is the sum of A and B. The module should also have a carry-out output, Cout, which is high if the sum overflows beyond 4 bits.\n\nYour module should be named \"four_bit_adder\" and should take the following inputs and outputs:\n\nInputs:\n- A: a 4-bit input\n- B: a 4-bit input\n- Cin: a carry-in input\n\nOutputs:\n- S: a 4-bit output representing the sum of A and B\n- Cout: a carry-out output\n\nYour module should be designed using structural Verilog, and should consist of only combinational logic (i.e. no registers or flip-flops). You may use any gates or primitive modules available in Verilog.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] X;\nwire [3:0] Y;\nwire [3:0] Z;\n\nassign X = A ^ B;\nassign Y = A & B;\nassign Z = Cin & X;\n\nassign S = X ^ Cin;\nassign Cout = (Y | Z) | (X & Cin);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a bitwise full adder operation on three input bits A, B, and CIN. The module should output two bits, COUT and SUM, representing the carry-out and sum of the operation, respectively. The module should also take in four input signals, VPB, VPWR, VGND, and VNB, representing the power supply and ground voltages.\n\nDesign a Verilog module named 'bitwise_full_adder' that takes in the following inputs and outputs:\n- Inputs:\n  - A (1-bit)\n  - B (1-bit)\n  - CIN (1-bit)\n  - VPB (1-bit)\n  - VPWR (1-bit)\n  - VGND (1-bit)\n  - VNB (1-bit)\n- Outputs:\n  - COUT (1-bit)\n  - SUM (1-bit)\n\nThe module should implement the following logic:\n- SUM = (A ^ B) ^ CIN\n- COUT = (A & B) | (CIN & (A ^ B))\n\nEnsure that your module can be simulated correctly and passes the following test cases:\n\nTest Case 1:\n- Inputs: A=0, B=0, CIN=0, VPB=1, VPWR=1, VGND=0, VNB=0\n- Expected Outputs: SUM=0, COUT=0\n\nTest Case 2:\n- Inputs: A=1, B=1, CIN=1, VPB=1, VPWR=1, VGND=0, VNB=0\n- Expected Outputs: SUM=1, COUT=1\n\nTest Case 3:\n- Inputs: A=1, B=0, CIN=1, VPB=1, VPWR=1, VGND=0, VNB=0\n- Expected Outputs: SUM=0, COUT=1\n\n", "output": "module bitwise_full_adder (\n    input  A   ,\n    input  B   ,\n    input  CIN ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB ,\n    output COUT,\n    output SUM \n);\n\n    assign SUM = (A ^ B) ^ CIN;\n    assign COUT = (A & B) | (CIN & (A ^ B));\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit binary-to-Gray code converter. The module should have a 4-bit input representing the binary value, and a 4-bit output representing the Gray code value. The Gray code value should be generated using the XOR operation between adjacent bits of the binary value.", "output": "module binary_to_gray (\n    input [3:0] binary,\n    output [3:0] gray\n);\n\nassign gray[0] = binary[0];\nassign gray[1] = binary[0] ^ binary[1];\nassign gray[2] = binary[1] ^ binary[2];\nassign gray[3] = binary[2] ^ binary[3];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a 4-bit input and outputs the corresponding 2-bit binary representation of the input value. For example, if the input is 5 (binary 0101), the output should be 01. You are not allowed to use any arithmetic operators, such as + or -, in your solution. You can only use bitwise operators.\n\nDesign a verilog module that satisfies the above requirements. Your module should be named \"bin_to_two_bit\" and have the following inputs and outputs:\n\nInputs:\n- `in` (4-bit input)\n\nOutputs:\n- `out` (2-bit output)\n\nYou can assume that the input will always be a valid 4-bit binary number.\n\n", "output": "module bin_to_two_bit(input [3:0] in, output [1:0] out);\n\t\n\twire [1:0] in_2bit;\n\t\n\tassign in_2bit[0] = in[1] | in[3];\n\tassign in_2bit[1] = in[2] | in[3];\n\t\n\tassign out = in_2bit;\n\t\nendmodule"}
{"instruction": "Please act as a professional Verilog coder. Create a module that implements a 4-to-1 multiplexer using a case statement. The module should have four input ports (in0, in1, in2, in3), two select input ports (sel0, sel1) and one output port (out). The select input ports (sel0, sel1) are used to select which input port is connected to the output port (out). The module should use a case statement to select the appropriate input port based on the select input ports (sel0, sel1). If sel0=0 and sel1=0, in0 should be connected to out. If sel0=0 and sel1=1, in1 should be connected to out. If sel0=1 and sel1=0, in2 should be connected to out. If sel0=1 and sel1=1, in3 should be connected to out.", "output": "module mux_4to1_case (\n  input [3:0] in0,\n  input [3:0] in1,\n  input [3:0] in2,\n  input [3:0] in3,\n  input sel0,\n  input sel1,\n  output reg [3:0] out\n);\n\n  always @ (sel0 or sel1 or in0 or in1 or in2 or in3)\n    case ({sel1, sel0})\n      2'b00: out <= in0;\n      2'b01: out <= in1;\n      2'b10: out <= in2;\n      2'b11: out <= in3;\n    endcase\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a crystal oscillator interface. \nA crystal oscillator is a type of electronic oscillator circuit that uses the mechanical resonance of a vibrating crystal to create an electrical signal with a precise frequency. \nThe crystal oscillator interface circuit is used to connect the crystal oscillator to the rest of the digital circuitry in a system. \nIt provides the necessary connections and circuitry to generate a clock signal from the oscillator's output.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- `osc_in`: the input signal from the crystal oscillator\n- `reset`: a reset signal that initializes the circuit\n- `clk_enable`: a signal that enables or disables the output clock signal\n\nOutputs: \n- `clk_out`: the output clock signal generated by the circuit\n\nThe module should also have the following parameters:\n\n- `osc_freq`: the frequency of the crystal oscillator\n- `clk_div`: the clock divider value that determines the output clock frequency\n\nYour module should implement the following functionality:\n\n- The circuit should generate a clock signal with a frequency that is a multiple of the crystal oscillator frequency.\n- The output clock frequency should be determined by the `clk_div` parameter.\n- The circuit should provide a reset signal that initializes the output clock signal.\n- The circuit should provide a `clk_enable` signal that can be used to enable or disable the output clock signal.\n\nTo implement the crystal oscillator interface, you should use Verilog code to connect the oscillator input signal to a frequency divider circuit. \nThe frequency divider circuit should divide the oscillator frequency by the `clk_div` parameter to generate the output clock frequency. \nYou should also implement circuitry to provide the reset and `clk_enable` signals as specified in the inputs and outputs.", "output": "module crystal_oscillator_interface (\n  input osc_in,\n  input reset,\n  input clk_enable,\n  output reg clk_out\n);\n\nparameter osc_freq = 50e6; // frequency of the crystal oscillator\nparameter clk_div = 2; // clock divider value\n\nreg [31:0] counter;\n\nalways @ (posedge osc_in or posedge reset) begin\n  if (reset) begin\n    counter <= 0;\n    clk_out <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter == osc_freq / (2 * clk_div)) begin\n      counter <= 0;\n      if (clk_enable) begin\n        clk_out <= ~clk_out;\n      end\n    end\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-input AND gate. The module should have the following ports and supplies:\n\n- `Y`: output port for the AND gate\n- `A`, `B`, `C`, `D`: input ports for the AND gate\n- `VPWR`, `VGND`, `VPB`, `VNB`: module supplies\n\nImplement the AND gate using only NOR gates. You may use as many NOR gates as necessary.\n\nWrite a verilog module that meets these specifications. \n\n", "output": "module nor_and(\n    Y, A, B, C, D,\n    VPWR, VGND, VPB, VNB\n);\n\n    // Module ports\n    output Y;\n    input A, B, C, D;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire nor1_out, nor2_out, nor3_out;\n\n    // NOR gates\n    nor nor1(nor1_out, A, B);\n    nor nor2(nor2_out, C, D);\n    nor nor3(Y, nor1_out, nor2_out);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in 5 inputs and produces 1 output. The module should have the following interface:\n\n```\nmodule my_module(\n    input A,\n    input B,\n    input C,\n    input D,\n    input E,\n    output reg X\n);\n```\n\nThe module should perform the following operation:\n\n1. If A is 0, X should be set to 0.\n2. If A is 1, B should be added to C and the result should be stored in a temporary variable T.\n3. If T is greater than or equal to D, X should be set to 1.\n4. If T is less than D, E should be added to T and the result should be stored in a temporary variable T2.\n5. If T2 is greater than or equal to D, X should be set to 1.\n6. If T2 is less than D, X should be set to 0.\n\nWrite a Verilog module that implements the above operation. Your solution should be contained within a single module that is no more than 200 lines of code.\n\n", "output": "module my_module(\n    input A,\n    input B,\n    input C,\n    input D,\n    input E,\n    output reg X\n);\n\n    reg [31:0] T, T2;\n\n    always @(*) begin\n        if (A == 0) begin\n            X = 0;\n        end else begin\n            T = B + C;\n            if (T >= D) begin\n                X = 1;\n            end else begin\n                T2 = E + T;\n                if (T2 >= D) begin\n                    X = 1;\n                end else begin\n                    X = 0;\n                end\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two inputs, `A` and `B`, and outputs the maximum value between them. You should implement this using a conditional operator.\n\nCreate a verilog module named `max_value` that takes in two 8-bit inputs, `A` and `B`, and outputs an 8-bit value `MAX`. If `A` is greater than or equal to `B`, then `MAX` should be assigned the value of `A`. Otherwise, `MAX` should be assigned the value of `B`.\n\nEnsure that your module has the following ports:\n- `A`: an 8-bit input\n- `B`: an 8-bit input\n- `MAX`: an 8-bit output\n\n", "output": "module max_value(\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] MAX\n);\n\n    always @(*) begin\n        MAX = (A >= B) ? A : B;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are designing an ALU (Arithmetic Logic Unit) for a NIOS system. The module `nios_system_alu_carry_out` has four inputs: `address`, `clk`, `in_port`, and `reset_n`. It also has one output: `readdata`. The `address` input is a 2-bit address bus used to select the ALU operation. The `clk` input is the system clock. The `in_port` input is the data input to the ALU. The `reset_n` input is an active-low reset signal. The `readdata` output is the result of the ALU operation.\n\nThe module has the following internal signals:\n- `clk_en`: a wire that is high when the clock is enabled\n- `data_in`: a wire that is connected to the `in_port` input\n- `read_mux_out`: a wire that is the output of a multiplexer that selects between the `data_in` input and a constant value of 0, depending on the value of `address`.\n\nThe module has one register `readdata` that stores the output of the ALU operation. The `readdata` register is updated on every rising edge of the clock when `clk_en` is high. If `reset_n` is low, `readdata` is set to 0.\n\nImplement the `nios_system_alu_carry_out` module using Verilog.\n\n", "output": "module nios_system_alu_carry_out (\n  input [1:0] address,\n  input clk,\n  input in_port,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  wire clk_en = 1;\n  wire data_in = in_port;\n  wire read_mux_out = (address == 0) ? data_in : 32'b0;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0, read_mux_out};\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a clock divider circuit that takes in a clock signal and outputs a slower clock signal. The module should have one input port for the clock signal and one output port for the slower clock signal. The slower clock signal should have a frequency that is half of the input clock signal.\n\nYour module should be named \"clk_divider\" and should be implemented in less than 200 lines of Verilog code. Assume that the input clock signal has a frequency of 50 MHz and that the slower clock signal should have a duty cycle of 50%.\n\n", "output": "module clk_divider(\n    input clk,\n    output reg slower_clk\n);\n\nreg [24:0] counter;\n\nalways @(posedge clk) begin\n    counter <= counter + 1;\n    if (counter == 1250000) begin\n        slower_clk <= ~slower_clk;\n        counter <= 0;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit counter with a synchronous reset and a load input. The module should have a 4-bit output (COUNT), a 1-bit input (LOAD), a 1-bit input (CLK), and a 1-bit input (RESET). When RESET is high, the COUNT should be reset to 0. When LOAD is high, the COUNT should be loaded with the value on the DATA_IN input. When CLK is high, the COUNT should be incremented by 1.", "output": "module counter_with_load_reset (\n    input [3:0] DATA_IN,\n    input LOAD,\n    input CLK,\n    input RESET,\n    output reg [3:0] COUNT\n);\n\n    always @(posedge CLK, negedge RESET) begin\n        if(RESET == 0) begin\n            COUNT <= 4'b0;\n        end\n        else if(LOAD == 1) begin\n            COUNT <= DATA_IN;\n        end\n        else begin\n            COUNT <= COUNT + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 16-bit barrel shifter. The module should have two 16-bit inputs (A and B) and one 4-bit input (shift). The module should shift A left or right by the number of bits specified by the shift input. If shift[3] is high, the module should perform a logical shift. If shift[3] is low, the module should perform an arithmetic shift. The output should be equal to A shifted by the number of bits specified by the shift input, or B if shift is 0.", "output": "module barrel_shifter (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] shift,\n    output [15:0] out\n);\n\n    assign out = (shift == 0) ? B :\n                (shift[3] == 1) ? (shift[2:0] == 0 ? A : {A[shift[2:0]-1:0], 0}) :\n                (A[15] == 0 ? {A[15:shift[2]], A[shift[2]-1:0]} : {16'd0, A[15:shift[2]]});\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module that takes in a clock signal, a data input, a reset signal and outputs a data output. The input data is stored in a D flip-flop and is passed through a wire to the output. Your module should be named \"data_dff\" and should have the following ports:\n\n- `clk`: the clock signal\n- `din`: the input data\n- `dout`: the output data\n- `reset_n`: the active-low reset signal\n\nUse the following code snippet as a starting point:\n\n```\nmodule data_dff (\n    // your code here\n);\n\n    // your code here\n\nendmodule\n```\n\n", "output": "module data_dff (\n    clk,\n    din,\n    dout,\n    reset_n\n);\n\n    input clk;\n    input din;\n    output dout;\n    input reset_n;\n\n    wire [0:0] wire_dffpipe3_q;\n\n    DE0_Nano_SOPC_altpll_sys_dffpipe_l2c dffpipe3 (\n        .clock(clk),\n        .clrn(reset_n),\n        .d(din),\n        .q(wire_dffpipe3_q)\n    );\n\n    assign dout = wire_dffpipe3_q;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary counter with a synchronous reset signal. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: the clock signal\n- `RST`: the reset signal\n\nOutputs:\n- `Q`: the 4-bit binary count\n\nThe counter should increment on the rising edge of the clock signal (`CLK`) and reset to 0 on the rising edge of the reset signal (`RST`).\n\nImplement the module using only D flip-flops and combinational logic gates.\n\n", "output": "module binary_counter (\n    input CLK,\n    input RST,\n    output [3:0] Q\n);\n\n    // Local signals\n    wire [3:0] Q_next;\n\n    // D flip-flops\n    reg [3:0] Q_reg;\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q_reg <= 4'b0000;\n        end else begin\n            Q_reg <= Q_next;\n        end\n    end\n\n    // Combinational logic\n    assign Q_next = (Q_reg == 4'b1111) ? 4'b0000 : Q_reg + 1'b1;\n    assign Q = Q_reg;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a simple 2-bit counter. The module should have two inputs, a clock input, and a reset input. When the reset input is high, the counter should be reset to 0. When the clock input is high, the counter should increment by 1. The module should have one output, a 2-bit binary number that represents the current count.\n\nDesign a Verilog module that implements this simple 2-bit counter. \n\n", "output": "module counter(\n    input clock,\n    input reset,\n    output reg [1:0] count\n);\n\n    always @(posedge clock) begin\n        if (reset) begin\n            count <= 2'b00;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a 4-to-1 multiplexer using the SkyWater 130nm process technology. The multiplexer has four data inputs, one output, and two select inputs. The output should be the value of the selected input. The input and output voltage levels are specified as follows:\n\n- VPWR: 1.8V\n- VGND: 0V\n- VPB: 1.8V\n- VNB: -1.8V\n\nYou need to implement the multiplexer in a single Verilog module that has the following inputs and output:\n\n- `Z`: output of the multiplexer\n- `D`: 4-bit input data bus\n- `S`: 4-bit select bus\n- `VPWR`: power supply voltage\n- `VGND`: ground voltage\n- `VPB`: positive power supply voltage\n- `VNB`: negative power supply voltage\n\nYou should assume that the inputs `D` and `S` are valid and stable during operation. Your design should use the SkyWater 130nm process technology and should be implemented in no more than 200 lines of Verilog code.\n\n", "output": "module sky130_fd_sc_hdll__muxb4to1 (\n    Z   ,\n    D   ,\n    S   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output       Z   ;\n    input  [3:0] D   ;\n    input  [3:0] S   ;\n    input        VPWR;\n    input        VGND;\n    input        VPB ;\n    input        VNB ;\n\n    reg [3:0] Z_reg;\n\n    always @(*) begin\n        case(S)\n            4'b0000: Z_reg = D[0];\n            4'b0001: Z_reg = D[1];\n            4'b0010: Z_reg = D[2];\n            4'b0011: Z_reg = D[3];\n            default: Z_reg = 4'bxxxx;\n        endcase\n    end\n\n    assign Z = Z_reg;\n\nendmodule"}
{"instruction": "\n\nYou are working on a project that requires you to design a module in Verilog that takes three input signals A1, A2, and B1, and produces a single output signal X. You need to write a Verilog module that implements this functionality and can be synthesized into hardware. \n\nThe module should be named \"three_input_gate\" and should have the following interface:\n\n```\nmodule three_input_gate (\n    input A1,\n    input A2,\n    input B1,\n    output X\n);\n```\n\nThe module should implement the following logic:\n\n- If A1 is high and A2 is low, X should be high.\n- If A1 is low and A2 is high, X should be high.\n- If B1 is high, X should be low.\n- If A1 and A2 are both high or both low, X should be low.\n\nWrite a Verilog module that implements this functionality and can be synthesized into hardware. The module should be self-contained and should not rely on any other Verilog modules or libraries. Your solution should be within 200 lines of Verilog code.\n\n", "output": "module three_input_gate (\n    input A1,\n    input A2,\n    input B1,\n    output X\n);\n\n    wire A1_not;\n    wire A2_not;\n    wire A1_and_A2;\n    wire A1_nand_A2;\n    wire B1_not;\n    wire A1_and_A2_nand_B1;\n    \n    assign A1_not = ~A1;\n    assign A2_not = ~A2;\n    assign A1_and_A2 = A1 & A2;\n    assign A1_nand_A2 = ~(A1 & A2);\n    assign B1_not = ~B1;\n    assign A1_and_A2_nand_B1 = ~(A1 & A2 & B1);\n\n    assign X = (A1 & A2_not) | (A1_not & A2) | (B1_not & A1_and_A2_nand_B1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 3-bit input and outputs a single bit. The output should be the inverse of the input. \n\nDesign a Verilog module that implements this behavior. The module should be named `INV3` and should have the following ports:\n\n- `in`: a 3-bit input\n- `out`: a single bit output\n\nThe module should be implemented using basic gates such as AND, OR, NOT, and XOR. You are not allowed to use any pre-existing Verilog modules or operators.\n\nYour implementation should be within 200 lines of Verilog code.\n\n", "output": "module INV3 (\n    input [2:0] in,\n    output out\n);\n\nwire [2:0] not_in;\nassign not_in = ~in;\n\nwire and_out;\nassign and_out = not_in[0] & not_in[1] & not_in[2];\n\nassign out = and_out;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a digital circuit using Verilog that implements a D-type flip-flop with asynchronous set and clear inputs. The circuit should have the following inputs and outputs:\n\n- `CLK`: a clock input\n- `D`: a data input\n- `SET`: an asynchronous set input\n- `CLR`: an asynchronous clear input\n- `Q`: the output\n- `Q_N`: the complement of the output\n\nYour circuit should be implemented in a single module of no more than 200 lines of Verilog code. Your module should be named `d_ff_as`.\n\nWrite a Verilog module `d_ff_as` that implements the above specifications.\n\n", "output": "module d_ff_as (\n    input CLK,\n    input D,\n    input SET,\n    input CLR,\n    output Q,\n    output Q_N\n);\n\n    wire Q_int;\n    sky130_fd_sc_ls__sdfxbp_1 d_ff (\n        .CLK(CLK),\n        .D(D),\n        .SCD(SET),\n        .SCE(CLR),\n        .Q(Q_int),\n        .Q_N(Q_N)\n    );\n    assign Q = Q_int;\n\nendmodule"}
{"instruction": "\n\nYou have been given a Verilog module named `sky130_fd_sc_lp__xnor3_1` that implements a 3-input XNOR gate. The module has eight inputs, namely `A`, `B`, `C`, `VPWR`, `VGND`, `VPB`, `VNB`, and one output `X`.\n\nYour task is to write a Verilog module named `xnor3_2` which implements the same functionality as `sky130_fd_sc_lp__xnor3_1` but has only three inputs `A`, `B`, and `C` and one output `X`. The `xnor3_2` module should use only basic logic gates such as AND, OR, and NOT gates.\n\n", "output": "module xnor3_2 (\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    wire AB_xor = A ^ B;\n    wire ABC_xor = AB_xor ^ C;\n    wire ABC_xor_not = ~ABC_xor;\n    assign X = ABC_xor_not;\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module called \"BrzSlice_1_18_16\" which takes three inputs and three outputs. The input \"out_0r\" is a single bit, while \"inp_0a\" is a single bit and \"inp_0d\" is a 18-bit vector. The output \"out_0a\" is a single bit and \"out_0d\" is a single bit. Your task is to implement this module by writing Verilog code that correctly assigns the output signals based on the input signals.\n\nSpecifically, the output signal \"inp_0r\" should be assigned the value of \"out_0r\". The output signal \"out_0a\" should be assigned the value of \"inp_0a\". The output signal \"out_0d\" should be assigned the 17th bit of \"inp_0d\".\n\nWrite a Verilog module called \"BrzSlice_1_18_16\" that implements this functionality.\n\n", "output": "module BrzSlice_1_18_16 (\n  out_0r, out_0a, out_0d,\n  inp_0r, inp_0a, inp_0d\n);\n  input out_0r;\n  output out_0a;\n  output out_0d;\n  output inp_0r;\n  input inp_0a;\n  input [17:0] inp_0d;\n  assign inp_0r = out_0r;\n  assign out_0a = inp_0a;\n  assign out_0d = inp_0d[16];\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a module for a 2-input OR gate using the sky130_fd_sc_lp library. The module should have the following inputs and outputs:\n\n- Inputs: A, B, VPWR, VGND, VPB, VNB\n- Outputs: X\n\nThe inputs VPWR, VGND, VPB, and VNB are the power and ground supplies for the module. The module should be able to operate with a supply voltage of 1.8V.\n\nYour task is to complete the module definition for sky130_fd_sc_lp__or2. The module should implement a standard 2-input OR gate. The module should have a single output X, which is high if either input A or input B is high.\n\nYou should assume that the inputs A and B are valid digital signals, and will only take on values of 0 or 1. You should also assume that the power and ground supplies are stable and have no noise.\n\nYour solution should include the complete module definition for sky130_fd_sc_lp__or2.\n\n", "output": "module sky130_fd_sc_lp__or2 (\n    X   ,\n    A   ,\n    B   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A   ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign X = A | B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit input signal `in_signal` and produces a 3-bit output signal `out_signal`.\nThe output signal is to be generated according to the following rules:\n- If the input signal is less than 4, the output signal should be equal to the input signal.\n- If the input signal is between 4 and 7 (inclusive), the output signal should be equal to the input signal minus 1.\n- If the input signal is greater than 7, the output signal should be equal to the input signal minus 2.\n\nWrite a Verilog module that implements the above rules and takes in a single input signal `in_signal` and produces a single output signal `out_signal`.\n\n", "output": "module signal_converter(\n    input [3:0] in_signal,\n    output reg [2:0] out_signal\n);\n\nalways @(*) begin\n    if (in_signal < 4) begin\n        out_signal = in_signal;\n    end else if (in_signal < 8) begin\n        out_signal = in_signal - 1;\n    end else begin\n        out_signal = in_signal - 2;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in two 8-bit inputs, A and B, and outputs the maximum value between the two inputs. If A is greater than B, output A. Otherwise, output B.", "output": "module max_value (\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] max\n);\n\n    always @* begin\n        if (A > B) begin\n            max = A;\n        end\n        else begin\n            max = B;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a power-on reset (POR) circuit. \nA POR circuit is a type of digital circuit that generates a reset signal when the power supply to the circuit is turned on. \nThe reset signal is used to initialize the circuit to a known state, which is important for ensuring proper operation of the circuit. \nYour module should have the following inputs and outputs:\n\nInputs: a power supply signal (VDD)\nOutputs: a reset signal (RST)\nThe module should also have the following parameters:\n\nt: the time it takes for the power supply to stabilize (i.e., the time it takes for the voltage to reach a steady state)\nYour module should implement the following functionality:\n\nWhen the power supply signal (VDD) is first applied, the reset signal (RST) should be asserted (i.e., set to 1) for a period of time equal to t.\nAfter the reset signal has been asserted for t, it should be de-asserted (i.e., set to 0).\nTo implement the POR circuit, you should use Verilog code to define the timing of the reset signal as a function of the power supply signal. \nYou should then use this function to generate the reset signal when the power supply is first turned on.", "output": "module POR (\n  input VDD,\n  output RST\n);\n\nparameter t = 10; // time it takes for power supply to stabilize (in ns)\n\nreg [31:0] count; // counter to keep track of time\nreg POR_active; // flag to indicate if POR is active\n\nalways @(posedge VDD) begin\n  count <= 0; // reset counter\n  POR_active <= 1; // set POR flag\nend\n\nalways @(posedge clk) begin\n  if (POR_active && (count < t)) begin\n    RST <= 1; // assert reset signal\n    count <= count + 1; // increment counter\n  end else begin\n    RST <= 0; // de-assert reset signal\n    POR_active <= 0; // clear POR flag\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit binary to gray code converter. The module should have a 4-bit input (D) and a 4-bit output (G). The output should be the gray code equivalent of the input.\n\nA gray code is a binary numeral system where two successive values differ in only one bit. For example, the binary equivalent of 2 is 0010 and the gray code equivalent is 0011. The gray code equivalent of 3 is 0011 and the gray code equivalent of 4 is 0111.\n\nDesign a verilog module that takes a 4-bit binary input (D) and outputs its 4-bit gray code equivalent (G). You are not allowed to use any built-in gray code conversion functions or look-up tables.\n\n", "output": "module binary_to_gray(\n    input [3:0] D,\n    output [3:0] G\n);\n\n    assign G[0] = D[0];\n    assign G[1] = D[0] ^ D[1];\n    assign G[2] = D[1] ^ D[2];\n    assign G[3] = D[2] ^ D[3];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that performs binary addition of two 1-bit inputs xi and yi, and generates a 1-bit sum output Si and a 1-bit carry output Co. The module should be named \"one_bit_adder\" and should be written in Verilog.\n\nThe module should have the following ports:\n- xi: a 1-bit input\n- yi: a 1-bit input\n- Si: a 1-bit output representing the sum of the inputs\n- Co: a 1-bit output representing the carry generated by the addition\n\nYou should use the following truth table to implement the module:\n- xi = 0, yi = 0: Si = 0, Co = 0\n- xi = 0, yi = 1: Si = 1, Co = 0\n- xi = 1, yi = 0: Si = 1, Co = 0\n- xi = 1, yi = 1: Si = 0, Co = 1\n\nWrite a Verilog module \"one_bit_adder\" that implements the above truth table and satisfies the requirements mentioned above. The module should be self-contained and should not require any external modules.\n\n", "output": "module one_bit_adder(\n    input xi,\n    input yi,\n    output Si,\n    output Co\n);\n\n    assign Si = xi ^ yi;\n    assign Co = xi & yi;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-to-1 multiplexer. The module should have 4 input ports (A, B, C, and D) and 2 select ports (S0 and S1) to select one of the four inputs. The output port should be named Y. The module should be named \"mux4to1\".\n\nWrite the verilog code for the \"mux4to1\" module that meets the above requirements.\n\n", "output": "module mux4to1(\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire w1, w2, w3;\n\n    assign w1 = (~S1 & ~S0) ? A : (~S1 & S0) ? B : (S1 & ~S0) ? C : D;\n    assign w2 = (S1 & ~S0) ? C : D;\n    assign w3 = (S1 & S0) ? D : w2;\n\n    assign Y = (S1 & S0) ? w1 : w3;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2:1 multiplexer with a priority input. The module should have two inputs (A and B) and one priority input (P). When the priority input is high, the output should be A. When the priority input is low, the output should be B.", "output": "module mux_2to1_priority (\n    input [3:0] A,\n    input [3:0] B,\n    input P,\n    output reg [3:0] Y\n);\n\nalways @(*) begin\n    if (P) begin\n        Y <= A;\n    end else begin\n        Y <= B;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a circuit that takes in a 4-bit binary number and outputs the 2's complement of that number.", "output": "module twos_complement (\n    input [3:0] in,\n    output reg [3:0] out);\n    \n    assign out = ~in + 1;\n    \nendmodule\n\nmodule top_module (\n    input [3:0] in,\n    output reg [3:0] out);\n    \n    twos_complement tc(in, out);\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a pull-down resistor. A pull-down resistor is used to ensure that a signal remains at a logical low level when no input is connected to it. The module should have a single input and output, both of which are one-bit wide. The output should be connected to the input through the pull-down resistor.\n\nYour module should be able to pass the following testbench:\n\n```\nmodule testbench;\n\n   reg\tin;\n   wire\tout;\n\n   pull_down pd(in, out);\n\n   initial begin\n      in = 0;\n      #100 if (out !== 1'b0) begin\n\t $display(\"FAILED -- 0 out = %b\", out);\n\t $finish;\n      end\n\n      in = 1;\n      #100 if (out !== 1'b0) begin\n\t $display(\"FAILED -- 1 out = %b\", out);\n\t $finish;\n      end\n\n      $display(\"PASSED\");\n      $finish;\n   end // initial begin\n\nendmodule\n```\n\nYou are only allowed to use one module and the module should not be more than 200 lines of code.\n\n", "output": "module pull_down (\n   input in,\n   output out\n);\n\n   wire bit;\n   PULLDOWN pd(bit);\n\n   reg\tdrv;\n   assign bit = drv;\n\n   always @ (in) begin\n      drv = in;\n   end\n\n   assign out = bit;\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, a clock delay inverter is used to delay the clock signal by a specific amount of time. In this problem, you are asked to design a clock delay inverter module using Verilog HDL.\n\nThe module should have two inputs: a clock signal and a delay value. The output of the module should be the delayed clock signal. The delay value should be specified in terms of the number of clock cycles by which the output signal should be delayed.\n\nYou should assume that the clock signal is a square wave with a 50% duty cycle and a period of 10 ns. The delay value should be an integer between 1 and 10, representing the number of clock cycles by which the output signal should be delayed.\n\nYour task is to implement a Verilog module that satisfies the following requirements:\n\n- The module should be named \"clock_delay_inverter\".\n- The module should have two inputs: a clock signal named \"clk\" and a delay value named \"delay\".\n- The module should have one output: a delayed clock signal named \"clk_delayed\".\n- The module should use a single always block to implement the clock delay inverter.\n- The module should be self-contained and should not rely on any external modules or components.\n- The module should be no more than 200 lines of Verilog code.\n\n", "output": "module clock_delay_inverter(\n    input clk,\n    input [3:0] delay,\n    output reg clk_delayed\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (counter == delay) begin\n        clk_delayed <= ~clk_delayed;\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4:1 multiplexer. The module should have four 4-bit input ports (A, B, C, and D), and a 2-bit select port (S0, S1) that selects which input port to output to the single 4-bit output port (Y). The select port should be active high, meaning that if S0 is high and S1 is low, the output should be the value of input port B.\n\nDesign a verilog module that meets these requirements. \n\n", "output": "module mux4to1_4bit(Y, A, B, C, D, S0, S1);\n\n    input [3:0] A, B, C, D;\n    input S0, S1;\n    output [3:0] Y;\n    \n    wire [3:0] AB, CD, Y_temp;\n    \n    assign AB = (S0 & ~S1) ? B : A;\n    assign CD = (S0 & S1) ? D : C;\n    assign Y_temp = (S0 | S1) ? CD : AB;\n    assign Y = Y_temp;\n    \nendmodule"}
{"instruction": "\n\nIn digital systems, data is often represented as a sequence of bits. In some cases, it is necessary to rotate the bits in a sequence by a certain number of positions. In this problem, you are required to implement a module that performs a circular shift of a 32-bit input data by 1 position to the left, and outputs the 48-bit result. \n\nYou are given a code snippet that defines a Verilog module called `Eblock`. This module has one 32-bit input port called `R` and one 48-bit output port called `Rout`. The input data is represented by the `R` port, and the output data should be represented by the `Rout` port. \n\nYour task is to modify the `assign` statement in the `Eblock` module to perform the circular shift of the input data by one position to the left, and assign the result to the `Rout` port. \n\nNote that the circular shift should be performed in a way that the bit that was originally in the most significant position becomes the least significant bit after the shift. \n\n", "output": "module Eblock(\n    input [0:31] R,\n    output [0:47] Rout\n    );\n    \n    assign Rout = {R[31], R[0:30]} << 1;\n    \nendmodule"}
{"instruction": "\n\nYou have been hired by a company that is developing a new hardware design. The design includes a module called `my_module` which is responsible for performing a specific function. The company has provided you with a code snippet for the `my_module` module, but they are having trouble getting it to work properly. Your task is to debug the code and ensure that it performs the intended function.\n\nThe `my_module` module takes four inputs: `A`, `B`, `C`, and `D`. It also has one output, `out`. The goal of the module is to output the value of `A` if `B` is 1, and the value of `C` if `B` is 0. Additionally, if `D` is 1, the output should be inverted (i.e. if `B` is 1 and `D` is 1, the output should be the inverse of `A`).\n\nYou should only modify the code within the `my_module` module. You may not add any new modules or change the inputs or outputs.\n\nYour solution should be contained entirely within the `my_module` module and should be no more than 200 lines of verilog code.\n\n", "output": "module my_module(input A, B, C, D, output out);\n    wire temp;\n    assign temp = (B == 1) ? A : C;\n    assign out = (D == 1) ? ~temp : temp;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an image or video processing block. \nThe block should perform a specific function such as filtering, transforming, or compressing an image or video. \nYour module should have the following inputs and outputs:\n\nInputs: a set of n input signals (in1, in2, ..., inn)\nOutputs: a set of m output signals (out1, out2, ..., outm)\nThe module should also have the following parameters:\n\nn: the number of input signals\nm: the number of output signals\np: any additional parameters needed for the specific processing function\nYour module should implement the following functionality:\n\nPerform the specific image or video processing function using Verilog code.\nThe input signals should be processed based on the specific function and the output signals should be the result of the processing.\nTo implement the processing block, you should use Verilog code to define the specific processing function as a set of operations on the input signals. \nYou should then use these operations to transform the input signals into the desired output signals.\nFinally, you should use the output signals to store the processed image or video data.", "output": "module ProcessingBlock (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 8; // number of input signals\nparameter m = 8; // number of output signals\nparameter p = 2; // additional parameters needed for specific processing function\n\n// Specific image or video processing function\n// Define the operations on the input signals to transform them into the desired output signals\n// Store the processed image or video data in the output signals\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 2-to-1 multiplexer. The module should have two inputs, `A` and `B`, and one output, `Z`. The output should be the same as the input selected by the control input `S`. If `S` is 0, then `Z` should be equal to `A`. If `S` is 1, then `Z` should be equal to `B`. You are not allowed to use the `if` statement or any other conditional constructs in your design. You need to use only the `buf` primitive to implement the multiplexer.\n\nTo help you get started, here is the skeleton of the verilog module:\n\n```\nmodule mux2to1 (A, B, S, Z);\ninput A, B, S;\noutput Z;\n\n// your code goes here\n\nendmodule\n```\n\n", "output": "module mux2to1 (A, B, S, Z);\ninput A, B, S;\noutput Z;\n\nbuf buf_A (Z, A);\nbuf buf_B (Z, B);\n\n// select A if S is 0, B if S is 1\nassign Z = (~S & A) | (S & B);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a system ID for a System-on-Chip (SoC) design. The module should have three input ports: `address`, `clock`, and `reset_n`. The `address` port is a 32-bit input that specifies the address of the requested system ID. The `clock` port is a standard Verilog clock input, and the `reset_n` port is an active-low reset input. The module should have one output port: `readdata`, which is a 32-bit output that contains the system ID data corresponding to the input address.\n\nThe system ID data should be stored in the module and should be accessible via the `address` input. Specifically, when the `address` input is equal to `32'h0`, the `readdata` output should contain the value `32'hDEADBEEF`. When the `address` input is equal to `32'h4`, the `readdata` output should contain the value `32'hCAFEBABE`. For all other values of `address`, the `readdata` output should be set to `32'h00000000`.\n\nThe module should operate synchronously with the `clock` input, and should only update the `readdata` output on the rising edge of the clock. The module should also support an active-low reset input (`reset_n`), which should reset the `readdata` output to `32'h00000000`.\n\nImplement the `soc_design_SystemID` module in Verilog, following the specifications above.\n\n", "output": "module soc_design_SystemID (\n  input [31:0] address,\n  input clock,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  always @(posedge clock) begin\n    if (!reset_n) begin\n      readdata <= 32'h00000000;\n    end else begin\n      case (address)\n        32'h0: readdata <= 32'hDEADBEEF;\n        32'h4: readdata <= 32'hCAFEBABE;\n        default: readdata <= 32'h00000000;\n      endcase\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-input multiplexer with a select input that can choose between four different inputs. The module should have five inputs: four data inputs and one select input. The select input should be a 2-bit input that can select between the four data inputs. The output of the module should be the selected data input.", "output": "module four_input_mux (\n    input [3:0] data_in_0,\n    input [3:0] data_in_1,\n    input [3:0] data_in_2,\n    input [3:0] data_in_3,\n    input [1:0] select,\n    output reg [3:0] data_out\n);\n\nalways @(*) begin\n    case (select)\n        2'b00: data_out = data_in_0;\n        2'b01: data_out = data_in_1;\n        2'b10: data_out = data_in_2;\n        2'b11: data_out = data_in_3;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with implementing a Verilog module that performs a 2:1 multiplexer. The module should have the following inputs and outputs:\n\nInputs:\n- A0: a single bit input\n- A1: a single bit input\n- S: a single bit input representing the select line\n- VPWR: a power supply input\n- VGND: a ground input\n- VPB: a power supply input\n- VNB: a ground input\n\nOutputs:\n- X: a single bit output representing the selected input\n\nYou should use the following module as a base for your implementation:\n\n```\nmodule sky130_fd_sc_hdll__mux2_12 (\n    X   ,\n    A0  ,\n    A1  ,\n    S   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A0  ;\n    input  A1  ;\n    input  S   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hdll__mux2 base (\n        .X(X),\n        .A0(A0),\n        .A1(A1),\n        .S(S),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n```\n\nImplement the `sky130_fd_sc_hdll__mux2_12` module using primitive gates such as `and`, `or`, `not`, and `xnor`. Make sure to handle all possible input combinations.\n\n", "output": "module my_mux2 (\n    X   ,\n    A0  ,\n    A1  ,\n    S   \n);\n\n    output X   ;\n    input  A0  ;\n    input  A1  ;\n    input  S   ;\n\n    wire notS;\n    wire and1;\n    wire and2;\n\n    not #(1) inv1(notS, S);\n    and #(1) gate1(and1, A0, notS);\n    and #(1) gate2(and2, A1, S);\n    or #(1) gate3(X, and1, and2);\n\nendmodule"}
{"instruction": "\nYou are tasked to design a verilog module for a 4-bit synchronous up-counter with asynchronous reset. The counter should have two input ports, `clk` and `rst`, and one output port, `count`. The counter should increment on every rising edge of the clock signal, and reset to 0 on the falling edge of the reset signal. The counter should be designed using sequential logic.\n\nWrite a verilog module for the 4-bit synchronous up-counter with asynchronous reset.\n\n", "output": "module up_counter(clk, rst, count);\n  input clk;\n  input rst;\n  output reg [3:0] count;\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit input and outputs the Gray code equivalent. The module should have one input, a 4-bit binary number (D[3:0]), and one output, a 4-bit Gray code number (G[3:0]). The module should convert the binary input to Gray code using the algorithm for converting binary to Gray code.", "output": "module gray_code (\n    input [3:0] D,\n    output reg [3:0] G\n);\n\nalways @ (D) begin\n    G[3] = D[3];\n    G[2] = D[3] ^ D[2];\n    G[1] = D[2] ^ D[1];\n    G[0] = D[1] ^ D[0];\nend\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog code snippet for a module `gcd_zynq_snick_auto_pc_0_axi_protocol_converter_v2_1_17_b2s_cmd_translator`. Your task is to implement a new module `my_module` that takes the same inputs and outputs as `gcd_zynq_snick_auto_pc_0_axi_protocol_converter_v2_1_17_b2s_cmd_translator`, but performs a different functionality.\n\nThe `my_module` should have two inputs: `input [15:0] a` and `input [15:0] b`. The module should output the greatest common divisor (GCD) of `a` and `b` to `output [15:0] gcd`. You can assume that `a` and `b` are both non-negative integers.\n\nYour implementation should be within 200 lines of Verilog code and should only use combinational logic.\n\n", "output": "module my_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] gcd\n);\n\nwire [15:0] r;\nassign r = a >= b ? a - b : b - a;\nassign gcd = (r == 0) ? (a == 0 ? b : a) : my_module(r, a >= b ? b : a);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module to implement a simple 4-bit adder. The module should have two 4-bit inputs (A and B) and one 4-bit output (S). The module should also have a single input (Cin) and a single output (Cout), both of which should be 1-bit. The adder should implement the following logic:\n\n- The 4-bit output S should be the sum of the two 4-bit inputs A and B, plus the value of Cin.\n- The 1-bit output Cout should be 1 if the sum of A, B, and Cin is greater than 15 (i.e. the output S is a 5-bit number).\n\nYou should implement this module using only basic verilog constructs (i.e. no pre-defined adder modules).\n\n", "output": "module four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  // Internal variables\n  reg [3:0] sum;\n  reg carry;\n\n  // Implement the 4-bit adder\n  always @(*) begin\n    sum = A + B + Cin;\n    carry = (sum > 15) ? 1 : 0;\n  end\n\n  // Assign outputs\n  assign S = sum;\n  assign Cout = carry;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-input NOR gate. The module should have the following inputs and outputs:\n\nInputs:\n- IN1: 1-bit input\n- IN2: 1-bit input\n- IN3: 1-bit input\n- IN4: 1-bit input\n- VDD: 1-bit input\n- VSS: 1-bit input\n\nOutputs:\n- QN: 1-bit output\n\nThe module should be named NOR4X0 and should be completely self-contained, meaning that it should not rely on any other modules.\n\nYour task is to write a Verilog module that implements the NOR4X0 module. The module should take in four inputs, IN1, IN2, IN3, IN4, and output the NOR of these inputs to QN. The module should also have inputs for VDD and VSS, which are the power and ground connections, respectively.\n\nThe NOR4X0 module should implement the following logic:\n\n- QN should be the NOR of IN1, IN2, IN3, and IN4.\n\nYou should write a Verilog module that implements the NOR4X0 module within 200 lines of code.\n\n", "output": "module NOR4X0 (input IN1, IN2, IN3, IN4, output QN, input VDD, VSS);\n\n  wire n1, n2, n3;\n\n  assign n1 = ~(IN1 | IN2);\n  assign n2 = ~(IN3 | IN4);\n  assign n3 = ~(n1 | n2);\n\n  assign QN = n3;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in 4 input signals A1, A2, B1, and C1, and produces a single output signal X. You need to implement the module using the following logic:\n\n- A1 and A2 are inputs to an OR gate.\n- The output of the OR gate is connected to one input of an AND gate.\n- The other two inputs of the AND gate are B1 and C1.\n- The output of the AND gate is connected to the input of a buffer.\n- The output of the buffer is the output signal X.\n\nImplement the above logic in a verilog module named \"logic_module\". Ensure that the module has the correct input and output ports, and that the module is synthesizable.\n\n", "output": "module logic_module (\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    output reg X\n);\n\n    // Local signals\n    wire or0_out   ;\n    wire and0_out_X;\n\n    //  Name  Output      Other arguments\n    or  or0  (or0_out   , A2, A1         );\n    and and0 (and0_out_X, or0_out, B1, C1);\n    buf buf0 (X         , and0_out_X     );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 9-bit control signal `ctrl` and outputs a 4-bit signal `td_mode`. The control signal `ctrl` is used to select one of eight possible values for `td_mode`. The mapping of control signal values to `td_mode` values is as follows:\n\n| Control Signal | td_mode |\n| :------------: | :-----: |\n|     000        |  0000   |\n|     001        |  1000   |\n|     010        |  0100   |\n|     011        |  1100   |\n|     100        |  0010   |\n|     101        |  1010   |\n|     110        |  0101   |\n|     111        |  1111   |\n\nYour module should be named `td_mode_selector` and should take in the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a synchronous reset signal\n- `ctrl`: a 9-bit control signal\n\nOutputs:\n- `td_mode`: a 4-bit signal representing the selected `td_mode` value\n\nYour module should be implemented using behavioral Verilog and should be no more than 200 lines of code.\n\n", "output": "module td_mode_selector (\n  input clk,\n  input rst,\n  input [8:0] ctrl,\n  output reg [3:0] td_mode\n);\n\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      td_mode <= 4'b0000;\n    end else begin\n      case (ctrl[8:6])\n        3'b000: td_mode <= 4'b0000;\n        3'b001: td_mode <= 4'b1000;\n        3'b010: td_mode <= 4'b0100;\n        3'b011: td_mode <= 4'b1100;\n        3'b100: td_mode <= 4'b0010;\n        3'b101: td_mode <= 4'b1010;\n        3'b110: td_mode <= 4'b0101;\n        3'b111: td_mode <= 4'b1111;\n        default: td_mode <= 4'b0000;\n      endcase\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary counter. The counter should have a synchronous reset input and a clock input. The counter should count from 0 to 15 and then reset back to 0. The counter output should be displayed on four output wires, with each wire representing a single bit of the counter output. Write the Verilog code for the counter module.\n\n\n", "output": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if(rst) begin\n      count <= 4'b0000;\n    end else begin\n      if(count == 4'b1111) begin\n        count <= 4'b0000;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nIn digital electronics, a multiplexer (MUX) is a device that selects one of several input signals and forwards the selected input into a single output line. A MUX has n input lines and a single output line. It also has a select line, which determines which input line is connected to the output line. The select line is a binary number with m bits, where 2^m = n. \n\nIn this problem, you are asked to implement a 2:1 MUX using Verilog. The module should have the following inputs and outputs:\n\nInputs:\n- `sel` (1-bit): the select line that determines which input is selected.\n- `in0` (1-bit): the first input.\n- `in1` (1-bit): the second input.\n\nOutputs:\n- `out` (1-bit): the output of the MUX.\n\nYour implementation should be done in a single module with no more than 200 lines of Verilog code. You may not use any built-in Verilog operators or functions that implement a MUX (such as `?:`).\n\n", "output": "module mux_2to1(\n    input sel,\n    input in0,\n    input in1,\n    output out\n    );\n    \n    wire not_sel;\n    assign not_sel = ~sel;\n    \n    wire and0;\n    assign and0 = in0 & not_sel;\n    \n    wire and1;\n    assign and1 = in1 & sel;\n    \n    assign out = and0 | and1;\n    \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit bidirectional data port. The module should have two input ports, in and dir, and two output ports, out and dout. The output of the module is assigned to out based on the value of in. If dir = 0, then out = in. If dir = 1, then out = {a,b,c,d} and dout = {d,c,b,a}.", "output": "module bidirectional_data_port (\n  input clk,\n  input reset,\n  input [3:0] in,\n  input dir,\n  output reg [3:0] out,\n  output reg [3:0] dout\n);\n\n  always @(posedge clk, negedge reset) begin\n    if (!reset) begin\n      out <= 4'b0;\n      dout <= 4'b0;\n    end else begin\n      if (dir == 1) begin\n        out <= {in[3], in[2], in[1], in[0]};\n        dout <= {in[0], in[1], in[2], in[3]};\n      end else begin\n        out <= in;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "Design a new module that combines the functionality of an AND gate and an OR gate. The module should have three input ports and one output port. Two inputs should be used for the AND operation, and the third input should be used for the OR operation. The output should be the result of the OR operation between the two AND outputs.", "output": "module and_or_gate(\n    input a,\n    input b,\n    input c,\n    output reg out\n);\n\n    always @ (a, b, c) begin\n        out = (a & b) | c;\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a module that counts the number of '1's in a 4-bit input vector using a combinational circuit. The output should be a 2-bit binary number representing the number of '1's in the input vector. You can use any combinational logic gates to implement the circuit.", "output": "module population_count_4bit (\n  input [3:0] in,\n  output reg [1:0] out\n);\n\n  always @* begin\n    case(in)\n      4'b0000: out = 2'b00;\n      4'b0001: out = 2'b01;\n      4'b0010: out = 2'b01;\n      4'b0011: out = 2'b10;\n      4'b0100: out = 2'b01;\n      4'b0101: out = 2'b10;\n      4'b0110: out = 2'b10;\n      4'b0111: out = 2'b11;\n      4'b1000: out = 2'b01;\n      4'b1001: out = 2'b10;\n      4'b1010: out = 2'b10;\n      4'b1011: out = 2'b11;\n      4'b1100: out = 2'b10;\n      4'b1101: out = 2'b11;\n      4'b1110: out = 2'b11;\n      4'b1111: out = 2'b11;\n    endcase\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 4-to-1 multiplexer. The module should have four input ports, each with a single bit, and a select port that is two bits wide. The output of the module should be a single bit that is the value of the selected input.\n\nThe module should be named \"mux_4to1\" and should be contained within a single Verilog file that is no more than 200 lines long. You should use the \"always\" block to implement the logic of the module.\n\nYou may assume that the input values will be either 0 or 1 and that the select value will be a binary number between 0 and 3. If the select value is outside this range, the output value should be 0.\n\n", "output": "module mux_4to1(\n    input [3:0] data_in,\n    input [1:0] select,\n    output reg out\n);\n\nalways @*\nbegin\n    case (select)\n        2'b00: out = data_in[0];\n        2'b01: out = data_in[1];\n        2'b10: out = data_in[2];\n        2'b11: out = data_in[3];\n        default: out = 0;\n    endcase\nend\n\nendmodule"}
{"instruction": "Design a priority encoder that can detect the first high bit in an 8-bit binary number. The module should have an 8-bit input port and a 3-bit output port. If there are no high bits in the input vector, the output should be 3'b000. You can only use combinational logic gates to complete this task.", "output": "module priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos );\n\n    always @(*) begin\n        case(in)\n            8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000:\n                pos = 3'b000;\n            8'b00000011, 8'b00000101, 8'b00001001, 8'b00010001, 8'b00100001, 8'b01000001, 8'b10000001:\n                pos = 3'b001;\n            8'b00000111, 8'b00001111, 8'b00011111, 8'b00111111, 8'b01111111, 8'b11111111:\n                pos = 3'b010;\n            default:\n                pos = 3'b000;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that performs a 4-bit binary to Gray code conversion. The module should have the following inputs and outputs:\n\nInputs:\n- `in`: a 4-bit binary input\n- `clk`: a clock input\n\nOutputs:\n- `out`: a 4-bit Gray code output\n\nImplement the module using Verilog code. Assume that the clock input is a 50MHz clock signal. You can assume that the initial binary input is 0000.\n\n", "output": "module bin2gray (\n    input [3:0] in,\n    input clk,\n    output reg [3:0] out\n);\n\nalways @(posedge clk) begin\n    out[0] <= in[0];\n    out[1] <= in[0] ^ in[1];\n    out[2] <= in[1] ^ in[2];\n    out[3] <= in[2] ^ in[3];\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-to-16 decoder with active-low outputs. The module should have two inputs, a 2-bit binary value (A, B) and an active-high enable input (EN). The module should have 16 outputs (Y0 - Y15), where only one output should be active-low at a time based on the input value of A, B, and EN. Hint: Use a case statement to implement the decoder logic.", "output": "module decoder_4to16 (\n    input [1:0] A, B,\n    input EN,\n    output reg [15:0] Y\n);\n\nalways @ (A or B or EN) begin\n    case ({A,B})\n        2'b00: Y = EN ? 16'b1111111111111110 : 16'b1111111111111111;\n        2'b01: Y = EN ? 16'b1111111111111101 : 16'b1111111111111111;\n        2'b10: Y = EN ? 16'b1111111111111011 : 16'b1111111111111111;\n        2'b11: Y = EN ? 16'b1111111111110111 : 16'b1111111111111111;\n        default: Y = 16'b1111111111111111;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a gated D flip-flop with an enable signal and a clock input. The module should take in three inputs: CLK, EN, and TE. CLK is the clock input, EN is the enable signal, and TE is the data input. The module should output a signal called ENCLK, which is the gated output of the D flip-flop.\n\nYour module should be named \"gated_d_ff_en\" and should be contained within 200 lines of Verilog code. The module should use the following syntax:\n\n```\nmodule gated_d_ff_en (CLK, EN, TE, ENCLK);\n  input CLK, EN, TE;\n  output ENCLK;\n\n  // Your code here\n\nendmodule\n```\n\nThe module should implement the following functionality:\n- When EN is high, the D flip-flop should be enabled and should output the value of TE on the rising edge of CLK.\n- When EN is low, the output of the D flip-flop should be held at its previous value.\n- The output of the D flip-flop should be gated by EN, such that when EN is low, the output should be held at its previous value regardless of the value of TE.\n\nYour implementation should be efficient and should not use any unnecessary logic or resources.\n\n", "output": "module gated_d_ff_en (CLK, EN, TE, ENCLK);\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK_reg;\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      ENCLK_reg <= TE;\n    end\n  end\n\n  assign ENCLK = EN ? ENCLK_reg : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 4-bit inputs (A and B) and outputs a 4-bit result (Z). The output should be the result of adding the two inputs together. If the result is greater than 15, the output should be saturated to 15. The module should have the following interface:\n\nInputs:\n- A: 4-bit input\n- B: 4-bit input\n\nOutputs:\n- Z: 4-bit output\n\nYour module should be named \"adder_4bit\".\n\nYou can assume that the inputs will always be valid 4-bit values (0-15) and that the module will be used in a larger system.\n\n", "output": "module adder_4bit (\n    A,\n    B,\n    Z\n);\n\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Z;\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B;\n\n    always @(*) begin\n        if (temp_sum > 15) begin\n            Z = 4'b1111;\n        end else begin\n            Z = temp_sum[3:0];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nWrite a verilog module for a 2-to-1 multiplexer with the following specifications:\n\n- The module should be named `mux2to1`.\n- The module should have three input ports `a`, `b`, and `sel`, and one output port `out`.\n- The input ports should be 1-bit wide, and the output port should be 1-bit wide.\n- When `sel` is 0, the output `out` should be equal to `a`. When `sel` is 1, the output `out` should be equal to `b`.\n- Use only combinational logic (no sequential logic).\n\n", "output": "module mux2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 0) ? a : b;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-input multiplexer with an enable input. The module should have the following inputs and outputs:\n\n- 4 input signals, A, B, C, D, each with a width of 8 bits\n- 1 enable signal, E, with a width of 1 bit\n- 1 output signal, Y, with a width of 8 bits\n\nThe module should output the value of the input signal selected by the enable signal. If the enable signal is 0, the output signal should be 0. If the enable signal is 1, the output signal should be the value of the input signal selected by the 2-bit selection signal, S, as follows:\n\n- If S = 00, Y = A\n- If S = 01, Y = B\n- If S = 10, Y = C\n- If S = 11, Y = D\n\nYour task is to implement the verilog module for the 4-input multiplexer with an enable input. You should assume that the input signals are unsigned.\n\n", "output": "module mux4(input [7:0] A, input [7:0] B, input [7:0] C, input [7:0] D, input E, input [1:0] S, output reg [7:0] Y);\n\nalways @(*)\nbegin\n    if (E == 0)\n        Y = 0;\n    else if (S == 2'b00)\n        Y = A;\n    else if (S == 2'b01)\n        Y = B;\n    else if (S == 2'b10)\n        Y = C;\n    else if (S == 2'b11)\n        Y = D;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create two Verilog modules: one for implementing a half subtractor and another for implementing a full subtractor.\n\nA half subtractor is a digital circuit that performs subtraction of two single-bit binary numbers. \nIt has two inputs: minuend (A) and subtrahend (B). The output of the half subtractor consists of two bits: difference (D) and borrow (Bout). \nThe output difference is the result of subtracting the subtrahend from the minuend, and the borrow output is a signal indicating if a borrow is required in the next stage of subtraction.\n\nA full subtractor is a digital circuit that performs subtraction of three single-bit binary numbers. \nIt has three inputs: minuend (A), subtrahend (B), and borrow-in (Bin). The output of the full subtractor consists of two bits: difference (D) and borrow-out (Bout). \nThe output difference is the result of subtracting the subtrahend and the borrow-in from the minuend, and the borrow-out output is a signal indicating if a borrow is required in the next stage of subtraction.\n\nYour half subtractor module should have the following inputs and outputs:\n\nInputs: minuend (A), subtrahend (B)\nOutputs: difference (D), borrow (Bout)\n\nYour full subtractor module should have the following inputs and outputs:\n\nInputs: minuend (A), subtrahend (B), borrow-in (Bin)\nOutputs: difference (D), borrow-out (Bout)\n\nTo implement the half subtractor and full subtractor, you should use Verilog code to define the Boolean functions for the difference and borrow outputs. \nYou should then use these functions to compute the output signals for both modules.", "output": "module half_subtractor (\n  input A,\n  input B,\n  output D,\n  output Bout\n);\n  assign D = A ^ B;\n  assign Bout = ~A & B;\nendmodule\n\nmodule full_subtractor (\n  input A,\n  input B,\n  input Bin,\n  output D,\n  output Bout\n);\n  wire half_sub1_D, half_sub1_Bout, half_sub2_D, half_sub2_Bout;\n  \n  half_subtractor half_sub1 (\n    .A(A),\n    .B(B),\n    .D(half_sub1_D),\n    .Bout(half_sub1_Bout)\n  );\n  \n  half_subtractor half_sub2 (\n    .A(half_sub1_D),\n    .B(Bin),\n    .D(half_sub2_D),\n    .Bout(half_sub2_Bout)\n  );\n  \n  assign D = half_sub2_D;\n  assign Bout = half_sub1_Bout | half_sub2_Bout;\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module named `SNPS_CLOCK_GATE_HIGH_d_ff_en_W64_0_3` which implements a clock gating circuit. The module has four inputs and one output. The inputs are `CLK`, `EN`, `ENCLK`, and `TE`. The output is `ENCLK`.\n\nYour task is to implement the `TLATNTSCAX2TS` module which is used inside the `SNPS_CLOCK_GATE_HIGH_d_ff_en_W64_0_3` module. The `TLATNTSCAX2TS` module is a D flip-flop with asynchronous set and reset, and a clock enable input. The module has four inputs and one output. The inputs are `E`, `SE`, `CK`, and `ECK`. The output is `ECK`.\n\nThe `E` input is the data input, `SE` is the asynchronous set input, `CK` is the clock input, and `ECK` is the clock enable input. The `ECK` input is used to gate the clock signal `CK`. When `ECK` is high, the flip-flop operates normally. When `ECK` is low, the flip-flop is disabled and the output does not change.\n\nYour implementation should be within 200 lines of Verilog code and should be able to pass the given testbench.\n\n", "output": "module TLATNTSCAX2TS (E, SE, CK, ECK, Q);\n  input E, SE, CK, ECK;\n  output Q;\n\n  reg Q;\n\n  always @(posedge CK, negedge ECK) begin\n    if (!ECK) begin\n      Q <= Q;\n    end else if (SE) begin\n      Q <= 1'b1;\n    end else begin\n      Q <= E;\n    end\n  end\n\nendmodule\n\nmodule SNPS_CLOCK_GATE_HIGH_d_ff_en_W64_0_3 (CLK, EN, ENCLK, TE);\n  input CLK, EN, TE;\n  output ENCLK;\n\n  wire D;\n  assign D = 1'b1;\n\n  TLATNTSCAX2TS latch (.E(D), .SE(TE), .CK(CLK), .ECK(ENCLK), .Q(ENCLK));\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module for a simple digital circuit that takes in two 8-bit binary numbers, `A` and `B`, and returns the sum of the two numbers, `S`. The circuit should also have an output `C_out` which represents the carry-out bit. You are allowed to use any verilog operators or modules in your design.\n\nWrite a verilog module `adder` that takes in two 8-bit binary numbers, `A` and `B`, and returns the sum of the two numbers, `S`. The module should also have an output `C_out` which represents the carry-out bit.\n\nThe module should have the following inputs and outputs:\n- `input [7:0] A`: an 8-bit binary number\n- `input [7:0] B`: an 8-bit binary number\n- `output [7:0] S`: the sum of `A` and `B`\n- `output C_out`: the carry-out bit\n\n", "output": "module adder(input [7:0] A, input [7:0] B, output [7:0] S, output C_out);\n\n    wire [7:0] sum;\n    \n    assign sum = A + B;\n    \n    assign S = sum;\n    \n    assign C_out = sum[8];\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a verilog module that implements a 2:1 multiplexer. The module should have two input ports, one output port, and a select signal to choose between the two inputs. The module should be named `mux_2to1` and should have the following ports:\n\n- `input a`: a 1-bit input signal\n- `input b`: a 1-bit input signal\n- `input sel`: a 1-bit select signal\n- `output y`: a 1-bit output signal\n\nWhen `sel` is `0`, `y` should be equal to `a`. When `sel` is `1`, `y` should be equal to `b`.\n\nImplement the `mux_2to1` module using only basic gates such as AND, OR, NOT, and XOR gates. You may not use any pre-built multiplexer modules.\n\n", "output": "module mux_2to1(\n    input a,\n    input b,\n    input sel,\n    output y\n);\n\n    wire not_sel;\n    wire a_and_sel;\n    wire b_and_not_sel;\n\n    // Invert the select signal\n    not not_sel(sel);\n\n    // AND gate between a and select signal\n    and a_and_sel(a, not_sel, a_and_sel);\n\n    // AND gate between b and inverted select signal\n    and b_and_not_sel(b, sel, b_and_not_sel);\n\n    // OR gate between the two AND gates\n    or or_gate(a_and_sel, b_and_not_sel, y);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a D-type flip-flop with reset functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `D`: the data input\n- `RESET_B`: the reset signal (active low)\n- `CLK`: the clock signal\n\nOutputs:\n- `Q`: the output signal\n\nThe module should operate as follows:\n- When `RESET_B` is low, the output `Q` should be set to 0, regardless of the value of `D`.\n- When `RESET_B` is high and the rising edge of `CLK` occurs, the output `Q` should be updated with the value of `D`.\n\nYou can assume that `CLK` has a frequency of 50 MHz.\n\nWrite a Verilog module that implements the above functionality. Your module should be self-contained and should not require any external modules. Your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module d_ff_reset (\n    input D,\n    input CLK,\n    input RESET_B,\n    output reg Q\n);\n\n    always @(posedge CLK, negedge RESET_B) begin\n        if (~RESET_B) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a simple counter. The counter should have a single input clock signal, and should increment by one on each rising edge of the clock. The counter should have a maximum value of 10, and should reset to zero once it reaches this maximum value. \n\nDesign a verilog module that implements this counter. \n\n", "output": "module counter (/*AUTOARG*/\n   // Inputs\n   clk,\n   // Outputs\n   count\n   );\n   input clk;\n   output reg [3:0] count;\n\n   always @ (posedge clk) begin\n      if (count == 10) begin\n         count <= 0;\n      end\n      else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit input `a`, and outputs a 2-bit value `o`. The output `o` is determined by the following rules:\n- If the input is less than 5 (i.e. `a < 5`), the output should be the 2 least significant bits of the input.\n- If the input is greater than or equal to 5 (i.e. `a >= 5`), the output should be the 2 most significant bits of the input, shifted right by 2 bits.\n\nYou should implement this module using only combinational logic. You may use any number of intermediate wires or variables as necessary.\n\nYour module should be named `four_bit_selector` and should have the following interface:\n- `input [3:0] a`: a 4-bit input value\n- `output reg [1:0] o`: a 2-bit output value\n\n", "output": "module four_bit_selector(input [3:0] a, output reg [1:0] o);\n    wire [3:0] a_shifted;\n    assign a_shifted = a >> 2; // shift input right by 2 bits\n    \n    always @(*) begin\n        if (a < 5) begin\n            o = a[1:0]; // output 2 least significant bits of input\n        end else begin\n            o = a_shifted[3:2]; // output 2 most significant bits of shifted input\n        end\n    end\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module for a synchronous D flip-flop with asynchronous set and clear. The module should have the following inputs and outputs:\nInputs:\n- `CLK`: a clock signal\n- `D`: a data input\n- `SET`: an asynchronous set input\n- `CLR`: an asynchronous clear input\nOutputs:\n- `Q`: a data output\n- `Q_bar`: the complement of the data output\n\nThe module should operate as follows:\n- When `SET` is asserted, `Q` and `Q_bar` should both be set to 1, regardless of the values of `CLK` and `D`.\n- When `CLR` is asserted, `Q` and `Q_bar` should both be set to 0, regardless of the values of `CLK` and `D`.\n- When neither `SET` nor `CLR` is asserted, the module should behave as a standard D flip-flop, with the output `Q` taking on the value of `D` on the rising edge of `CLK`.\n\nYou should implement the module within 200 lines of Verilog code.\n\n", "output": "module d_ff_with_async_set_clear(\n    input CLK,\n    input D,\n    input SET,\n    input CLR,\n    output reg Q,\n    output reg Q_bar\n);\n\nalways @(posedge CLK, posedge SET, posedge CLR) begin\n    if (SET) begin\n        Q <= 1'b1;\n        Q_bar <= 1'b0;\n    end else if (CLR) begin\n        Q <= 1'b0;\n        Q_bar <= 1'b1;\n    end else begin\n        Q <= D;\n        Q_bar <= ~D;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been given a task to design a verilog module for a 4-bit ripple carry adder. The module should have two 4-bit input ports A and B, and a 1-bit input port CIN for carry-in. The module should also have two 4-bit output ports S and COUT for sum and carry-out respectively. \n\nWrite a verilog module for the 4-bit ripple carry adder that satisfies the above requirements. Use the following module header:\n\n```\nmodule ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] S,\n    output COUT\n);\n```\n\n", "output": "module ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] S,\n    output COUT\n);\n    \n    wire [3:0] C;\n    \n    assign S = A + B + CIN;\n    \n    assign C[0] = (A[0] & B[0]) | (A[0] & CIN) | (B[0] & CIN);\n    assign C[1] = (A[1] & B[1]) | (A[1] & C[0]) | (B[1] & C[0]);\n    assign C[2] = (A[2] & B[2]) | (A[2] & C[1]) | (B[2] & C[1]);\n    assign C[3] = (A[3] & B[3]) | (A[3] & C[2]) | (B[3] & C[2]);\n    \n    assign COUT = C[3];\n    \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a light control block for ambient light sensing and dimming.\nThe module should have the following inputs and outputs:\n\nInputs: \n- ambient light sensor (als): a 12-bit signal that represents the ambient light level\n- desired light level (dll): a 12-bit signal that represents the desired light level\n- enable signal (en): a single bit signal that enables the module\n\nOutputs:\n- dimming signal (dim): a 8-bit signal that controls the brightness of the light\n\nThe module should implement the following functionality:\n- When the enable signal is high, the module should compare the ambient light level to the desired light level to determine the dimming level.\n- The dimming level should be calculated as follows:\n  - If the ambient light level is less than or equal to the desired light level, the dimming level should be set to 0.\n  - Otherwise, the dimming level should be calculated as (ambient light level - desired light level) / 16.\n- The dimming level should be clamped to the range of 0 to 255.\n- When the enable signal is low, the dimming level should be set to 0.\n\nTo implement the light control block, you should use Verilog code to define the calculations for the dimming level based on the input signals. \nYou should also define the enable signal and use it to control the output of the dimming signal.", "output": "module light_control (\n  input [11:0] als,\n  input [11:0] dll,\n  input en,\n  output reg [7:0] dim\n);\n\n  always @(*) begin\n    if (en) begin\n      if (als <= dll) begin\n        dim <= 8'b00000000;\n      end else begin\n        dim <= ((als - dll) >> 4) > 8'b11111111 ? 8'b11111111 : ((als - dll) >> 4);\n      end\n    end else begin\n      dim <= 8'b00000000;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a multiplexer module in Verilog. The module should have two 1-bit data inputs, `D0` and `D1`, one control input `ctrl`, and one 1-bit output `S`. The output `S` should be equal to `D0` if `ctrl` is 0, and equal to `D1` if `ctrl` is 1.\n\nYou should implement this module within 200 lines of Verilog code. The module should be named `Multiplexer` and should be self-contained, meaning that it should not rely on any external modules or libraries.\n\nWrite a Verilog module that satisfies the above requirements. Your solution should include the following:\n\n- The module declaration, including the input and output ports.\n- The module implementation, including any necessary wires and logic gates.\n\nYour solution should be correct and efficient, and should not include any unnecessary code.\n\n", "output": "module Multiplexer(\n    input ctrl,\n    input [0:0]D0,\n    input [0:0]D1,\n    output [0:0]S\n);\n\n  wire [0:0]S;\n\n  assign S = ctrl ? D1 : D0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock gating module that can be used to reduce power consumption in a digital circuit. The module should have three inputs - CLK, EN and TE - and one output, ENCLK. The CLK input is the system clock, and the EN input is used to enable or disable the clock gating functionality. When EN is high, the module should pass the CLK signal to the ENCLK output. When EN is low, the module should hold the ENCLK output low, regardless of the value of CLK. The TE input is a test enable signal that can be used to force the module to bypass the clock gating and pass the CLK signal to the ENCLK output.\n\nYour task is to design the module in Verilog using no more than 200 lines of code. The module should be named \"clock_gate\" and should be implemented using behavioral modeling. You should also write a testbench to verify the functionality of the module.\n\n", "output": "module clock_gate (CLK, EN, TE, ENCLK);\n\ninput CLK, EN, TE;\noutput ENCLK;\n\nreg ENCLK;\n\nalways @ (posedge CLK) begin\n    if (EN) begin\n        ENCLK <= CLK;\n    end else begin\n        ENCLK <= 1'b0;\n    end\nend\n\nassign ENCLK = (TE) ? CLK : ENCLK;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 16-bit shift register with a parallel load feature. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a 1-bit clock signal\n- `load`: a 1-bit signal that enables parallel loading of data\n- `data_in`: a 16-bit input signal that contains the data to be loaded into the shift register\n- `shift_en`: a 1-bit signal that enables shifting of the data in the shift register\n\nOutputs:\n- `data_out`: a 16-bit output signal that contains the current state of the shift register\n\nThe shift register should shift the data to the left on every positive edge of the clock signal when `shift_en` is high. When `load` is high, the data in `data_in` should be loaded into the shift register on the next positive edge of the clock signal.\n\n", "output": "module shift_register(clk, load, data_in, shift_en, data_out);\n  input clk;\n  input load;\n  input [15:0] data_in;\n  input shift_en;\n  output [15:0] data_out;\n\n  reg [15:0] reg_data;\n\n  always @(posedge clk) begin\n    if (load) begin\n      reg_data <= data_in;\n    end else if (shift_en) begin\n      reg_data <= {reg_data[14:0], 1'b0};\n    end\n  end\n\n  assign data_out = reg_data;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit binary adder. The module should have two 4-bit inputs, A and B, and a 1-bit input, Cin, representing the carry-in bit. The module should output a 4-bit sum, S, and a 1-bit carry-out bit, Cout. \n\nIn addition, the module should have a 1-bit input, En, representing the enable signal. When En is high, the module should perform the addition and output the result. When En is low, the module should output all zeros.\n\nYou should use the following module template:\n\n```\nmodule binary_adder (\n    A   ,\n    B   ,\n    Cin ,\n    En  ,\n    S   ,\n    Cout\n);\n\n    input  [3:0] A   ;\n    input  [3:0] B   ;\n    input        Cin ;\n    input        En  ;\n    output [3:0] S   ;\n    output       Cout;\n\n    // your code here\n\nendmodule\n```\n\n", "output": "module binary_adder (\n    A   ,\n    B   ,\n    Cin ,\n    En  ,\n    S   ,\n    Cout\n);\n\n    input  [3:0] A   ;\n    input  [3:0] B   ;\n    input        Cin ;\n    input        En  ;\n    output [3:0] S   ;\n    output       Cout;\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    assign sum = A + B + Cin;\n    assign Cout = carry[3];\n\n    genvar i;\n    generate\n        for (i = 0; i < 3; i = i + 1) begin\n            assign carry[i+1] = (sum[i+1] > 1) ? 1 : 0;\n        end\n    endgenerate\n\n    assign S = En ? sum : 4'b0000;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a modulo operator. \nA modulo operator is a mathematical operator that returns the remainder of a division operation. \nThe modulo operator is commonly used in digital circuits to perform operations on binary numbers.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- a: a binary number (represented as an n-bit input signal)\n- b: a binary number (represented as an n-bit input signal)\n\nOutputs: \n- rem: the remainder of the division operation (represented as an n-bit output signal)\n\nYour module should implement the following functionality:\n\n- The module should perform the division operation a / b.\n- The module should then compute the remainder of the division operation using the modulo operator.\n- The remainder should be output as an n-bit signal.\n\nTo implement the modulo operator, you should use Verilog code to define the division operation as well as the modulo operation. \nIn the division operation, you should use a loop to repeatedly subtract the divisor (b) from the dividend (a) until the dividend is less than the divisor. \nThe number of times the loop runs is the quotient. \nIn the modulo operation, you should use the remainder of the division operation to compute the modulo.", "output": "module Modulo (\n  input [n-1:0] a,\n  input [n-1:0] b,\n  output [n-1:0] rem\n);\n\nparameter n = 4; // number of bits in input signals\n\nreg [n-1:0] dividend;\nreg [n-1:0] divisor;\nreg [n-1:0] quotient;\nreg [n-1:0] remainder;\n\nalways @(*) begin\n  dividend = a;\n  divisor = b;\n  \n  // Perform division operation\n  quotient = 0;\n  while (dividend >= divisor) begin\n    dividend = dividend - divisor;\n    quotient = quotient + 1;\n  end\n  \n  // Compute remainder using modulo operator\n  remainder = dividend;\nend\n\nassign rem = remainder;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a 16-bit input signal `in_signal`, and outputs two signals `out_signal1` and `out_signal2`. `out_signal1` should be a 6-bit signal that is the concatenation of the 6 most significant bits of `in_signal` and the 2 least significant bits of `in_signal`. `out_signal2` should be a 10-bit signal that is the concatenation of the 10 least significant bits of `in_signal`. Implement this functionality in a verilog module named `concatenation_module`.\n\n", "output": "module concatenation_module (\n input [15:0] in_signal,\n output [5:0] out_signal1,\n output [9:0] out_signal2\n);\n\n assign out_signal1 = {in_signal[15:10], in_signal[1:0]};\n assign out_signal2 = in_signal[9:0];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-input, 2-output logic function. The module should have four input bits, A, B, C, and D. The module should have two output bits, X and Y. The output X should be the result of the function (A and B) or (C and D). The output Y should be the result of the function (A and C) or (B and D).", "output": "module logic_func_4x2 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg X,\n    output reg Y\n);\n\nalways @(*) begin\n    X = (A & B) | (C & D);\n    Y = (A & C) | (B & D);\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit binary counter with asynchronous reset and synchronous enable. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: Clock input\n- `RST`: Asynchronous reset input\n- `EN`: Synchronous enable input\n\nOutputs:\n- `Q`: 4-bit binary output\n\nThe counter should increment on the rising edge of the clock signal only when the enable input is high. When the reset input is high, the counter should be reset to 0.\n\nDesign a verilog module that meets these specifications. \n\n", "output": "module binary_counter(CLK, RST, EN, Q);\n\ninput CLK, RST, EN;\noutput [3:0] Q;\nreg [3:0] Q;\n\nalways @(posedge CLK) begin\n    if(RST) begin\n        Q <= 4'b0;\n    end\n    else if(EN) begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a digital circuit that implements a 2-input XOR gate using Verilog HDL. The circuit should be implemented using only one module and should take two inputs (A and B) and output their XOR result (Z). The module should also have an active-high enable input (EN) that when asserted, allows the circuit to function and when deasserted, sets the output to 0. The circuit should be synthesizable and operate at a clock frequency of 50 MHz. Assume that the inputs A, B, and EN are synchronous to the clock, and the output Z is registered on the rising edge of the clock.\n\n", "output": "module xor_gate (\n    input A,\n    input B,\n    input EN,\n    input CLK,\n    output reg Z\n);\n\n    always @(posedge CLK) begin\n        if (EN) begin\n            Z <= A ^ B;\n        end else begin\n            Z <= 0;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that performs a specific function. The module should have the following inputs:\n- `clock`: a clock signal\n- `reset_n`: an active-low reset signal\n- `data_in`: a 32-bit input data signal\n- `write_en`: a write enable signal\n- `address`: a 5-bit address signal\n- `data_out`: a 32-bit output data signal\n\nThe module should have the following functionality:\n- On the rising edge of the clock signal, if the reset signal is low, the output data signal should be set to 0.\n- If the write enable signal is high, the input data signal should be written to the memory location specified by the address signal.\n- On the rising edge of the clock signal, if the write enable signal is low, the output data signal should be set to the data stored in the memory location specified by the address signal.\n\nAssume that the memory has a capacity of 32 words, and that the memory is initialized with all 0s.\n\n", "output": "module memory (\n    input clock,\n    input reset_n,\n    input [31:0] data_in,\n    input write_en,\n    input [4:0] address,\n    output reg [31:0] data_out\n);\n\nreg [31:0] mem [31:0];\n\nalways @(posedge clock) begin\n    if (!reset_n) begin\n        data_out <= 0;\n    end else begin\n        if (write_en) begin\n            mem[address] <= data_in;\n        end else begin\n            data_out <= mem[address];\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder with two input ports (`a` and `b`) and one output port (`sum`). The module should also have a control input `ctrl` which, when set to 1, enables the adder and when set to 0, disables it. \n\nYou may use any built-in Verilog operators and functions. The module should have the following interface:\n\n```verilog\nmodule adder_4bit (\n  input [3:0] a,\n  input [3:0] b,\n  input ctrl,\n  output [3:0] sum\n);\n```\n\n", "output": "module adder_4bit (\n  input [3:0] a,\n  input [3:0] b,\n  input ctrl,\n  output [3:0] sum\n);\n\n  reg [3:0] sum_reg;\n\n  always @(*) begin\n    if (ctrl == 1'b1) begin\n      sum_reg = a + b;\n    end\n  end\n\n  assign sum = sum_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that will take in two 32-bit inputs, A and B, and output the sum of A and B. The module should have a parameter called INITVAL, which will be used to initialize a global integer variable called globali. The module should also have two functions: getName, which takes in a fake input and returns the string \"gmod\", and getGlob, which takes in a fake input and returns the value of globali.\n\nDesign a verilog module that meets the above requirements. \n\n", "output": "module adder(\n    input [31:0] A,\n    input [31:0] B,\n    output reg [31:0] sum\n);\n\n   parameter INITVAL = 0;\n   integer globali;\n\n   initial globali = INITVAL;\n\n   always @(*) begin\n      sum = A + B;\n   end\n   \n   function [31:0] getName;  \n      input fake;  \n      getName = \"gmod\"; \n   endfunction\n   \n   function [31:0] getGlob;  \n      input fake;  \n      getGlob = globali;  \n   endfunction\n   \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital circuit using Verilog that implements a 2-input AND gate and a 2-input OR gate. The circuit should have the following inputs and outputs:\n\n- Inputs: A, B, C, D\n- Outputs: F1 (2-input AND gate output), F2 (2-input OR gate output)\n\nYou must implement the circuit using only one module within 200 lines of Verilog code. You are not allowed to use any predefined Verilog modules or operators.\n\nTo help you get started, you can use the following Verilog code snippet as a template:\n\n```\nmodule and_or_gate (\n    input A,\n    input B,\n    input C,\n    input D,\n    output F1,\n    output F2\n);\n\n// Your code here\n\nendmodule\n```\n\nYour task is to fill in the `// Your code here` section with the Verilog code that implements the 2-input AND gate and 2-input OR gate using only basic logic gates (AND, OR, NOT).\n\n", "output": "module and_or_gate (\n    input A,\n    input B,\n    input C,\n    input D,\n    output F1,\n    output F2\n);\n\nwire and1, and2, or1;\n\nassign and1 = A & B;\nassign and2 = C & D;\nassign or1 = A | B;\n\nassign F1 = and1 & and2;\nassign F2 = or1 | and2;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a verilog module for a simple digital circuit that takes in a 4-bit binary input and outputs a 2-bit binary output. The circuit should output a '1' on the first bit of the output if the input is greater than or equal to 5, and a '1' on the second bit of the output if the input is odd.\n\nDesign a verilog module that implements this circuit, and ensure that the module has the following input and output ports:\n\n- `input [3:0] binary_in`: a 4-bit binary input\n- `output [1:0] binary_out`: a 2-bit binary output\n\nYour module should be named `binary_converter`.\n\n", "output": "module binary_converter(\n    input [3:0] binary_in,\n    output [1:0] binary_out\n);\n\n    wire greater_than_five;\n    wire is_odd;\n    \n    assign greater_than_five = (binary_in >= 5);\n    assign is_odd = (binary_in[0] == 1);\n    \n    assign binary_out[0] = greater_than_five;\n    assign binary_out[1] = is_odd;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit binary counter with a synchronous reset. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: the clock signal\n- `RESET`: the synchronous reset signal\n\nOutputs:\n- `Q`: a 4-bit binary output representing the current count\n\nThe counter should increment on the rising edge of the clock signal and reset to 0 on the rising edge of the reset signal. The counter should count up from 0 to 15 (1111 in binary) and then wrap around to 0.\n\nDesign a Verilog module that implements this 4-bit binary counter with a synchronous reset.\n\n", "output": "module counter (\n    input CLK,\n    input RESET,\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        Q <= 4'b0;\n    end else begin\n        if (Q == 4'b1111) begin\n            Q <= 4'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit input and outputs the corresponding Gray code value. The module should have a single input (in) and a single output (out). The output should be a 4-bit Gray code value that corresponds to the input value.", "output": "module gray_code (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @ (in) begin\n        out[3] = in[3];\n        out[2] = in[3] ^ in[2];\n        out[1] = in[2] ^ in[1];\n        out[0] = in[1] ^ in[0];\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a verilog module that computes the logical AND of all the input bits. You need to implement the same functionality using the reduction operator.\n\nWrite a verilog module named \"reduce_and\" that takes in a 4-bit input vector \"in_vec\" and outputs a single-bit \"out_bit\". The module should use the reduction operator to compute the logical AND of all the input bits.\n\n", "output": "module reduce_and(\n    input [3:0] in_vec,\n    output out_bit\n);\n\nassign out_bit = &in_vec;\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module called `RAT_slice_1_0_0` with two ports: `Din` and `Dout`. The `Din` port is a 18-bit input, while the `Dout` port is an 8-bit output. The module also has a wire `Din` of size 18 bits.\n\nYour task is to implement the logic for the `RAT_slice_1_0_0` module such that the lower 8 bits of `Din` are assigned to the `Dout` output port. \n\nWrite the Verilog code for this module.\n\n", "output": "module RAT_slice_1_0_0\n   (Din,\n    Dout);\n  input [17:0] Din;\n  output [7:0] Dout;\n\n  assign Dout[7:0] = Din[7:0];\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a Verilog module that implements a 4-bit binary to gray code converter. The module should have two input ports, a 4-bit binary input and a clock input. The module should have one output port, a 4-bit gray code output. The module should convert the binary input to gray code output on every rising edge of the clock signal. The gray code output should be generated using the following equation: G3 = B3, G2 = B3 XOR B2, G1 = B2 XOR B1, G0 = B1 XOR B0, where B3 is the most significant bit of the binary input and B0 is the least significant bit of the binary input.", "output": "module binary_to_gray (\n  input clk,\n  input [3:0] binary_input,\n  output [3:0] gray_output\n);\n\n  reg [3:0] gray_reg;\n  \n  always@(posedge clk) begin\n    gray_reg[3] <= binary_input[3];\n    gray_reg[2] <= binary_input[3] ^ binary_input[2];\n    gray_reg[1] <= binary_input[2] ^ binary_input[1];\n    gray_reg[0] <= binary_input[1] ^ binary_input[0];\n  end\n  \n  assign gray_output = gray_reg;\n  \nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Design a module that takes in a 4-bit input and outputs the 2's complement equivalent of the input. 2's complement is a way of representing signed integers in binary form. The module should have one input, a 4-bit binary number, and one output, a 4-bit 2's complement number.", "output": "module twos_complement (\n    input [3:0] binary,\n    output reg [3:0] twos_comp\n);\n\nassign twos_comp = (~binary) + 1;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module for a 4-to-1 multiplexer. The module should have four input ports, one output port, and two select lines. The module should be implemented using behavioral Verilog.\n\nThe select lines should be named `sel0` and `sel1`, and the input ports should be named `in0`, `in1`, `in2`, and `in3`. The output port should be named `out`.\n\nThe module should output the value of the input port selected by the select lines. For example, if `sel1` is 0 and `sel0` is 1, the output should be the value of `in1`.\n\n", "output": "module mux4(sel1, sel0, in0, in1, in2, in3, out);\n  input sel1, sel0, in0, in1, in2, in3;\n  output out;\n\n  always @ (*)\n    case ({sel1, sel0})\n      2'b00: out = in0;\n      2'b01: out = in1;\n      2'b10: out = in2;\n      2'b11: out = in3;\n    endcase\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an absolute value calculator. \nAn absolute value calculator is a digital circuit that takes an input signal and outputs its absolute value. \nThe absolute value of a signal is the magnitude of the signal, regardless of its sign. \nFor example, the absolute value of -3 is 3, and the absolute value of 5 is 5.\nYour module should have the following inputs and outputs:\n\nInputs: a signed input signal (in)\nOutputs: an unsigned output signal (out)\nThe module should implement the following functionality:\n\nIf the input signal is positive (i.e., its sign bit is 0), then the output signal should be the same as the input signal.\nIf the input signal is negative (i.e., its sign bit is 1), then the output signal should be the magnitude of the input signal (i.e., the input signal with its sign bit flipped).\nTo implement the absolute value calculator, you should first check the sign bit of the input signal using Verilog code. \nIf the sign bit is 0, then you can simply pass the input signal through to the output signal. \nIf the sign bit is 1, then you should flip the sign bit and pass the resulting signal to the output. \nYou can flip the sign bit by using Verilog code to invert the signal and then adding 1 to the result.", "output": "module abs_value (\n  input signed [31:0] in,\n  output reg [31:0] out\n);\n\n  always @(*) begin\n    if (in < 0) begin\n      out = (~in) + 1;\n    end\n    else begin\n      out = in;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `v84f0a1` that takes in four inputs `vd84a57`, `vf8041d`, `vee8a83`, and `v03aaf0` and outputs a 4-bit value `v11bca5`. The module also instantiates another module `v84f0a1_v9a2a06` which takes in four inputs and outputs a 4-bit value. Your task is to implement the `v84f0a1_v9a2a06` module.\n\nThe `v84f0a1_v9a2a06` module takes in four inputs `i0`, `i1`, `i2`, and `i3` and outputs a 4-bit value `o`. The output `o` is determined by the following rules:\n- If `i0`, `i1`, `i2`, and `i3` are all 0, then `o` should be 0000.\n- If `i0`, `i1`, `i2`, and `i3` are all 1, then `o` should be 1111.\n- If `i0`, `i1`, `i2`, and `i3` are all different from each other, then `o` should be 0001.\n- If `i0`, `i1`, `i2`, and `i3` are all the same and not 0 or 1, then `o` should be 1110.\n- Otherwise, `o` should be 1010.\n\nImplement the `v84f0a1_v9a2a06` module in Verilog within 200 lines of code.\n\n", "output": "module v84f0a1_v9a2a06 (\n    input i0,\n    input i1,\n    input i2,\n    input i3,\n    output reg [3:0] o\n);\n\nalways @(*) begin\n    if (i0 == 0 && i1 == 0 && i2 == 0 && i3 == 0) begin\n        o = 4'b0000;\n    end else if (i0 == 1 && i1 == 1 && i2 == 1 && i3 == 1) begin\n        o = 4'b1111;\n    end else if (i0 != i1 && i0 != i2 && i0 != i3 && i1 != i2 && i1 != i3 && i2 != i3) begin\n        o = 4'b0001;\n    end else if (i0 == i1 && i0 == i2 && i0 == i3 && i0 != 0 && i0 != 1) begin\n        o = 4'b1110;\n    end else begin\n        o = 4'b1010;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in 5 inputs and produces 1 output. The inputs are A1, A2, A3, A4, and B1. The output is Y. The module should be named \"logic_gate\". \n\nThe inputs are binary values, either 0 or 1. The output should be the result of the following logic expression: \n\nY = (A1 AND A2 AND A3 AND A4) OR B1\n\nYou should implement the module using Verilog syntax. \n\n", "output": "module logic_gate (\n    input A1,\n    input A2,\n    input A3,\n    input A4,\n    input B1,\n    output Y\n);\n\n    assign Y = (A1 & A2 & A3 & A4) | B1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a rising-edge triggered D flip-flop with asynchronous reset and set. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal.\n- `rst`: an asynchronous active-low reset signal.\n- `set`: an asynchronous active-low set signal.\n- `d`: the data input.\n\nOutputs:\n- `q`: the output of the flip-flop.\n- `qn`: the complement of the output.\n\nThe module should operate as follows:\n- When `rst` is asserted, `q` and `qn` should both be reset to 0.\n- When `set` is asserted, `q` and `qn` should both be set to 1.\n- On the rising edge of `clk`, `q` and `qn` should be updated with the value of `d`.\n\nYou should implement the module in Verilog within 200 lines of code.\n\n", "output": "module d_ff_async_rst_set (\n  input clk,\n  input rst,\n  input set,\n  input d,\n  output q,\n  output qn\n);\n\n  reg q_i;\n  wire q = q_i;\n  assign qn = ~q_i;\n\n  always @(posedge clk) begin\n    if (rst == 1'b0) begin\n      q_i <= 1'b0; // Asynchronous reset\n    end else if (set == 1'b0) begin\n      q_i <= 1'b1; // Asynchronous set\n    end else begin\n      q_i <= d; // Rising edge triggered\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 2:1 multiplexer with an enable signal. The module should have the following inputs and outputs:\n\nInputs:\n- `input wire  a`: the first input to the multiplexer\n- `input wire  b`: the second input to the multiplexer\n- `input wire  en`: the enable signal\n\nOutputs:\n- `output wire y`: the output of the multiplexer\n\nIf `en` is high, the output of the module should be equal to `b`. Otherwise, the output should be equal to `a`.\n\nYou should implement the module using behavioral Verilog, and assume that the inputs `a`, `b`, and `en` are stable during the entire clock cycle.\n\n", "output": "module mux_2_1(\n    input wire  a,\n    input wire  b,\n    input wire  en,\n    output wire y\n);\n\n  always @*\n    begin\n      if (en)\n        begin\n          y = b;\n        end\n      else\n        begin\n          y = a;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-input OR gate. The module should have the following inputs and outputs:\n\nInputs:\n- A, B, C, D: 4-bit binary values\n- VPWR, VGND: power and ground signals\n- VPB, VNB: positive and negative bias voltages\n\nOutputs:\n- X: 1-bit binary value representing the OR of the 4 inputs\n\nYour module should be named `four_input_or_gate` and should be contained within 200 lines of Verilog code. Your module should be synthesizable and should not use any delays or other non-synthesizable constructs.\n\nYou may assume that the input values are valid binary values and that the power and ground signals are stable.\n\nWrite a Verilog module that meets these requirements.\n\n", "output": "module four_input_or_gate (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    wire [3:0] AB;\n    wire [3:0] CD;\n    wire [3:0] ABCD;\n\n    assign AB = A | B;\n    assign CD = C | D;\n    assign ABCD = AB | CD;\n    assign X = |ABCD;\n\n    sky130_fd_sc_ms__or4b base (\n        .X(X),\n        .A(A),\n        .B(B),\n        .C(C),\n        .D_N(D),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-to-1 multiplexer using only 2-to-1 multiplexers. Your module should have four input signals (D0, D1, D2, D3), two select signals (S0, S1), and one output signal (Y).\n\nYour module should have the following interface:\n```\nmodule MUX4to1_using_2to1 (D0, D1, D2, D3, S0, S1, Y);\ninput D0, D1, D2, D3, S0, S1;\noutput Y;\n// your code here\nendmodule\n```\nYou should not use any other verilog constructs, such as if-else statements or case statements, to implement the 4-to-1 multiplexer.\n\n", "output": "module MUX4to1_using_2to1 (D0, D1, D2, D3, S0, S1, Y);\ninput D0, D1, D2, D3, S0, S1;\noutput Y;\n\nwire w1, w2, w3;\n\n// first stage of multiplexing\nmux_2to1 m1 (.A(D0), .B(D1), .S(S0), .Y(w1));\nmux_2to1 m2 (.A(D2), .B(D3), .S(S0), .Y(w2));\n\n// second stage of multiplexing\nmux_2to1 m3 (.A(w1), .B(w2), .S(S1), .Y(w3));\n\nassign Y = w3;\n\nendmodule\n\nmodule mux_2to1 (A, B, S, Y);\ninput A, B, S;\noutput Y;\n\nassign Y = (S == 1'b0) ? A : B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 32-bit input and outputs a 16-bit output. The output is the result of performing a bitwise AND operation between the input and a 16-bit mask. The mask is determined by a set of control signals that are input into the module. \n\nThe module should have the following inputs:\n- `input [31:0] data_in`: the 32-bit input to be masked\n- `input [15:0] mask`: the 16-bit mask to be applied to the input\n- `input enable`: a control signal that enables the module to perform the masking operation\n\nThe module should have the following output:\n- `output [15:0] data_out`: the 16-bit output after applying the mask\n\nIf `enable` is low, the module should output all zeros. If `enable` is high, the module should perform the bitwise AND operation between `data_in` and `mask` and output the result as `data_out`.\n\nWrite a Verilog module that implements this functionality within 200 lines of code.\n\n", "output": "module bit_masking(\n  input [31:0] data_in,\n  input [15:0] mask,\n  input enable,\n  output [15:0] data_out\n);\n\n  reg [15:0] temp_data_out;\n\n  always @(*) begin\n    if (enable) begin\n      temp_data_out = data_in & mask;\n    end else begin\n      temp_data_out = 16'b0;\n    end\n  end\n\n  assign data_out = temp_data_out;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 8-bit comparator that compares two 8-bit input vectors (in1 and in2) and outputs a 1-bit match signal (match) indicating whether the input vectors are equal or not. The module should use a for loop to compare each bit of the input vectors. If all the bits are equal, the match signal should be high, otherwise it should be low.", "output": "module comparator_8bit (\n  input [7:0] in1,\n  input [7:0] in2,\n  output reg match\n);\n\n  reg [7:0] temp;\n  integer i;\n\n  always @* begin\n    match = 1;\n    for (i = 0; i < 8; i = i + 1) begin\n      temp[i] = (in1[i] == in2[i]);\n      match = match & temp[i];\n    end\n  end\n\nendmodule\n"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes in 3 inputs and produces 1 output. The inputs are A1, A2, and B1_N, and the output is Y. The module should be named \"three_to_one\". The module should be designed to implement the following logic:\n- If A1 and A2 are both high, Y should be high.\n- If A1 is high and A2 is low, Y should be low.\n- If A1 is low and A2 is high, Y should be low.\n- If A1 and A2 are both low, Y should be high if B1_N is low, and low if B1_N is high.\n- The module should also have two inputs, VPWR and VGND, which should be connected to the power and ground rails, respectively. \n\nYour task is to implement the \"three_to_one\" module in Verilog, ensuring that it satisfies the above requirements. Your Verilog module should be no longer than 200 lines of code.\n\n", "output": "module three_to_one (\n    input A1,\n    input A2,\n    input B1_N,\n    output Y,\n    input VPWR,\n    input VGND\n);\n\n    assign Y = (A1 && A2) ? 1'b1 :\n               (A1 && !A2) ? 1'b0 :\n               (!A1 && A2) ? 1'b0 :\n               (!A1 && !A2 && !B1_N) ? 1'b1 :\n               (!A1 && !A2 && B1_N) ? 1'b0 :\n               1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a binary counter with asynchronous reset and synchronous enable. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a reset signal (active high)\n- `en`: an enable signal (active high)\n\nOutputs:\n- `count`: a binary output representing the current count value\n\nThe counter should increment on the rising edge of `clk` only if `en` is asserted. If `rst` is asserted, the counter should reset to 0. The counter should be implemented using a D flip-flop.\n\nWrite a Verilog module that implements the binary counter with the given specifications.\n\n", "output": "module binary_counter(\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n    end else if (en) begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in 3 inputs, `A`, `B`, and `C`, and outputs `Y`. The output `Y` should be the result of the following expression: `(A & B) | (~B & C)`. \n\nDesign a module named `logic_gate` with the following ports:\n- `input A`\n- `input B`\n- `input C`\n- `output Y`\n\nUse the `and`, `not`, and `or` gates to implement the logic expression. \n\n", "output": "module logic_gate (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    // Local signals\n    wire and0_out;\n    wire not0_out;\n    wire not1_out;\n    wire and1_out;\n    wire or0_out;\n\n    //  Name    Output      Other arguments\n    and and0   (and0_out  , A, B    );\n    not not0   (not0_out  , B      );\n    not not1   (not1_out  , not0_out);\n    and and1   (and1_out  , not1_out, C);\n    or  or0    (or0_out   , and0_out, and1_out);\n    buf buf0   (Y         , or0_out );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a register file module in Verilog. The module should have 8 8-bit registers, with the ability to read from and write to any of the registers. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `we`: a write enable signal\n- `d_in`: an 8-bit data input\n- `adr`: a 3-bit address input\n\nOutputs:\n- `d_out`: an 8-bit data output\n\nDesign the register file module in Verilog, ensuring that it is synchronous and that all inputs and outputs are correctly defined.\n\n", "output": "module register_file(\n    input clk,\n    input we,\n    input [7:0] d_in,\n    input [2:0] adr,\n    output reg [7:0] d_out\n);\n\nreg [7:0] reg_file [0:7];\n\nalways @(posedge clk) begin\n    if (we) begin\n        reg_file[adr] <= d_in;\n    end\n    d_out <= reg_file[adr];\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit adder with carry-in and carry-out signals. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a reset signal\n- `a`: a 4-bit input signal\n- `b`: a 4-bit input signal\n- `cin`: a carry-in signal\n\nOutputs:\n- `sum`: a 4-bit output signal representing the sum of `a` and `b`\n- `cout`: a carry-out signal\n\nThe module should perform the addition of `a` and `b` with the carry-in signal `cin`, and output the resulting sum in `sum` and the carry-out signal in `cout`. The module should be synchronous, meaning that the addition should only occur on the rising edge of the clock signal. The module should also have an asynchronous reset signal `rst` that sets the output signals to 0 when asserted.\n\n", "output": "module Adder_4bit (\n    input clk,\n    input rst,\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nreg [3:0] sum_reg;\nreg cout_reg;\n\nalways @(posedge clk or negedge rst) begin\n    if (rst == 0) begin\n        sum_reg <= 4'b0;\n        cout_reg <= 1'b0;\n    end\n    else begin\n        sum_reg <= a + b + cin;\n        cout_reg <= (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n    end\nend\n\nassign sum = sum_reg;\nassign cout = cout_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a logic circuit with the following truth table:\n\n| A1 | A2 | B1 | B2 | X |\n|----|----|----|----|---|\n| 0  | 0  | 0  | 0  | 0 |\n| 0  | 0  | 0  | 1  | 1 |\n| 0  | 0  | 1  | 0  | 1 |\n| 0  | 0  | 1  | 1  | 0 |\n| 0  | 1  | 0  | 0  | 0 |\n| 0  | 1  | 0  | 1  | 0 |\n| 0  | 1  | 1  | 0  | 1 |\n| 0  | 1  | 1  | 1  | 0 |\n| 1  | 0  | 0  | 0  | 1 |\n| 1  | 0  | 0  | 1  | 0 |\n| 1  | 0  | 1  | 0  | 0 |\n| 1  | 0  | 1  | 1  | 1 |\n| 1  | 1  | 0  | 0  | 1 |\n| 1  | 1  | 0  | 1  | 0 |\n| 1  | 1  | 1  | 0  | 0 |\n| 1  | 1  | 1  | 1  | 1 |\n\nYour module should have the following inputs and outputs:\n\n- `A1`: a single-bit input\n- `A2`: a single-bit input\n- `B1`: a single-bit input\n- `B2`: a single-bit input\n- `X`: a single-bit output\n\nYour implementation should use only one module and should be no more than 200 lines of Verilog code.\n\n", "output": "module logic_circuit (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire or0_out;\n    wire or1_out;\n    wire and0_out_X;\n\n    or or0 (or0_out, A2, A1);\n    or or1 (or1_out, B2, B1);\n    and and0 (and0_out_X, or0_out, or1_out);\n    buf buf0 (X, and0_out_X);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a simple circuit with 8 inputs and 4 outputs. The circuit should take in 8 binary inputs and output the following:\n- The first output should be the logical OR of the first four inputs.\n- The second output should be the logical AND of the first four inputs.\n- The third output should be the logical OR of the last four inputs.\n- The fourth output should be the logical AND of the last four inputs.\n\nDesign a module named \"logic_circuit\" that takes in 8 binary inputs named \"in[7:0]\" and outputs the four binary outputs named \"out[3:0]\".\n\n", "output": "module logic_circuit(\n    input [7:0] in,\n    output [3:0] out\n);\n\n    assign out[0] = |in[3:0];   // OR of first four inputs\n    assign out[1] = &in[3:0];   // AND of first four inputs\n    assign out[2] = |in[7:4];   // OR of last four inputs\n    assign out[3] = &in[7:4];   // AND of last four inputs\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-to-1 multiplexer with a select input. The module should have five inputs (A, B, C, D, and SEL) and one output (Y). If SEL is 2'b00, Y should be equal to A. If SEL is 2'b01, Y should be equal to B. If SEL is 2'b10, Y should be equal to C. If SEL is 2'b11, Y should be equal to D.", "output": "module mux4to1 (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input [1:0] SEL,\n    output reg [3:0] Y\n);\n\nalways @(*) begin\n    case (SEL)\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements the hyperbolic sine, cosine, and tangent functions (sineh, cosh, tanh). \nThese functions are commonly used in mathematical and scientific applications, and they are defined as follows:\n\nsineh(x) = (e^x - e^-x) / 2\ncosh(x) = (e^x + e^-x) / 2\ntanh(x) = sineh(x) / cosh(x)\n\nYour module should have the following inputs and outputs:\n\nInputs: a single input signal (x)\nOutputs: three output signals (sineh, cosh, tanh)\n\nYour module should implement the following functionality:\n\nThe module should compute the hyperbolic sine, cosine, and tangent functions of the input signal using the above equations.\nTo implement these functions, you should use Verilog code to compute the values of e^x, e^-x, and the various sums and differences required by the equations.\nYou should then use these values to compute the values of sineh, cosh, and tanh.", "output": "module hyperbolic (\n  input x,\n  output sineh,\n  output cosh,\n  output tanh\n);\n\n  reg signed [31:0] exp_x, exp_neg_x;\n  reg signed [31:0] e_x, e_neg_x;\n  reg signed [31:0] sum, diff;\n  \n  assign e_x = $exp(x);\n  assign e_neg_x = $exp(-x);\n  \n  always @(*) begin\n    sum = e_x + e_neg_x;\n    diff = e_x - e_neg_x;\n    \n    sineh = diff >> 1;\n    cosh = sum >> 1;\n    tanh = sineh / cosh;\n  end\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a module in Verilog that will output a zero signal. The module should be named \"zero\" and have a single output port named \"zero\". The module should be implemented within 200 lines of Verilog code.\n\nYou should use the provided code snippet as a starting point, but you will need to modify it to meet the requirements of the problem. Specifically, you will need to modify the module name, add an output port, and ensure that the module outputs a zero signal.\n\nYour implementation should be able to be synthesized and run on an FPGA.\n\n", "output": "module zero (\n  output zero\n);\n\n  assign zero = 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module that implements a 32-bit adder with a synchronous reset and clock enable. The module should have the following inputs and outputs:\n\nInputs:\n- `A` (32-bit signed integer): First input to the adder\n- `B` (32-bit signed integer): Second input to the adder\n- `C` (1-bit): Clock input\n- `CE` (1-bit): Clock enable input\n- `R` (1-bit): Reset input\n\nOutputs:\n- `S` (32-bit signed integer): Result of the addition\n\nThe module should perform the addition of `A` and `B` when `CE` is high and the clock edge is detected. If `R` is high, the output should be set to 0. If `CE` is low, the output should remain unchanged.\n\n", "output": "module ADD32\n  (output reg signed [31:0] S,\n   input signed [31:0] A,\n   input signed [31:0] B,\n   input C,    // Clock\n   input CE,   // Clock Enable\n   input R     // Synchronous Reset\n   );\n   \n   always @(posedge C)\n     if(R)\n       S <= 32'sd0;\n     else if(CE)\n       S <= A + B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that will implement a 4-bit binary to Gray code converter. The module should have the following input and output ports:\n\nInput Ports:\n- `binary_in`: a 4-bit input port representing the binary input.\n- `clk`: a clock input port.\n\nOutput Ports:\n- `gray_out`: a 4-bit output port representing the Gray code output.\n\nThe module should use the positive edge of the clock to sample the binary input and generate the corresponding Gray code output. The module should be synthesizeable and should not use any behavioral constructs.\n\nDesign Requirements:\n- The module should use only combinational logic.\n- The module should use the minimum number of logic gates.\n- The module should have a maximum delay of 2 ns.\n\n", "output": "module binary_to_gray_converter(\n    input [3:0] binary_in,\n    input clk,\n    output [3:0] gray_out\n);\n\n    assign gray_out[0] = binary_in[0];\n    assign gray_out[1] = binary_in[0] ^ binary_in[1];\n    assign gray_out[2] = binary_in[1] ^ binary_in[2];\n    assign gray_out[3] = binary_in[2] ^ binary_in[3];\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that implements a simple 2-to-1 multiplexer. The module should have two input ports, `A` and `B`, and a select input `S`. When `S` is 0, the output `Y` should be equal to `A`, and when `S` is 1, `Y` should be equal to `B`. The module should also have a reset input `RST` which sets the output to 0 when active, and a clock input `CLK` which updates the output on the rising edge.\n\nImplement the module `MUX2` with the following ports:\n- `A`: a 1-bit input\n- `B`: a 1-bit input\n- `S`: a 1-bit input\n- `Y`: a 1-bit output\n- `CLK`: a clock input\n- `RST`: a reset input\n\nYou may assume that the inputs `A`, `B`, and `S` are synchronous to the clock, and that the reset input `RST` is asynchronous.\n\n", "output": "module MUX2(\n\tinput A, B, S, CLK, RST,\n\toutput reg Y\n);\n\n\talways @(posedge CLK, negedge RST) begin\n\t\tif(RST == 1) begin\n\t\t\tY <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif(S == 0) begin\n\t\t\t\tY <= A;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tY <= B;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit binary counter. The counter should have a synchronous reset input, a clock input, and an output that displays the current count value in binary. The counter should count up on each rising edge of the clock input and reset to 0 when the reset input is asserted.\n\nCreate a verilog module that implements the 4-bit binary counter with the following interface:\n- `clk`: input clock signal\n- `rst`: input synchronous reset signal\n- `count`: output 4-bit binary value representing the current count\n\n", "output": "module binary_counter(clk, rst, count);\n\n   input clk, rst;\n   output reg [3:0] count;\n\n   always @(posedge clk or posedge rst)\n   begin\n      if (rst) // reset counter to 0\n         count <= 4'b0000;\n      else // increment counter\n         count <= count + 1;\n   end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit adder with carry-in and carry-out functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `a` (4-bit input)\n- `b` (4-bit input)\n- `cin` (1-bit input)\n\nOutputs:\n- `sum` (4-bit output)\n- `cout` (1-bit output)\n\nYour module should implement the following functionality:\n- The 4-bit adder should add the values of `a` and `b` and output the result in `sum`.\n- The carry-in value `cin` should be added to the sum of `a` and `b`.\n- The carry-out value `cout` should be set to 1 if the sum of `a`, `b`, and `cin` is greater than 15, otherwise it should be set to 0.\n\nWrite the verilog code for the module and test it using a testbench.\n\n", "output": "module four_bit_adder(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] temp_sum;\n  wire carry;\n\n  assign temp_sum = a + b + cin;\n  assign sum = temp_sum[3:0];\n  assign cout = temp_sum[4];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a full adder using Verilog. The module should have three inputs, A, B, and CIN, and two outputs, SUM and COUT. The module should be able to add the two binary inputs A and B, along with a carry input CIN, and produce the binary sum in SUM and the carry out in COUT. \n\nThe module should be named \"full_adder\" and should be contained within 200 lines of Verilog code. The inputs and outputs should be defined as follows: \n\nInputs:\n- A (1-bit)\n- B (1-bit)\n- CIN (1-bit)\n\nOutputs:\n- SUM (1-bit)\n- COUT (1-bit)\n\nThe module should use the following Verilog primitives:\n- XOR (^)\n- AND (&)\n- OR (|)\n\nYou may use any other Verilog constructs you see fit.\n\n", "output": "module full_adder(\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\nwire w1, w2, w3;\n\n// Calculate SUM\nassign w1 = A ^ B;\nassign SUM = w1 ^ CIN;\n\n// Calculate COUT\nassign w2 = A & B;\nassign w3 = CIN & w1;\nassign COUT = w2 | w3;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Build a module that implements a 4-bit barrel shifter. The module should have two inputs (data and shift), a 4-bit output (result), and four shift modes (shift_right, shift_left, rotate_right, rotate_left). When shift_right is high, the module should shift the data input to the right by the amount specified by shift and fill the leftmost bits with zeros. When shift_left is high, the module should shift the data input to the left by the amount specified by shift and fill the rightmost bits with zeros. When rotate_right is high, the module should rotate the data input to the right by the amount specified by shift. When rotate_left is high, the module should rotate the data input to the left by the amount specified by shift.", "output": "module barrel_shifter (\n    input [3:0] data,\n    input [1:0] shift,\n    input shift_right,\n    input shift_left,\n    input rotate_right,\n    input rotate_left,\n    output reg [3:0] result\n);\n\nalways @(*) begin\n    case ({rotate_left, rotate_right, shift_left, shift_right})\n        4'b0001: result = {data[2:0], data[3]};\n        4'b0010: result = {data[1:0], data[3:2]};\n        4'b0100: result = {data[0], data[3:1]};\n        4'b1000: result = {data[3], data[2:0]};\n        default: result = data;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that generates a block memory with a specified width and parameter. The module should take in a clock signal `clka` and an address input of 10 bits `addra`. The output should be a 36-bit data output `douta`.\n\nCreate a Verilog module called `block_mem_gen` that takes in the clock signal `clka` and address input `addra`. The module should generate a block memory with a specified width and parameter. The width and parameter should be defined as parameters within the module and should be set to 32 and 1024 respectively.\n\nThe module should have a memory depth of 1024 and a data width of 32. The memory should be initialized with the values of an array `mem_init` which is defined as follows:\n\n```\nreg [31:0] mem_init [0:1023] = '{1024{32'h00000000}};\n```\n\nThe module should output the value stored in the memory at the address specified by `addra`. If `addra` is greater than or equal to 1024, then the output should be 0.\n\n", "output": "module block_mem_gen\n   #(parameter WIDTH = 32, DEPTH = 1024)\n   (douta,\n    clka,\n    addra);\n    \n  output reg [WIDTH-1:0] douta;\n  input clka;\n  input [9:0] addra;\n\n  reg [WIDTH-1:0] mem_init [0:DEPTH-1];\n\n  integer i;\n\n  initial begin\n    for (i = 0; i < DEPTH; i = i + 1) begin\n      mem_init[i] = 32'h00000000;\n    end\n  end\n\n  always @(posedge clka) begin\n    if (addra < DEPTH) begin\n      douta <= mem_init[addra];\n    end else begin\n      douta <= 0;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create two Verilog modules: one for the Discrete Cosine Transform (DCT) block and another for the Inverse Discrete Cosine Transform (IDCT) block. \nA DCT is a mathematical technique used to convert a signal from the time domain to the frequency domain. The DCT and IDCT blocks are commonly used in image and video compression algorithms, such as JPEG.\nThe DCT module should have the following inputs and outputs:\n\nInputs: a set of n input samples (in1, in2, ..., inn)\nOutputs: a set of n frequency coefficients (out1, out2, ..., outn)\nThe module should also have the following parameters:\n\nn: the number of input samples\nYour DCT module should implement the following functionality:\n\nThe DCT block should take in a set of n input samples and transform them into a set of n frequency coefficients using the DCT algorithm.\nTo implement the DCT, you should use Verilog code to define the DCT algorithm as a mathematical operation on the input samples. \nYou should then use this algorithm to compute the frequency coefficients.\n\nThe IDCT module should have the following inputs and outputs:\n\nInputs: a set of n frequency coefficients (in1, in2, ..., inn)\nOutputs: a set of n output samples (out1, out2, ..., outn)\nThe module should also have the following parameters:\n\nn: the number of output samples\nYour IDCT module should implement the following functionality:\n\nThe IDCT block should take in a set of n frequency coefficients and transform them into a set of n output samples using the IDCT algorithm.\nTo implement the IDCT, you should use Verilog code to define the IDCT algorithm as a mathematical operation on the frequency coefficients. \nYou should then use this algorithm to compute the output samples.", "output": "module DCT (\n  input [n-1:0] in,\n  output [n-1:0] out\n);\n\nparameter n = 8; // number of input samples\n\n// DCT implementation code goes here\n\nendmodule\n\nmodule IDCT (\n  input [n-1:0] in,\n  output [n-1:0] out\n);\n\nparameter n = 8; // number of output samples\n\n// IDCT implementation code goes here\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a pipelined module that performs parity checking on 8-bit data, using an XNOR gate. \nThe output 'parity_out' should be set to 1 if the total number of 1's in the data is even, and 0 if the total number of 1's is odd. \nThe module should be clocked using a positive edge-triggered clock and include a reset input to ensure proper initialization. \nUse pipeline structure to achieve this functionality.", "output": "module parity_check (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  output reg parity_out\n);\n\nreg [7:0] pipeline_reg1;\nreg [7:0] pipeline_reg2;\nreg [7:0] pipeline_reg3;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    pipeline_reg1 <= 8'b0;\n    pipeline_reg2 <= 8'b0;\n    pipeline_reg3 <= 8'b0;\n    parity_out <= 1'b0;\n  end else begin\n    pipeline_reg1 <= data_in;\n    pipeline_reg2 <= pipeline_reg1;\n    pipeline_reg3 <= pipeline_reg2;\n    parity_out <= ~(pipeline_reg1 ^ pipeline_reg2 ^ pipeline_reg3) & 1'b1;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a basic arithmetic logic unit (ALU) for a microprocessor. The ALU should be able to perform the following operations: addition, subtraction, bitwise AND, bitwise OR, bitwise XOR, and logical shift left. The ALU should take two 32-bit inputs (A and B) and a 5-bit control signal (CTRL) as inputs, and output a 32-bit result (RES).\n\nThe CTRL signal should be decoded as follows:\n- CTRL = 00000: addition (A + B)\n- CTRL = 00001: subtraction (A - B)\n- CTRL = 00010: bitwise AND (A & B)\n- CTRL = 00011: bitwise OR (A | B)\n- CTRL = 00100: bitwise XOR (A ^ B)\n- CTRL = 00101: logical shift left (A << B)\n\nThe module should have the following interface:\n- input clk: the clock signal\n- input rst: the reset signal\n- input [31:0] A: the first input value\n- input [31:0] B: the second input value\n- input [4:0] CTRL: the control signal\n- output reg [31:0] RES: the result value\n\nYou should implement the ALU using behavioral Verilog code.\n\n", "output": "module ALU(clk, rst, A, B, CTRL, RES);\n\ninput clk, rst;\ninput [31:0] A, B;\ninput [4:0] CTRL;\noutput reg [31:0] RES;\n\nalways @(posedge clk or posedge rst) begin\n\tif(rst) begin\n\t\tRES <= 0;\n\tend else begin\n\t\tcase(CTRL)\n\t\t\t5'b00000: // addition\n\t\t\t\tRES <= A + B;\n\t\t\t5'b00001: // subtraction\n\t\t\t\tRES <= A - B;\n\t\t\t5'b00010: // bitwise AND\n\t\t\t\tRES <= A & B;\n\t\t\t5'b00011: // bitwise OR\n\t\t\t\tRES <= A | B;\n\t\t\t5'b00100: // bitwise XOR\n\t\t\t\tRES <= A ^ B;\n\t\t\t5'b00101: // logical shift left\n\t\t\t\tRES <= A << B;\n\t\t\tdefault:\n\t\t\t\tRES <= 0;\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit up/down counter with a synchronous reset and enable. The module should have one 1-bit input (up), one 1-bit input (en), one 1-bit input (rst), and one 4-bit output (out). When up is high, the counter should count up. When up is low, the counter should count down. When en is low, the counter should hold its current value. When rst is high, the counter should reset to zero.", "output": "module up_down_counter (\n    input up,\n    input en,\n    input rst,\n    output reg [3:0] out\n);\n\n    always @(posedge en or posedge rst) begin\n        if (rst) begin\n            out <= 4'b0;\n        end else if (en) begin\n            if (up) begin\n                out <= out + 1;\n            end else begin\n                out <= out - 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that detects a USB reset signal. The module should have four inputs: `rst_n` (active-low reset), `clk` (clock), `se0` (USB signal), and an output `usb_rst` (USB reset signal). The module should reset the `cntr` register to 0 whenever `rst_n` is low. When `rst_n` is high, the module should count down from 480000 to 0 if `se0` is low. If `se0` is high, the module should reset the `cntr` register to 0. When `cntr` reaches 0, the module should assert the `usb_rst` signal for one clock cycle.\n\nDesign a Verilog module that implements the above functionality.\n\n", "output": "module usb_reset_detect(\n    input rst_n,\n    input clk,\n    input se0,\n    output usb_rst\n);\n\nreg[18:0] cntr;\nassign usb_rst = cntr == 1'b0;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cntr <= 1'b0;\n    end else begin\n        if (se0) begin\n            cntr <= 19'd480000;\n        end else begin\n            cntr <= cntr - 1'b1;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit comparator. The module should have two 4-bit inputs and a single output. The output should be high if the first input is greater than the second input, low if the first input is less than the second input, and high-z if the inputs are equal.", "output": "module comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg out\n);\n\n    always @(*) begin\n        if (a > b) begin\n            out = 1'b1;\n        end\n        else if (a < b) begin\n            out = 1'b0;\n        end\n        else begin\n            out = 1'bz;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit binary number and outputs the one's complement of the number. One's complement is a binary operation that flips all the bits in a number, changing 0s to 1s and 1s to 0s.", "output": "module ones_complement (\n    input [3:0] binary,\n    output reg [3:0] ones_comp\n);\n\n    always @ (binary) begin\n        ones_comp <= ~binary;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a simple 8-bit adder. The module should have the following interface:\n\nInputs:\n- `clock`: the clock signal\n- `reset`: a synchronous active-high reset signal\n- `a`: an 8-bit input signal\n- `b`: an 8-bit input signal\n\nOutputs:\n- `sum`: an 8-bit output signal representing the sum of `a` and `b`\n\nThe module should perform the addition operation on every rising edge of the clock signal. When the reset signal is high, the output should be set to 0.\n\nWrite the verilog code for this module.\n\n", "output": "module adder\n(\n  input          clock,\n  input          reset,\n  input   [7:0] a,\n  input   [7:0] b,\n  output [7:0]  sum\n);\n\n  reg [8:0] sum_reg;\n\n  always @(posedge clock) begin\n    if (reset) begin\n      sum_reg <= 8'b0;\n    end else begin\n      sum_reg <= a + b;\n    end\n  end\n\n  assign sum = sum_reg[7:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 8-bit inputs, A and B, and outputs their sum in binary. The module should also output a carry bit indicating whether an overflow occurred during the addition. \n\nDesign a verilog module that meets the following specifications:\n\n- The module should be named \"addition_module\"\n- The module should have two 8-bit inputs named \"A\" and \"B\"\n- The module should have two 8-bit outputs named \"sum\" and \"carry\"\n- The module should perform binary addition on the inputs A and B, and output the result on the \"sum\" output\n- If an overflow occurs during the addition, the \"carry\" output should be set to 1, otherwise it should be set to 0\n\n", "output": "module addition_module(\n  input [7:0] A,\n  input [7:0] B,\n  output [7:0] sum,\n  output carry\n);\n\n  reg [8:0] temp_sum;\n\n  always @ (A or B) begin\n    temp_sum = A + B;\n    if (temp_sum > 255) begin\n      carry = 1;\n      sum = temp_sum[7:0];\n    end else begin\n      carry = 0;\n      sum = temp_sum[7:0];\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that performs a 4-to-1 multiplexer. The module should have four 8-bit inputs (data0, data1, data2, data3), a 2-bit select input (selectInput), and one 8-bit output (out). The output should be the selected input based on the selectInput value. The selectInput should be interpreted as follows:\n- 00: select data0\n- 01: select data1\n- 10: select data2\n- 11: select data3\n\nDesign a Verilog module that implements this 4-to-1 multiplexer. Ensure that the module is self-contained and does not require any external modules. The module should be synthesizable and meet timing requirements.\n\n", "output": "module mux4x1(data0, data1, data2, data3, selectInput, out);\n    \n    output reg [7:0] out;\n    input [7:0] data0, data1, data2, data3;\n    input [1:0] selectInput;\n\n    always @(*) begin\n        case (selectInput)\n            2'b00: out = data0;\n            2'b01: out = data1;\n            2'b10: out = data2;\n            2'b11: out = data3;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nImplement a Verilog module that takes a 50 MHz clock signal, a reset input, and an output signal. The module should generate a reset pulse of 10 clock cycles duration when the reset input is asserted. The output signal should be high during the reset pulse and low otherwise. The reset pulse should occur only once per reset event.\n\nUse the following module header:\n```\nmodule RESET(CLK, RST_I, RST_OUT);\n    input CLK, RST_I;\n    output RST_OUT;\n    \n    // Your code here\n    \nendmodule\n```\n\n", "output": "module RESET(CLK, RST_I, RST_OUT);\n    input CLK, RST_I;\n    output RST_OUT;\n    \n    reg [4:0] cnt;\n    reg rst_pulse;\n\n    always @(posedge CLK or negedge RST_I) begin\n        if (!RST_I) begin\n            cnt <= 0;\n            rst_pulse <= 0;\n        end\n        else if (cnt == 10) begin\n            rst_pulse <= 0;\n        end\n        else if (rst_pulse == 0) begin\n            cnt <= cnt + 1;\n            rst_pulse <= 1;\n        end\n    end\n    \n    assign RST_OUT = rst_pulse;\n    \nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that takes in four inputs: `g`, `p`, `g_prec`, and `p_prec`. The module should output two signals: `g_out` and `p_out`. You are only allowed to use a single module within 200 lines of Verilog code.\n\nThe inputs `g` and `p` are single bit signals, while `g_prec` and `p_prec` are single bit precision signals. The output `g_out` and `p_out` are also single bit signals.\n\nYour module should perform the following operations:\n1. A two-input AND gate with inputs `p` and `p_prec` should output `p_out`.\n2. An inverter with input `g` should output `n6`.\n3. A two-input NAND gate with inputs `g_prec` and `p` should output `n5`.\n4. A two-input NAND gate with inputs `n5` and `n6` should output `g_out`.\n\nYour task is to design a Verilog module that implements the above operations and satisfies the given input-output requirements. Make sure to name your module `pg_5`.\n\n", "output": "module pg_5 ( g, p, g_prec, p_prec, g_out, p_out );\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire   n5, n6;\n\n  AND2_X1 U1 ( .A1(p), .A2(p_prec), .ZN(p_out) );\n  INV_X1 U2 ( .A(g), .ZN(n6) );\n  NAND2_X1 U3 ( .A1(g_prec), .A2(p), .ZN(n5) );\n  NAND2_X1 U4 ( .A1(n5), .A2(n6), .ZN(g_out) );\nendmodule"}
{"instruction": "\n\nYou have been tasked with creating a Verilog module that performs a binary to BCD conversion. The module should have two inputs, a 4-bit binary number and a clock signal. It should output two 4-bit BCD digits corresponding to the input binary number.\n\nYour task is to complete the Verilog module `bin2bcd` that performs this conversion. The binary input is provided on a 4-bit input port `bin_in` and the clock signal is provided on an input port `clk`. The two BCD digits should be output on two separate 4-bit output ports `bcd_out1` and `bcd_out2`.\n\nYou may assume that the binary input is always a valid 4-bit unsigned binary number and that the clock signal has a frequency of 50 MHz.\n\n\n", "output": "module bin2bcd(\n  input [3:0] bin_in,\n  input clk,\n  output reg [3:0] bcd_out1,\n  output reg [3:0] bcd_out2\n);\n\n  reg [3:0] bcd[1:2];\n  integer i;\n\n  always @(posedge clk) begin\n    // Convert binary to BCD\n    for (i = 1; i <= 2; i = i + 1) begin\n      bcd[i] = 0;\n    end\n\n    for (i = 0; i <= 3; i = i + 1) begin\n      if (bin_in[i] >= 5) begin\n        bcd[1][i] = 1;\n        bcd[2][i] = bin_in[i] - 5;\n      end else begin\n        bcd[2][i] = bin_in[i];\n      end\n    end\n\n    // Output BCD digits\n    bcd_out1 <= bcd[1];\n    bcd_out2 <= bcd[2];\n  end\n\nendmodule"}
{"instruction": "\n\nCreate a Verilog module for a 4-to-1 multiplexer with inputs A, B, C, and D and a 2-bit select input S. The output of the module is the selected input based on the value of S. The module should have the following interface:\n\n```\nmodule mux4to1(\n    input wire [3:0] A,\n    input wire [3:0] B,\n    input wire [3:0] C,\n    input wire [3:0] D,\n    input wire [1:0] S,\n    output wire [3:0] Y\n);\n```\n\nThe module should use a case statement to select the appropriate input based on the value of S. If S is 2'b00, the output should be A. If S is 2'b01, the output should be B. If S is 2'b10, the output should be C. If S is 2'b11, the output should be D.\n\nAssume that the inputs A, B, C, and D are valid at all times and that the select input S changes only on the positive edge of the clock.\n\n", "output": "module mux4to1(\n    input wire [3:0] A,\n    input wire [3:0] B,\n    input wire [3:0] C,\n    input wire [3:0] D,\n    input wire [1:0] S,\n    output wire [3:0] Y\n);\nreg [3:0] Y_reg;\n\nalways @(posedge clk) begin\n    case (S)\n        2'b00: Y_reg <= A;\n        2'b01: Y_reg <= B;\n        2'b10: Y_reg <= C;\n        2'b11: Y_reg <= D;\n    endcase\nend\n\nassign Y = Y_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple calculator. The calculator should be able to perform basic arithmetic operations such as addition and subtraction. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: clock signal\n- `reset`: reset signal\n- `operation`: a 2-bit input that specifies the operation to perform. `00` represents addition, and `01` represents subtraction.\n- `operand1`: a 8-bit input that represents the first operand.\n- `operand2`: a 8-bit input that represents the second operand.\n\nOutputs:\n- `result`: an 8-bit output that represents the result of the operation.\n\nYou should implement the calculator using a single always block.\n\n", "output": "module calculator(\n    input clk,\n    input reset,\n    input [1:0] operation,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output [7:0] result\n);\n\nreg [7:0] temp_result;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        temp_result <= 8'h00;\n    end else begin\n        case (operation)\n            2'b00: temp_result <= operand1 + operand2;\n            2'b01: temp_result <= operand1 - operand2;\n        endcase\n    end\nend\n\nassign result = temp_result;\n\nendmodule"}
{"instruction": "Create an XOR gate using a behavioral always block and a tri-state buffer. The module should take two input signals and provide a single output signal that is the result of the XOR operation. The output signal should be able to be tri-stated when a control signal is asserted.", "output": "module xor_gate(input a, b, control, output reg out);\n  wire xor_result;\n  assign xor_result = a ^ b;\n  \n  always @(*) begin\n    if (control == 1'b1) begin\n      out <= 1'bz;\n    end else begin\n      out <= xor_result;\n    end\n  end\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit up/down counter with a load input. The module should have four inputs: a clock input, an up/down input, a load input, and a reset input. The module should have a 4-bit output representing the current count value. When the load input is high, the module should load the value on the input data lines. When the load input is low and the clock input is high, the module should increment or decrement the count value based on the up/down input. The module should output the current count value on the output lines. When the reset input is high, the module should reset the count value to zero.", "output": "module up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    input reset,\n    output reg [3:0] count,\n    input [3:0] data_in\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else if (load) begin\n            count <= data_in;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a 2-bit magnitude comparator using a combinational always block. The module should have two 2-bit inputs (A and B) and one output (out). The output should be high if A is greater than or equal to B, otherwise it should be low. You can use any logical operators and conditional statements to implement the comparator.", "output": "module mag_comp_comb (\n  input [1:0] A,\n  input [1:0] B,\n  output out\n);\n\n  always @* begin\n    if (A >= B) begin\n      out = 1;\n    end\n    else begin\n      out = 0;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with implementing a Verilog module that checks for a specific property. The module should be named `property_checker` and should have the following inputs and outputs:\n\nInputs:\n- `clock`: a single bit input representing the clock signal.\n- `reset`: a single bit input representing the reset signal.\n- `data`: a 4-bit input representing the data to be checked.\n\nOutputs:\n- `property_met`: a single bit output representing whether or not the property is met.\n\nThe property that needs to be checked is as follows: if the `data` input is equal to `4'b1100` for 3 consecutive clock cycles, then the `property_met` output should be set to 1.\n\nYou should assume that the clock signal has a frequency of 10MHz, and that the reset signal is synchronous to the clock signal. The reset signal should reset the module to its initial state, where the `property_met` output is set to 0.\n\nWrite a Verilog module that implements the `property_checker` module as described above. Your module should be no longer than 200 lines of code.\n\n", "output": "module property_checker(\n    input clock,\n    input reset,\n    input [3:0] data,\n    output reg property_met\n);\n\nreg [2:0] count;\n\nalways @(posedge clock or posedge reset) begin\n    if (reset) begin\n        count <= 3'b0;\n        property_met <= 1'b0;\n    end else begin\n        if (data == 4'b1100) begin\n            count <= count + 1;\n        end else begin\n            count <= 3'b0;\n        end\n        \n        if (count == 3) begin\n            property_met <= 1'b1;\n        end else begin\n            property_met <= 1'b0;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit ripple carry adder. The module should have two inputs (A and B) and two outputs (S and C). A and B are 4-bit 2's complement numbers, and S is their sum. C is the carry out of the most significant bit. The module should also have an asynchronous reset input that sets S and C to 0 regardless of the input values.", "output": "module ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input areset,\n    output [3:0] S,\n    output C\n);\n\n    reg [3:0] S_reg;\n    reg C_reg;\n\n    always @(*) begin\n        if (areset) begin\n            S_reg <= 4'b0;\n            C_reg <= 1'b0;\n        end\n        else begin\n            S_reg <= A + B + C_reg;\n            C_reg <= (S_reg[3] & (A[3] ^ B[3])) | (A[3] & B[3]);\n        end\n    end\n\n    assign S = S_reg;\n    assign C = C_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module that takes in two inputs, `data_in` and `write_en`, and outputs `data_out`. The module should implement a register with the following behavior:\n\n1. When `write_en` is high, the value of `data_in` should be stored in the register.\n2. When `write_en` is low, the value of `data_out` should be the value stored in the register.\n\nWrite a verilog module that implements this register behavior.\n\n", "output": "module register_behavior(\n    input wire clk,\n    input wire resetn,\n    input wire write_en,\n    input wire [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn) begin\n            data_out <= 8'h00;\n        end else if (write_en) begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a register with enable, clear, and preset functionalities. The module should have the following input and output ports:\n\n**Input Ports:**\n- `clk`: the clock signal\n- `ena`: the enable signal\n- `d`: the data input\n- `clrn`: the clear signal\n- `prn`: the preset signal\n\n**Output Ports:**\n- `q`: the output data\n\nThe module should operate as follows:\n- When `ena` is high, the data input `d` should be loaded into the register on the rising edge of the clock signal `clk`.\n- When `clrn` is low, the register should be cleared to 0 on the rising edge of the clock signal `clk`.\n- When `prn` is low, the register should be preset to 1 on the rising edge of the clock signal `clk`.\n- When `ena` is low, the register should hold its current value.\n\nYour task is to implement the Verilog module that meets the above requirements.\n\n", "output": "module my_register (\n    input clk,\n    input ena,\n    input d,\n    input clrn,\n    input prn,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (clrn == 1'b0) // clear\n            q <= 1'b0;\n        else if (prn == 1'b0) // preset\n            q <= 1'b1;\n        else if (ena == 1'b1) // enable\n            q <= d;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple calculator that can perform addition and subtraction of two 8-bit numbers. The module should have two input ports, `a` and `b`, and two output ports, `result` and `overflow`. \n\nThe `a` and `b` ports should be 8-bit binary numbers in two's complement representation. The `result` port should output the 8-bit binary result of the addition or subtraction of `a` and `b`. The `overflow` port should output a single bit indicating whether an overflow occurred during the operation. An overflow should be considered to occur when the result of the operation is outside the range of representable 8-bit two's complement numbers.\n\nYou should implement the module using behavioral verilog, and ensure that it is synthesizable.\n\n", "output": "module calculator(\n  input signed [7:0] a,\n  input signed [7:0] b,\n  output reg signed [7:0] result,\n  output reg overflow\n);\n\n  always @* begin\n    result = a + b;\n    if ((a[7] == b[7]) && (a[7] != result[7]))\n      overflow = 1;\n    else\n      overflow = 0;\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a sequential circuit with a clock signal and a single input 'a'. The circuit should generate an output 'q' based on the given simulation waveforms. Analyze the waveform to determine the pattern and logic of the circuit. Implement the target module using flip-flops, gates, and other necessary components within 100 words.", "output": "module sequential_circuit (\n  input clk,\n  input a,\n  output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n  q1 <= a;\n  q2 <= q1;\n  q <= q2;\nend\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a D flip-flop with synchronous clear functionality. The module should have three inputs: Clk (clock), D (data), and Clr (clear). The output of the module should be a single bit, Q.\n\nThe module should behave as follows:\n- When Clr is high (1), Q should be set to 0, regardless of the value of D.\n- When Clr is low (0), Q should take on the value of D on the rising edge of Clk.\n\nWrite a Verilog module that implements this functionality. Your module should be named \"d_ff_with_sync_clr\" and should use the \"always\" keyword to define its behavior. You may assume that all inputs are synchronous to the same clock signal.\n\n", "output": "module d_ff_with_sync_clr (Clk, D, Q, Clr);\n  input Clk, D, Clr;\n  output reg Q;\n  always @ ( posedge Clk)\n\t if (Clr)\n\t begin\n\t\tQ <= 1'b0;\n\t end else\n\t begin\n\t\tQ <= D;\n\t end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 4-bit unsigned binary numbers as inputs, `a` and `b`, and outputs the sum of these two numbers, `sum`, as a 5-bit unsigned binary number. The module should also output a `carry_out` signal indicating whether there is a carry-out from the most significant bit of the sum.\n\nYour module should be named `add_4bit`.\n\nYou should assume that the inputs are valid, and no overflow or underflow occurs.\n\n", "output": "module add_4bit (\n\tinput [3:0] a,\n\tinput [3:0] b,\n\toutput [4:0] sum,\n\toutput carry_out\n);\n\n\twire [3:0] sum_4bit;\n\twire carry_out_4bit;\n\n\t// perform the addition\n\tassign sum_4bit = a + b;\n\n\t// check for carry-out\n\tassign carry_out_4bit = (sum_4bit[4] == 1);\n\n\t// pad the sum with a leading zero\n\tassign sum = {1'b0, sum_4bit};\n\n\t// output the results\n\tassign carry_out = carry_out_4bit;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that takes in a binary number and outputs the number of 1's in the binary representation of the input. For example, if the input is 101010, the output should be 3. You are only allowed to use one module to solve this problem. \n\nDesign a Verilog module named `binary_ones_counter` that takes in a 8-bit binary number `bin_in` and outputs a 3-bit binary number `count_out` representing the number of 1's in the binary representation of `bin_in`. \n\nYou are not allowed to use any built-in functions or operators that directly count the number of 1's in a binary number, such as `$countones`. You can only use basic logic gates (AND, OR, NOT, XOR), bitwise operators (AND, OR, NOT, XOR, left shift, right shift), and conditional operators (if-else statements). \n\nAssume that the input `bin_in` is always 8 bits long and that the output `count_out` is always 3 bits long. \n\n", "output": "module binary_ones_counter(\n    input [7:0] bin_in,\n    output reg [2:0] count_out\n);\n\n    always @* begin\n        count_out = 0;\n        for (i = 0; i < 8; i = i + 1) begin\n            if (bin_in[i] == 1) begin\n                count_out = count_out + 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been given a Verilog module `qqq_sum` that takes in two 32-bit inputs `A` and `B`, a carry-in input `Cin`, and outputs the sum of `A`, `B`, and `Cin` in a 32-bit output `R`. Your task is to modify the module to implement a subtraction operation instead of an addition operation. \n\nYou need to implement this subtraction operation using only the existing inputs and outputs of the module. You are not allowed to add any additional inputs or outputs. You are also not allowed to use any other modules or functions in your implementation. \n\nYour modified module should behave as follows: when `Cin` is 0, the output `R` should be equal to `A - B`. When `Cin` is 1, the output `R` should be equal to `A - B - 1`. \n\nWrite the modified Verilog module `qqq_sub` that implements this subtraction operation. \n\n", "output": "module qqq_sub( input[31:0]  A, B,\n                output[31:0] R,\n                input  Cin );\n\nassign R = A - B - Cin;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a clock gate module in Verilog. The module should take in three inputs: a clock signal `CLK`, an enable signal `EN`, and a test enable signal `TE`. The module should output a gated clock signal `ENCLK`. The clock gate module should use a D flip-flop with an enable input to gate the clock signal `CLK`. The enable input should be controlled by the enable signal `EN` and the test enable signal `TE`. When `EN` is high and `TE` is low, the clock signal `CLK` should pass through the flip-flop and appear at the output `ENCLK`. When `EN` is low or `TE` is high, the clock signal `CLK` should be gated and `ENCLK` should be low.\n\nYou should write a Verilog module that implements the clock gate described above. Your module should be named `clock_gate` and should have the following inputs and outputs:\n\n- `CLK` (input): a 1-bit clock signal\n- `EN` (input): a 1-bit enable signal\n- `TE` (input): a 1-bit test enable signal\n- `ENCLK` (output): a 1-bit gated clock signal\n\nThe clock gate module should be implemented in no more than 200 lines of Verilog code.\n\n", "output": "module clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  reg gated_clk;\n  always @(posedge CLK) begin\n    if (EN && !TE) begin\n      gated_clk <= 1'b1;\n    end else begin\n      gated_clk <= 1'b0;\n    end\n  end\n\n  TLATNTSCAX2TS latch (\n    .E(EN),\n    .SE(TE),\n    .CK(CLK),\n    .ECK(ENCLK)\n  );\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in a 4-bit input signal `data_i`, a write enable signal `we_i`, a clock signal `clk_i`, and a reset signal `rst_i`. The module should output a 4-bit signal `data_o` and a flag signal `flag_o`. The `data_o` output should be the input `data_i` shifted left by one bit position on every rising edge of the clock signal, with the least significant bit being replaced by the value of `we_i`. The `flag_o` output should be set to 1 if the output `data_o` is equal to the input `data_i` on any given clock cycle.\n\nWrite a verilog module that implements this functionality.\n\n", "output": "module shift_reg (\n  input  [3:0] data_i,\n  input        we_i,\n  input        clk_i,\n  input        rst_i,\n  output [3:0] data_o,\n  output       flag_o\n);\n\nreg [3:0] shift_reg;\nreg        flag_reg;\n\nalways @(posedge clk_i or posedge rst_i) begin\n  if (rst_i) begin\n    shift_reg <= 4'b0;\n    flag_reg  <= 1'b0;\n  end\n  else begin\n    shift_reg <= {shift_reg[2:0], we_i};\n    flag_reg  <= (shift_reg == data_i);\n  end\nend\n\nassign data_o = shift_reg;\nassign flag_o = flag_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that assigns the output one to a value of 1. This module should have an input that is a 1-bit enable signal, which controls whether the output is 1 or 0. When the enable signal is 1, the output should be 1, and when the enable signal is 0, the output should be 0. This module can be used to control the value of a signal based on an enable signal.", "output": "module constant_enable (\n  input clk,\n  input reset,\n  input enable,\n  output reg out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      out <= 0;\n    end else if (enable) begin\n      out <= 1;\n    end else begin\n      out <= 0;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a priority encoder. The priority encoder should take in 4 inputs (A1, A2, A3, A4) and produce a 2-bit output (X). The output should be the binary representation of the highest input that is asserted. For example, if A3 and A4 are both asserted, X should be 11 (binary for 3).\n\nYou should implement the priority encoder using a combinational circuit. Your Verilog module should be named \"priority_encoder\" and should be contained within 200 lines of code.\n\n", "output": "module priority_encoder (\n    input A1,\n    input A2,\n    input A3,\n    input A4,\n    output reg [1:0] X\n);\n\nalways @* begin\n    if (A4) begin\n        X = 2'b11;\n    end else if (A3) begin\n        X = 2'b10;\n    end else if (A2) begin\n        X = 2'b01;\n    end else if (A1) begin\n        X = 2'b00;\n    end else begin\n        X = 2'b00;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a 32-bit input signal `in` and outputs a 16-bit signal `out`. The `out` signal should contain the 16 least significant bits of the `in` signal. \n\nDesign a verilog module that meets these requirements. \n\nYour module should be named `lsb_extractor` and should have the following ports:\n\n- `input [31:0] in`: a 32-bit input signal\n- `output [15:0] out`: a 16-bit output signal\n\nYour module should extract the 16 least significant bits of the `in` signal and assign them to the `out` signal.\n\n", "output": "module lsb_extractor (\n    in,\n    out\n);\n\n    input [31:0] in;\n    output [15:0] out;\n\n    assign out[15:0] = in[15:0];\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module for a 2-to-1 multiplexer (MUX) with a control signal. The module should have three inputs: A0, A1, and S, and one output, X. The control signal S will determine which input is selected and passed to the output. If S is 0, then input A0 should be passed to the output X. If S is 1, then input A1 should be passed to the output X. Your module should be named \"mux_2to1\".\n\nYou should write a Verilog module with the above specifications and ensure that it can be simulated correctly.\n\n", "output": "module mux_2to1 (\n  input A0,\n  input A1,\n  input S,\n  output X\n);\n\n  // select A0 if S is 0, A1 if S is 1\n  assign X = (!S) ? A0 : A1;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that controls the output clock signal based on an input clock signal and an enable signal. The module should be named \"clock_control_altclkctrl_0\" and should have three ports: ena, inclk, and outclk. The ena port is a single bit input that enables the output clock signal when high. The inclk port is a single bit input that represents the input clock signal. The outclk port is a single bit output that represents the output clock signal.\n\nYour module should have the following functionality:\n- When the ena input is low, the outclk output should be low.\n- When the ena input is high, the outclk output should be high when the inclk input is high and low when the inclk input is low.\n- The output clock signal should have a frequency that is half of the input clock signal frequency.\n- The module should synthesize without warnings or errors.\n\nWrite a module in Verilog that satisfies the above requirements. Your module should be no longer than 200 lines of code.\n\n", "output": "module clock_control_altclkctrl_0 (\n    input ena,\n    input inclk,\n    output reg outclk\n);\n\nreg inclk_reg;\nreg [31:0] counter;\n\nalways @ (posedge inclk or negedge ena) begin\n    if (!ena) begin\n        outclk <= 1'b0;\n        counter <= 0;\n    end\n    else begin\n        inclk_reg <= inclk;\n        counter <= counter + 1;\n        if (counter == 1) begin\n            outclk <= inclk_reg;\n        end\n        else if (counter == 2) begin\n            outclk <= ~inclk_reg;\n            counter <= 0;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit binary input and outputs the two's complement equivalent. The module should use a combinational design approach and should have a single input and output. Two's complement is a mathematical operation on binary numbers where the most significant bit represents the sign of the number, and the remaining bits represent the magnitude.", "output": "module twos_complement (\n    input [3:0] binary_in,\n    output reg [3:0] twos_comp_out\n);\n\nassign twos_comp_out = (~binary_in) + 1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four inputs and produces one output. The inputs are A1, A2, A3, and B1 and the output is X. You are given a code snippet for a module called sky130_fd_sc_lp__o31a_4 which has the correct input and output ports defined, as well as voltage supply signals. Your task is to complete the module by writing the logic for the sky130_fd_sc_lp__o31a base module.\n\nThe sky130_fd_sc_lp__o31a base module has five input ports and one output port. The input ports are X, A1, A2, A3, and B1, and the output port is X. The module should implement the following logic:\n\n- If A1 is high and A2 is low, X should be high\n- If A1 is low and A2 is high, X should be low\n- If A1 and A2 are both high or both low, X should be the same as A3\n- If B1 is high, X should be the opposite of whatever the previous logic determined\n\nWrite the logic for the sky130_fd_sc_lp__o31a base module using Verilog.\n\n", "output": "module sky130_fd_sc_lp__o31a (\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    wire X1;\n    wire X2;\n    wire X3;\n\n    assign X1 = (A1 == 1 && A2 == 0) ? 1 : 0;\n    assign X2 = (A1 == 0 && A2 == 1) ? 0 : 1;\n    assign X3 = (A1 == A2) ? A3 : ~A3;\n\n    assign X = (B1 == 1) ? ~X3 : (X1 | X2 | X3);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in three input signals and produces one output signal. The input signals are `io_valid_0`, `io_ready`, and `choose`. The `io_valid_0` signal is a single bit input, while `io_ready` and `choose` are single bit outputs. You need to design a module that outputs the value of `choose` based on the value of `io_valid_0`. If `io_valid_0` is 1, `choose` should be 0, and if `io_valid_0` is 0, `choose` should be 1. The module should only output a value for `choose` when `io_ready` is 1.\n\nYou need to create a module named `ChooseModule` that implements this behavior. The module should take in the following inputs and outputs:\n\n- `io_valid_0`: A single bit input signal.\n- `io_ready`: A single bit input signal.\n- `choose`: A single bit output signal.\n\nYour implementation should be done using Verilog.\n\n", "output": "module ChooseModule(\n    input  io_valid_0,\n    input  io_ready,\n    output io_chosen\n);\n\n  assign io_chosen = io_ready ? ~io_valid_0 : 1'b1; \n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that generates an external clock signal from an input clock signal. The module should be named `extclk_generator` and should have the following inputs and outputs:\n\nInputs:\n- `clk_in`: a 50 MHz input clock signal\n- `rst`: a synchronous reset signal\n\nOutputs:\n- `ext_clk`: a 10 MHz output clock signal\n\nThe `ext_clk` signal should be generated by dividing the `clk_in` signal by a factor of 5. The output clock signal should have a 50% duty cycle.\n\nYour task is to implement the `extclk_generator` module in Verilog and ensure that it meets the above requirements.\n\n", "output": "module extclk_generator(\n    input clk_in,\n    input rst,\n    output reg ext_clk\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk_in, posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        ext_clk <= 0;\n    end else begin\n        counter <= counter + 1;\n        if (counter == 4) begin\n            counter <= 0;\n            ext_clk <= ~ext_clk;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 2-input half adder. The module should have two input ports, A and B, and two output ports, SUM and CARRY_OUT. It should be implemented using sky130_fd_sc_hd library. The module should also include the necessary voltage supply signals.\n\nPlease write the verilog code for the module and ensure that it follows the following requirements:\n- The module should be named \"half_adder\"\n- The module should use the sky130_fd_sc_hd library\n- The module should have two input ports, A and B, and two output ports, SUM and CARRY_OUT\n- The module should include the necessary voltage supply signals\n\n", "output": "module half_adder (\n    input A,\n    input B,\n    output SUM,\n    output CARRY_OUT\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // XOR gate for SUM\n    assign SUM = A ^ B;\n\n    // AND gate for CARRY_OUT\n    assign CARRY_OUT = A & B;\n\nendmodule"}
{"instruction": "Design a half adder using only NAND gates. The half adder should take two input bits and produce a sum and carry-out bit. The module must be named \"half_adder_nand\" and have inputs \"a\" and \"b\" and outputs \"sum\" and \"cout\".", "output": "module half_adder_nand( \n    input a, b,\n    output sum, cout );\n    \n    wire s1, s2, c1;\n    \n    nand(s1, a, b);\n    nand(s2, a, s1);\n    nand(c1, s1, b);\n    \n    assign sum = s2;\n    assign cout = c1;\n    \nendmodule"}
{"instruction": "Please act as a professional verilog designer. Build a module that implements a 4-bit magnitude comparator. The module should take two 4-bit inputs, A and B, and output a 1-bit value indicating whether A is greater than or equal to B. Use a combination of AND, OR, and XOR gates to implement the circuit.", "output": "module magnitude_comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output reg greater_or_equal\n);\n\n    // Compare the MSB of A and B\n    assign greater_or_equal = (A[3] & ~B[3]) | ((A[3] ^ B[3]) & ~(A[2:0] ^ B[2:0]));\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a 2:1 multiplexer using only NAND gates. The module should have three inputs: A, B, and S, where A and B are the two inputs to be selected from and S is the selection signal. The output of the module should be Y, which is equal to A when S is 0 and B when S is 1.\n\nYou should write a Verilog module that implements the 2:1 multiplexer using only NAND gates. Your module should be named `nand_mux` and should have the following ports:\n- `A`: input, 1-bit\n- `B`: input, 1-bit\n- `S`: input, 1-bit\n- `Y`: output, 1-bit\n\nAssume that the inputs A and B are valid and stable before the selection signal S changes.\n\nYou may only use NAND gates in your implementation and may not use any other gates or modules. Your implementation should be within 200 lines of Verilog code.\n\n", "output": "module nand_mux(\n    input A,\n    input B,\n    input S,\n    output Y\n);\n\n    wire nand0_out;\n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n\n    nand nand0(nand0_out, A, S);\n    nand nand1(nand1_out, B, S);\n    nand nand2(nand2_out, nand0_out, nand0_out);\n    nand nand3(Y, nand1_out, nand1_out, nand2_out);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a UART log module that logs incoming data into a text file. The module has four inputs: `clk`, `data`, `strobe`, and `valid`. The module should only log incoming data when `valid` and `strobe` are high at the same time. The `data` input is 8 bits wide and contains the data to be logged. The `clk` input is the clock signal used by the module. \n\nIn the simulation-only contents, the module contains a register `text_handle` which is used to store the handle of the text file. The text file is opened using `$fopen` function and the handle is stored in `text_handle`. The `always` block is used to write incoming data to the text file. If `valid` and `strobe` are high at the same time, `$fwrite` function is used to write the data to the text file. The module should send a linefeed character (`\\n`) instead of a carriage return character (`\\r`) if `data` is equal to `8'hd`. The `$fflush` function is used to flush the data stream.\n\nDesign a Verilog module `uart_log_module` that implements the above functionality.\n\n", "output": "module uart_log_module (\n  input clk,\n  input [7:0] data,\n  input strobe,\n  input valid\n);\n\n  reg [31:0] text_handle; // for $fopen\n  \n  initial begin\n    text_handle = $fopen (\"uart_log_module.txt\");\n  end\n  \n  always @(posedge clk) begin\n    if (valid && strobe) begin\n      if (data == 8'hd) begin\n        $fwrite (text_handle, \"%c\", 8'ha);\n      end else begin\n        $fwrite (text_handle, \"%c\", data);\n      end\n      $fflush (text_handle);\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four input signals and produces one output signal. The module should be named `my_module` and should have the following ports:\n\n- `input A1`\n- `input A2`\n- `input B1`\n- `input B2`\n- `output X`\n\nThe output signal `X` should be equal to `1` if the following conditions are met:\n\n- `A1` and `A2` are both equal to `1`\n- `B1` and `B2` are both equal to `0`\n\nOtherwise, the output signal `X` should be equal to `0`.\n\nYou are free to use any gates or combination of gates to implement the module, but the entire module must be contained within 200 lines of Verilog code.\n\nImplement the `my_module` module and verify its functionality using a testbench.\n\n", "output": "module my_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire and1_out;\n    wire and2_out;\n    wire not1_out;\n\n    and and1 (and1_out, A1, A2);\n    and and2 (and2_out, B1, B2);\n    not not1 (not1_out, and2_out);\n\n    assign X = and1_out & not1_out;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a pipelined module that takes in a 4-bit binary number and outputs the next highest value that can be represented with 4 bits. If the input is already the highest value, the output should be the lowest value. Use pipeline structure to achieve this functionality.", "output": "module next_highest (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(*) begin\n    stage1_out = in + 1;\nend\n\nalways @(*) begin\n    if (stage1_out == 4'b1111) begin\n        stage2_out = 4'b0000;\n    end else begin\n        stage2_out = stage1_out;\n    end\nend\n\nalways @(posedge clk) begin\n    out <= stage2_out;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a simple logic buffer. The module should have one input port, A, and one output port, X. The module should also have four power supply ports: VPB, VPWR, VGND, and VNB. \n\nThe input port, A, should be a single-bit signal, while the output port, X, should also be a single-bit signal. The power supply ports should be single-bit signals as well. \n\nYour module should implement the following logic: when the input signal, A, is high, the output signal, X, should also be high. When the input signal, A, is low, the output signal, X, should also be low. \n\nYou should name your module sky130_fd_sc_hvl__buf and ensure that it is self-contained, meaning that it does not rely on any other modules to function.\n\n", "output": "module sky130_fd_sc_hvl__buf (\n    input  A   ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\nassign X = A;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a 4-bit binary input and outputs a 3-bit binary number. The output is determined by the input according to the following rules:\n\n- If the input is 000, 001, 010, or 011, the output is the input value shifted left by 1 bit.\n- If the input is 100, 101, 110, or 111, the output is the input value shifted right by 1 bit.\n\nImplement this functionality in a verilog module named `shift3`. The module should have the following interface:\n\nInputs:\n- `clk` (1-bit): The clock signal.\n- `in` (4-bit): The input value.\n\nOutputs:\n- `out` (3-bit): The output value.\n\nAssume that the input value will only be valid on the rising edge of the clock signal.\n\n", "output": "module shift3(clk, in, out);\ninput clk;\ninput [3:0] in;\noutput [2:0] out;\nreg [2:0] out;\n\nalways @(posedge clk) begin\n    case (in)\n        4'b0000, 4'b0001, 4'b0010, 4'b0011:\n            out <= {in[2:0], 1'b0};\n        4'b1000, 4'b1001, 4'b1010, 4'b1011:\n            out <= {1'b0, in[3:1]};\n        default:\n            out <= 3'b0;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in 3 data signals and 4 power signals, and outputs a single signal. The data signals are represented by a single input port `A` and a single output port `X`. The power signals are represented by input ports `VPB`, `VPWR`, `VGND`, and `VNB`. \n\nYour module should be named `data_power_module` and should include the following:\n- A `reg` named `data_reg` that is 8 bits wide\n- A `wire` named `power_wire` that is 1 bit wide\n- A `wire` named `data_power_wire` that is 1 bit wide\n\nThe `data_reg` should be assigned the value of the `A` input at the rising edge of `VPB`. The `power_wire` should be assigned the value of the `VPWR` input. The `data_power_wire` should be assigned the value of the AND operation between `data_reg` and `power_wire`.\n\nYour module should be tested with the following testbench:\n- `A` input is set to 1 for the first 5 clock cycles, then set to 0 for the next 5 clock cycles, and then set to 1 again for the last 5 clock cycles.\n- `VPB` is set to 0 for the first 10 clock cycles and then set to alternate between 1 and 0 for the remaining clock cycles.\n- `VPWR` is set to alternate between 1 and 0 for all clock cycles.\n- `VGND` and `VNB` are set to 0 for all clock cycles.\n\nYour task is to implement the `data_power_module` and ensure that it passes the provided testbench.\n\n", "output": "module data_power_module (\n    input  A   ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    reg [7:0] data_reg;\n    wire power_wire;\n    wire data_power_wire;\n\n    always @(posedge VPB) begin\n        data_reg <= A;\n    end\n\n    assign power_wire = VPWR;\n\n    assign data_power_wire = data_reg & power_wire;\n\n    assign X = data_power_wire;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 8-bit shift register with parallel load. The module should have three inputs: a clock input, a parallel load input, and an 8-bit data input. The module should have one output, an 8-bit data output. On the rising edge of the clock, if the parallel load input is high, the data input should be loaded into the shift register. Otherwise, the data in the shift register should be shifted left by one bit, and the least significant bit should be replaced by a zero. The data output should always reflect the current contents of the shift register.", "output": "module shift_register_8bit (\n    input clk,\n    input load,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data_in;\n    end else begin\n        shift_reg <= {shift_reg[6:0], 1'b0};\n    end\nend\n\nassign data_out = shift_reg;\n\nendmodule"}
{"instruction": "\n\nYou have been given a 4-bit ALU (Arithmetic Logic Unit) module in Verilog, which performs various arithmetic and logical operations on two 4-bit inputs A and B. The module has four inputs: A, B, CIN (carry-in), and BINV (invert B). It also has two control inputs: OP[1:0] for selecting one of the four operations to be performed, and COUT (carry-out) and Y[3:0] as outputs. \n\nYour task is to write the Verilog code for the 4-bit ALU module that performs the following operations based on the control inputs:\n\n- OP = 00: Y = A + B (addition), COUT = carry-out from addition\n- OP = 01: Y = A - B (subtraction), COUT = borrow-out from subtraction\n- OP = 10: Y = A AND B (logical AND), COUT = 0\n- OP = 11: Y = A OR B (logical OR), COUT = 0\n\nYou should assume that the input values for A and B are provided in binary format, while CIN and BINV are provided in boolean format. The output value for Y should also be in binary format, while COUT should be in boolean format.\n\n", "output": "module alu4bit(\n  input [3:0] A, B,\n  input CIN, BINV,\n  input [1:0] OP,\n  output reg COUT,\n  output reg [3:0] Y\n);\n\n  reg [3:0] B_inv;\n  assign B_inv = BINV ? ~B : B;\n  \n  always @(*) begin\n    case(OP)\n      2'b00: begin // Addition\n        Y = A + B_inv + CIN;\n        COUT = Y[4];\n      end\n      2'b01: begin // Subtraction\n        Y = A - B_inv - ~CIN;\n        COUT = ~Y[4];\n      end\n      2'b10: begin // Logical AND\n        Y = A & B_inv;\n        COUT = 1'b0;\n      end\n      2'b11: begin // Logical OR\n        Y = A | B_inv;\n        COUT = 1'b0;\n      end\n    endcase\n  end\nendmodule"}
{"instruction": "\n\nYou are designing a circuit that will take in a 4-bit input `data_in` and output a 3-bit value `data_out`. The circuit will use a lookup table to determine the output value based on the input value. The lookup table will be implemented using a 16x3 ROM.\n\nDesign a Verilog module `lookup_table` that takes in a 4-bit input `data_in` and outputs a 3-bit value `data_out`.\n\nThe lookup table should be initialized with the following values:\n```\ndata_in | data_out\n--------|---------\n0000    | 011\n0001    | 000\n0010    | 101\n0011    | 010\n0100    | 111\n0101    | 001\n0110    | 100\n0111    | 110\n1000    | 010\n1001    | 100\n1010    | 001\n1011    | 111\n1100    | 110\n1101    | 011\n1110    | 000\n1111    | 101\n```\nUse behavioral modeling to implement the `lookup_table` module.\n\n", "output": "module lookup_table(\n    input [3:0] data_in,\n    output reg [2:0] data_out\n);\n\nreg [2:0] memory [15:0];\n\ninitial begin\n    memory[0] = 3'b011;\n    memory[1] = 3'b000;\n    memory[2] = 3'b101;\n    memory[3] = 3'b010;\n    memory[4] = 3'b111;\n    memory[5] = 3'b001;\n    memory[6] = 3'b100;\n    memory[7] = 3'b110;\n    memory[8] = 3'b010;\n    memory[9] = 3'b100;\n    memory[10] = 3'b001;\n    memory[11] = 3'b111;\n    memory[12] = 3'b110;\n    memory[13] = 3'b011;\n    memory[14] = 3'b000;\n    memory[15] = 3'b101;\nend\n\nalways @(*) begin\n    data_out = memory[data_in];\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a D latch. \nA D latch is a type of sequential circuit that can store one bit of data. It has two inputs: D (data) and C (clock), and one output: Q (output). \nWhen the clock signal is high, the D input is stored in the latch and appears at the output Q. When the clock signal is low, the latch holds its previous output value.\n\nYour module should have the following inputs and outputs:\n\nInputs: D (data), C (clock)\nOutputs: Q (output)\n\nTo implement the D latch, you should use Verilog code to describe the behavior of the latch. \nYou should use a single always block to define the behavior of the latch. \nThis always block should trigger on the positive edge of the clock signal and update the output Q with the value of the input D. \nWhen the clock signal is low, the latch should hold its previous output value.\n\nYou should use the following Verilog code to define the module and its IO:\n\nmodule d_latch(\n  input D,\n  input C,\n  output Q\n);", "output": "module d_latch(\n  input D,\n  input C,\n  output Q\n);\n\n  reg Q;\n\n  always @(posedge C) begin\n    if (C) begin\n      Q <= D;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, a multiplexer (MUX) is a device that selects one of several input signals and forwards the selected input into a single output line. In this problem, you are asked to design a 2:1 MUX using Verilog. The module should have two input signals (A and B), one select signal (SEL), and one output signal (Y). When SEL is 0, the output should be equal to A. When SEL is 1, the output should be equal to B. \n\nCreate a Verilog module that implements a 2:1 MUX with the following interface:\n\n```\nmodule mux_2to1 (\n  input A,\n  input B,\n  input SEL,\n  output Y\n);\n```\n\nAssume that all input signals are single-bit binary values (0 or 1). You are not allowed to use any built-in Verilog operators or keywords for this problem. You can only use basic logic gates such as AND, OR, NOT, and XOR.\n\n", "output": "module mux_2to1 (\n  input A,\n  input B,\n  input SEL,\n  output Y\n);\n\n  wire NOT_SEL;\n  wire AND1;\n  wire AND2;\n  wire OR;\n\n  assign NOT_SEL = ~SEL;\n  assign AND1 = A & NOT_SEL;\n  assign AND2 = B & SEL;\n  assign OR = AND1 | AND2;\n\n  assign Y = OR;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in four inputs and produces one output. The inputs consist of a single bit `PIN2`, two bits `GIN1` and `GIN2`, and a clock signal `PHI`. The output is a single bit `GOUT`.\n\nYour task is to create a Verilog module named `BLOCK2A` that implements the following logic:\n\n- If `GIN2` is high (1), then `GOUT` should be low (0).\n- If `GIN2` is low (0), then `GOUT` should be high (1) if either of the following conditions are met:\n  - `PIN2` is low (0) and `GIN1` is high (1).\n  - `PIN2` is high (1) and `GIN1` is low (0).\n\nYou should use the provided code snippet as a starting point for your module.\n\n", "output": "module BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            GOUT_reg <= 1'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit counter with a synchronous reset input. The counter should increment on each rising edge of the clock input, and the reset input should asynchronously clear the counter to 0. Additionally, the module should have an output that is high when the counter reaches its maximum value (15 in this case) and low otherwise.\n\nThe module should have the following interface:\n\n- `clk` (input): the clock input\n- `reset` (input): the asynchronous reset input\n- `count` (output): the 4-bit counter output\n- `max_reached` (output): a signal that is high when the counter reaches its maximum value, and low otherwise\n\nYou can assume that the clock input has a 50% duty cycle and a frequency of 50 MHz.\n\n", "output": "module counter (\n  input clk,\n  input reset,\n  output reg [3:0] count,\n  output reg max_reached\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0;\n      max_reached <= 1'b0;\n    end else begin\n      count <= count + 1;\n      if (count == 4'b1111) begin\n        max_reached <= 1'b1;\n      end else begin\n        max_reached <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit binary number and outputs the Gray code equivalent of the number. Gray code is a binary code where two consecutive values differ by only one bit. For example, the Gray code equivalent of binary 0110 is 0101.", "output": "module binary_to_gray (\n    input [3:0] binary,\n    output reg [3:0] gray\n);\n\nalways @ (binary) begin\n    gray[3] = binary[3];\n    gray[2] = binary[3] ^ binary[2];\n    gray[1] = binary[2] ^ binary[1];\n    gray[0] = binary[1] ^ binary[0];\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that performs a multiply-accumulate (MAC) operation on two 16-bit inputs, A and B, and stores the 32-bit result in C. The module should also have a start-of-frame (SOF) input that indicates the start of a new frame of inputs. The MAC operation should only be performed when SOF is high. \n\nDesign a verilog module that implements the MAC operation and meets the following requirements:\n- The module should have the following inputs: clk (clock), A (16-bit input), B (16-bit input), and sof (start-of-frame).\n- The module should have the following output: C (32-bit output).\n- The module should only perform the MAC operation when SOF is high. \n- The module should use a clock signal to synchronize operations.\n- The module should be solvable by only one module within 200 lines of verilog code.\n\nWrite a verilog module that meets the above requirements. \n\n", "output": "module MAC (\n    input clk, \n    input sof, \n    input [15:0] A, \n    input [15:0] B, \n    output reg [35:0] C\n);\n\nreg [31:0] acc; // accumulator for the MAC operation\n\nalways @(posedge clk) begin\n    if (sof) begin // start of frame\n        acc <= A * B; // perform MAC operation\n        C <= {acc, 4'b0}; // store result in C\n    end else begin\n        acc <= acc + A * B; // accumulate result\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a simple calculator. The calculator should be able to perform basic arithmetic operations such as addition, subtraction, multiplication, and division. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: clock signal\n- `reset_n`: asynchronous active low reset signal\n- `operand1`: 32-bit input operand 1\n- `operand2`: 32-bit input operand 2\n- `operation`: 2-bit input specifying the operation to be performed (00 for addition, 01 for subtraction, 10 for multiplication, and 11 for division)\n\nOutputs:\n- `result`: 32-bit output representing the result of the operation\n\nYou should use the following guidelines when designing the module:\n- The module should use a combinational logic block to perform the arithmetic operation based on the value of the `operation` input.\n- The module should use a register to store the result of the operation, which should be updated on the rising edge of the `clk` signal.\n- The module should assert the `result` output on the rising edge of the `clk` signal.\n\nImplement the verilog module for the calculator.\n\n", "output": "module calculator (\n  input clk,\n  input reset_n,\n  input [31:0] operand1,\n  input [31:0] operand2,\n  input [1:0] operation,\n  output reg [31:0] result\n);\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      result <= 0;\n    end else begin\n      case (operation)\n        2'b00: result <= operand1 + operand2;\n        2'b01: result <= operand1 - operand2;\n        2'b10: result <= operand1 * operand2;\n        2'b11: result <= operand1 / operand2;\n      endcase\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a digital circuit that performs a specific set of operations. The module should have one output and four inputs. The output should be a 16-bit wire, while the inputs should be a 1-bit wire, a 2-bit wire, a 4-bit wire, and a 9-bit wire.\n\nThe circuit should perform the following operations:\n- When the 1-bit input is high, the output should be the bitwise AND of the 2-bit and 4-bit inputs.\n- When the 1-bit input is low, the output should be the bitwise OR of the 2-bit and 9-bit inputs.\n\nDesign the verilog code for this circuit.\n\n", "output": "module digital_circuit(\n  input wire in1,\n  input wire [1:0] in2,\n  input wire [3:0] in3,\n  input wire [8:0] in4,\n  output wire [15:0] out\n);\n\n  assign out = in1 ? (in2 & in3) : (in2 | in4);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with a positive edge-triggered clock and asynchronous reset. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` (1-bit): the positive edge-triggered clock signal\n- `rst_l` (1-bit): the asynchronous active-low reset signal\n- `D` (1-bit): the data input signal\n\nOutputs:\n- `Q` (1-bit): the output signal\n- `Qn` (1-bit): the complement of the output signal\n\nYour module should be named `D_ff_posedge_async_reset` and should be written in Verilog. \n\n", "output": "module D_ff_posedge_async_reset(output Q, Qn, input rst_l, D, clk);\n\n    reg Q_reg, Qn_reg;\n    wire D_bar;\n    \n    assign D_bar = ~D;\n    \n    always @(posedge clk or negedge rst_l) begin\n        if (~rst_l) begin\n            Q_reg <= 1'b0;\n            Qn_reg <= 1'b1;\n        end\n        else begin\n            Q_reg <= D;\n            Qn_reg <= D_bar;\n        end\n    end\n    \n    assign Q = Q_reg;\n    assign Qn = Qn_reg;\n    \nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in four input signals and outputs one signal. The input signals are A1_N, A2_N, B1, and B2, while the output signal is Y. The module also takes in four power signals: VPB, VPWR, VGND, and VNB. \n\nThe module should perform the following operation: \n\n- If A1_N and A2_N are both 0, Y should be 0.\n- If A1_N is 1 and A2_N is 0, Y should be B1.\n- If A1_N is 0 and A2_N is 1, Y should be B2.\n- If A1_N and A2_N are both 1, Y should be the logical OR of B1 and B2.\n\nDesign the module and provide the Verilog code for it. \n\n", "output": "module signal_processing(\n    input A1_N,\n    input A2_N,\n    input B1,\n    input B2,\n    output Y,\n    input VPB,\n    input VPWR,\n    input VGND,\n    input VNB\n);\n\n    wire B1_OR_B2;\n    \n    assign B1_OR_B2 = B1 | B2;\n    \n    assign Y = (A1_N & A2_N) ? B1_OR_B2 : (A1_N & ~A2_N) ? B1 : (~A1_N & A2_N) ? B2 : 0;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked to design a Verilog module that implements a 4:1 multiplexer. The module should have four input signals, `in0`, `in1`, `in2`, and `in3`, and two select signals, `sel0` and `sel1`. The output signal, `out`, should be equal to one of the input signals based on the values of the select signals. The truth table for the 4:1 multiplexer is as follows:\n\n| sel1 | sel0 | out |\n|------|------|-----|\n|  0   |  0   | in0 |\n|  0   |  1   | in1 |\n|  1   |  0   | in2 |\n|  1   |  1   | in3 |\n\nYou should implement this module using only one module within 200 lines of Verilog code. Your module should be named `mux4to1` and should have the following interface:\n\n```\nmodule mux4to1 (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input sel0,\n    input sel1,\n    output reg out\n);\n```\n\nNote that the `out` signal should be a registered output. You may assume that the input signals are stable at the rising edge of the clock signal.\n\n", "output": "module mux4to1 (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input sel0,\n    input sel1,\n    input clk,\n    output reg out\n);\n    \n    always @(posedge clk) begin\n        if (sel1 == 0 && sel0 == 0) begin\n            out <= in0;\n        end else if (sel1 == 0 && sel0 == 1) begin\n            out <= in1;\n        end else if (sel1 == 1 && sel0 == 0) begin\n            out <= in2;\n        end else begin\n            out <= in3;\n        end\n    end\n    \nendmodule"}
{"instruction": "\n\nYou are tasked to design a Verilog module that takes in a 32-bit input signal and splits it into two separate output signals. The first output signal should contain the upper 22 bits of the input signal, while the second output signal should contain the lower 10 bits of the input signal.\n\nDesign a Verilog module that takes in a 32-bit input signal named `input_signal` and outputs two separate signals named `output_upper` and `output_lower`, where `output_upper` is a 22-bit signal containing the upper bits of `input_signal` and `output_lower` is a 10-bit signal containing the lower bits of `input_signal`.\n\nYour module should be named `splitter_module` and should be self-contained within a single file. The module should be designed to be synthesizable and should not contain any procedural blocks.\n\n", "output": "module splitter_module (\n    input [31:0] input_signal,\n    output [21:0] output_upper,\n    output [9:0] output_lower\n);\n\nassign output_upper = input_signal[31:10];\nassign output_lower = input_signal[9:0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a D flip-flop using an always block. The flip-flop should be sensitive to a positive edge of the clock and should have a reset input. When the reset input is high, the flip-flop should be reset to its initial value. The bit-width of the data input and output is 8. Remember to declare all input and output ports, and use appropriate wire and reg types.", "output": "module d_flip_flop (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  output reg [7:0] data_out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_out <= 8'd0;\n    end else begin\n      data_out <= data_in;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with creating a module that takes in a 9-bit control signal and outputs a 4-bit td_mode signal based on the following truth table:\n\n| Control Bits | td_mode |\n|--------------|---------|\n| 000          | 0000    |\n| 001          | 1000    |\n| 010          | 0100    |\n| 011          | 1100    |\n| 100          | 0010    |\n| 101          | 1010    |\n| 110          | 0101    |\n| 111          | 1111    |\n\nCreate a Verilog module `td_mode_generator` that takes in a 9-bit control signal `ctrl` and outputs a 4-bit td_mode signal `td_mode`. Use a case statement to map the control bits to the appropriate td_mode value.\n\n", "output": "module td_mode_generator (\n  input [8:0] ctrl,\n  output reg [3:0] td_mode\n);\n\n  always @ (ctrl) begin\n    case (ctrl[8:6])\n      3'b000: td_mode = 4'b0000;\n      3'b001: td_mode = 4'b1000;\n      3'b010: td_mode = 4'b0100;\n      3'b011: td_mode = 4'b1100;\n      3'b100: td_mode = 4'b0010;\n      3'b101: td_mode = 4'b1010;\n      3'b110: td_mode = 4'b0101;\n      3'b111: td_mode = 4'b1111;\n      default: td_mode = 4'b0000;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 5 inputs and produces a single output. The module should be named `and_nor_buffer` and should have the following inputs and outputs:\n\nInputs:\n- `A1` (1-bit)\n- `A2` (1-bit)\n- `A3` (1-bit)\n- `B1` (1-bit)\n- `C1` (1-bit)\n\nOutputs:\n- `Y` (1-bit)\n\nThe module should implement the following logic:\n1. Perform an AND operation between `A1`, `A2`, and `A3`.\n2. Perform a NOR operation between the result of the AND operation and `B1` and `C1`.\n3. Buffer the output of the NOR operation to produce `Y`.\n\nYou are only allowed to use a single module within 200 lines of Verilog code to implement this logic.\n\nWrite the Verilog code for the `and_nor_buffer` module that implements the above logic.\n\n", "output": "module and_nor_buffer (\n    Y,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n    input C1;\n\n    wire and_out;\n    wire nor_out;\n\n    and and_gate(\n        .out(and_out),\n        .in1(A1),\n        .in2(A2),\n        .in3(A3)\n    );\n\n    nor nor_gate(\n        .out(nor_out),\n        .in1(and_out),\n        .in2(B1),\n        .in3(C1)\n    );\n\n    buf buf_gate(\n        .out(Y),\n        .in(nor_out)\n    );\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a counter with a configurable maximum count value. The counter should increment on every positive edge of the clock input and reset to zero when the maximum count value is reached. The maximum count value should be configurable through an input port.", "output": "module configurable_counter (\n  input clk,\n  input reset,\n  input [7:0] max_count,\n  output reg [7:0] count\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      count <= 8'b0;\n    end else if (count == max_count) begin\n      count <= 8'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\nYou have been tasked to design a verilog module that implements a 4-bit binary counter with an asynchronous reset input. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: an asynchronous reset signal\n\nOutputs:\n- `count`: a 4-bit binary count signal\n\nThe counter should increment on every rising edge of the clock signal. The counter should reset to zero when the reset signal is asserted. The counter should hold its value when the reset signal is deasserted.\n\nDesign a verilog module that implements this counter.\n\n", "output": "module binary_counter (\n  input  wire           clk,\n  input  wire           rst,\n  output reg  [4-1:0]   count\n);\n\nalways @(posedge clk or negedge rst) begin\n  if (~rst) begin\n    count <= #1 4'b0;\n  end\n  else begin\n    count <= #1 count + 1;\n  end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 3-bit binary to Gray code converter. The module should have a 3-bit input and a 3-bit output that represents the Gray code equivalent of the input. The module should use combinational logic to perform the conversion.", "output": "module binary_to_gray (\n    input [2:0] in,\n    output reg [2:0] out\n);\n\n    always @(*) begin\n        out[2] = in[2];\n        out[1] = in[2] ^ in[1];\n        out[0] = in[1] ^ in[0];\n    end\n\nendmodule"}
{"instruction": "\n\nThe given code snippet is a Verilog module `sky130_fd_sc_ms__a211oi_4` that has 8 input ports and 1 output port. The module instantiates another module `sky130_fd_sc_ms__a211oi` and connects its input and output ports to the corresponding ports of the top-level module. Your task is to implement the `sky130_fd_sc_ms__a211oi` module, which has the following truth table:\n\n| A1 | A2 | B1 | C1 | Y |\n|----|----|----|----|---|\n| 0  | 0  | 0  | 0  | 0 |\n| 0  | 0  | 0  | 1  | 1 |\n| 0  | 0  | 1  | 0  | 1 |\n| 0  | 0  | 1  | 1  | 0 |\n| 0  | 1  | 0  | 0  | 1 |\n| 0  | 1  | 0  | 1  | 0 |\n| 0  | 1  | 1  | 0  | 0 |\n| 0  | 1  | 1  | 1  | 1 |\n| 1  | 0  | 0  | 0  | 1 |\n| 1  | 0  | 0  | 1  | 0 |\n| 1  | 0  | 1  | 0  | 0 |\n| 1  | 0  | 1  | 1  | 1 |\n| 1  | 1  | 0  | 0  | 0 |\n| 1  | 1  | 0  | 1  | 1 |\n| 1  | 1  | 1  | 0  | 1 |\n| 1  | 1  | 1  | 1  | 0 |\n\nImplement the `sky130_fd_sc_ms__a211oi` module using only Verilog and ensure that it meets the following requirements:\n- The module should have 5 input ports and 1 output port.\n- The input ports should be named `A1`, `A2`, `B1`, `C1`, and `VPWR`.\n- The output port should be named `Y`.\n- The module should be synthesizable and should not use any non-synthesizable constructs.\n\n", "output": "module sky130_fd_sc_ms__a211oi (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n\n    assign Y = (~A1 & ~A2 & ~B1 & ~C1) |\n               (~A1 & ~A2 &  B1 &  C1) |\n               (~A1 &  A2 & ~B1 &  VPWR) |\n               (~A1 &  A2 &  B1 & ~C1) |\n               ( A1 & ~A2 & ~B1 &  VPWR) |\n               ( A1 & ~A2 &  B1 & ~C1) |\n               ( A1 &  A2 &  B1 &  C1);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a digital logic circuit. The circuit will have three inputs: RESET_B, D, and GATE, and one output: Q. The module should be named \"sky130_fd_sc_ms__dlrtp\".\n\nIn addition to the inputs and output, the module should also include four voltage supply signals: VPWR, VGND, VPB, and VNB. VPWR and VGND should be connected to the positive and negative voltage supplies, respectively. VPB and VNB should be connected to the power and ground pins of the circuit, respectively.\n\nThe module should implement the following logic:\n- When RESET_B is high, Q should be low.\n- When RESET_B is low and GATE is high, Q should follow the value of D.\n- When RESET_B is low and GATE is low, Q should hold its previous value.\n\nYour task is to write the Verilog code for the \"sky130_fd_sc_ms__dlrtp\" module that implements the logic described above. Your code should be 200 lines or less.\n\n", "output": "module sky130_fd_sc_ms__dlrtp (\n    Q      ,\n    RESET_B,\n    D      ,\n    GATE\n);\n\n    output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE   ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    reg Q_reg;\n\n    always @ (RESET_B or D or GATE) begin\n        if (RESET_B == 1'b1) begin\n            Q_reg <= 1'b0;\n        end else if (GATE == 1'b1) begin\n            Q_reg <= D;\n        end\n    end\n\n    assign Q = GATE ? Q_reg : Q;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a 4:1 multiplexer using Verilog. The multiplexer should have 4 inputs, each of size 8 bits, and a 2-bit select input to choose which input to output. The outputs should also be of size 8 bits.\n\nDesign a module named \"Mux4\" that takes in the following inputs:\n- \"select\": a 2-bit input to select which input to output\n- \"data_i00\", \"data_i01\", \"data_i02\", \"data_i03\": 8-bit inputs representing the data to be multiplexed\n\nThe module should output a single 8-bit output \"data_o\" that is the selected input based on the value of \"select\".\n\nYou are required to use a \"case\" statement to implement the multiplexer.\n\nWrite a Verilog module \"Mux4\" that implements the above requirements. Your solution should be contained within a single module with a maximum of 200 lines of Verilog code.\n\n", "output": "module Mux4(select, data_i00, data_i01, data_i02, data_i03, data_o);\n   parameter Size = 8;\n\n   input wire [1:0] select;\n   input wire [Size-1:0] data_i00;\n   input wire [Size-1:0] data_i01;\n   input wire [Size-1:0] data_i02;\n   input wire [Size-1:0] data_i03;\n\n   output reg [Size-1:0] data_o;\n\n   always @ (select or data_i00 or data_i01 or data_i02 or data_i03) begin\n      case (select)\n         2'b00: data_o = data_i00;\n         2'b01: data_o = data_i01;\n         2'b10: data_o = data_i02;\n         2'b11: data_o = data_i03;\n         default: data_o = 0;\n      endcase\n   end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 2-to-1 multiplexer. The module should have two input ports (A and B), one select port (SEL), and one output port (Y). The output Y should be equal to A when SEL is 0, and B when SEL is 1. The module should be named \"mux_2to1\" and should be completely self-contained, meaning it should not require any other modules to function. \n\nYour implementation should be within 200 lines of Verilog code and should include proper input and output declarations, as well as any necessary internal signals or variables. You should also include comments explaining the purpose and functionality of each section of your code. \n\nYour module should be tested using a testbench that verifies that the output Y is correct for all possible input combinations of A, B, and SEL. \n\n", "output": "module mux_2to1 (\n    input A,\n    input B,\n    input SEL,\n    output Y\n);\n\n    wire sel_inv;\n    assign sel_inv = ~SEL;\n\n    assign Y = (A & sel_inv) | (B & SEL);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four input signals and produces a single output signal. The inputs are `empty`, `free2`, `free3`, and `tm_count`, and the output is `fifocount_inc`. \n\nThe `empty` input is a single-bit signal that is high when the FIFO is empty. The `free2` and `free3` inputs are also single-bit signals that are high when there are two or three free spaces in the FIFO, respectively. The `tm_count` input is a two-bit signal that indicates the number of items currently in the FIFO. \n\nThe `fifocount_inc` output is a five-bit signal that represents the number of items that should be added to the FIFO. The value of `fifocount_inc` is determined by the following rules:\n\n- If the FIFO is empty (`empty` is high), `fifocount_inc` should be set to the value of the two least significant bits of `tm_count`.\n- If there are three free spaces in the FIFO (`free3` is high) and `tm_count` is equal to 3, `fifocount_inc` should be set to 2.\n- If there are two free spaces in the FIFO (`free2` is high) and `tm_count` is greater than or equal to 2, `fifocount_inc` should be set to 1.\n- If there is at least one item in the FIFO (`tm_count` is greater than or equal to 1), `fifocount_inc` should be set to 0.\n- Otherwise, `fifocount_inc` should be set to a five-bit signal where all bits are high.\n\nWrite a verilog module that implements this functionality. \n\n", "output": "module fifo_controller (\n  input empty,\n  input free2,\n  input free3,\n  input [1:0] tm_count,\n  output reg [4:0] fifocount_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifocount_inc = tm_count[1:0];\n    end else if (free3 && (tm_count == 2'b11)) begin\n      fifocount_inc = 5'b00010;\n    end else if (free2 && (tm_count >= 2'b10)) begin\n      fifocount_inc = 5'b00001;\n    end else if (tm_count >= 2'b01) begin\n      fifocount_inc = 5'b00000;\n    end else begin\n      fifocount_inc = 5'b11111;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a clock delay buffer that takes an input clock signal and outputs a delayed version of the same clock signal. The module should have the following specifications:\n\n- The input clock signal is named `clk_in` and has a frequency of 50 MHz.\n- The output clock signal is named `clk_out` and should be delayed by 5 ns with respect to the input clock signal.\n- The module should have the following inputs:\n  - `clk_in`: the input clock signal\n  - `reset`: a synchronous reset signal that resets the output clock signal to low when high\n- The module should have the following outputs:\n  - `clk_out`: the delayed output clock signal\n\nYou can use any verilog primitives or gates, but you are not allowed to use any built-in delay functions or delay primitives.\n\nImplement the verilog module for the clock delay buffer that meets the specifications above.\n\n", "output": "module clk_delay_buffer (\n  input clk_in,\n  input reset,\n  output reg clk_out\n);\n\n  // Counter to count 5 ns\n  reg [22:0] counter = 0;\n\n  always @(posedge clk_in, posedge reset) begin\n    if (reset) begin\n      clk_out <= 1'b0;\n      counter <= 0;\n    end else begin\n      if (counter == 23'd249) begin\n        counter <= 0;\n        clk_out <= ~clk_out;\n      end else begin\n        counter <= counter + 1;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module in Verilog that takes in 5 inputs and produces 1 output. The module should be named `parity` and should output a 1 if the number of 1's in the inputs is odd, and a 0 if the number of 1's is even. The inputs should be named `a`, `b`, `c`, `d`, and `e`. \n\nYour module should be designed to be easily testable, meaning that it should be possible to write a testbench that verifies that the module works correctly. \n\nYou should write a module that is no more than 200 lines of Verilog code.\n\n", "output": "module parity(\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output reg out\n);\n\nreg [4:0] count;\n\nalways @(*) begin\n    count = {a, b, c, d, e};\n    out = (count % 2 == 1) ? 1 : 0;\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes in three input signals, A1, A2, and B1, and outputs a single signal, Y. The module should be named \"my_module\" and should be contained within 200 lines of code. The module should be defined in a file named \"my_module.v\".\n\nThe input signals are all single-bit signals, while the output signal is also a single-bit signal. The module should also include four voltage supply signals named VPWR, VGND, VPB, and VNB.\n\nYour task is to write the Verilog code for the \"my_module\" module that satisfies the following requirements:\n\n1. The output signal, Y, should be set to 1 if and only if both input signals A1 and A2 are set to 1 and input signal B1 is set to 0. Otherwise, the output signal should be set to 0.\n\n2. The voltage supply signals should be set up as follows:\n- VPWR should be set to a constant value of 1.\n- VGND should be set to a constant value of 0.\n- VPB should be set to a constant value of 1.\n- VNB should be set to a constant value of 0.\n\nYour code should be well-organized, easy to read, and must be contained within a single module named \"my_module\".\n\n", "output": "module my_module (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = (A1 & A2 & ~B1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a full adder operation. A full adder takes three inputs: two binary digits (A and B) and a carry input (CIN), and produces two outputs: a sum (SUM) and a carry output (COUT). The module should be designed to be implemented in a single module with no more than 200 lines of Verilog code.\n\nYour task is to implement a Verilog module that performs a full adder operation. The module should have the following inputs and outputs:\n\n- Inputs: \n    - A (1-bit binary digit)\n    - B (1-bit binary digit)\n    - CIN (1-bit binary digit)\n- Outputs:\n    - SUM (1-bit binary digit)\n    - COUT (1-bit binary digit)\n\nThe module should be named \"full_adder\" and should be implemented within a single Verilog module. You should use the code snippet provided as a starting point for your implementation.\n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\n    // Local signals\n    wire and1_out, and2_out, and3_out, and4_out, or1_out, or2_out, or3_out;\n\n    // AND gates\n    and and1 (and1_out, A, B);\n    and and2 (and2_out, A, CIN);\n    and and3 (and3_out, B, CIN);\n    and and4 (and4_out, and1_out, CIN);\n\n    // OR gates\n    or or1 (or1_out, and1_out, and2_out);\n    or or2 (or2_out, and3_out, and4_out);\n    or or3 (or3_out, or1_out, or2_out);\n\n    // Output\n    assign SUM = or3_out;\n    assign COUT = or1_out | and3_out | and2_out | and1_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4x4 matrix of push buttons that outputs a 4-bit binary value corresponding to the button being pressed. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: clock signal\n- `rst`: reset signal\n- `btn`: a 4-bit input representing the state of the push buttons (1 for pressed, 0 for not pressed)\n\nOutputs:\n- `out`: a 4-bit binary value representing the button being pressed (1 for button 1, 2 for button 2, etc.)\n\nYou can assume that only one button will be pressed at any given time. The module should output a value of 0 if no button is pressed.\n\n", "output": "module button_matrix (\n    input         clk,\n    input         rst,\n    input  [3:0]  btn,\n    output reg [3:0] out\n  );\n\n  always @(posedge clk, posedge rst)\n    begin\n      if (rst) out <= 4'b0;\n      else\n        case (btn)\n          4'b1110: out <= 4'b0001; // Button 1\n          4'b1101: out <= 4'b0010; // Button 2\n          4'b1011: out <= 4'b0100; // Button 3\n          4'b0111: out <= 4'b1000; // Button 4\n          default: out <= 4'b0000; // No button pressed\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes in four 8-bit inputs (A, B, C, and D) and outputs the largest value as a 16-bit output (out). If two or more inputs have the same maximum value, the output should be the first input with that value. \n\nYou are required to implement this using only a single always block with no if-else statements. \n\n", "output": "module max_value (input [7:0] A, B, C, D, output reg [15:0] out);\n\nreg [7:0] max_val;\n\nalways @ (A, B, C, D) begin\n    max_val = A > B ? A : B;\n    max_val = max_val > C ? max_val : C;\n    max_val = max_val > D ? max_val : D;\n    out = {max_val, 8'b0};\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a D flip-flop with asynchronous reset. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` (1-bit): clock signal\n- `d` (1-bit): data input\n- `reset_b` (1-bit): asynchronous reset signal (active low)\n\nOutputs:\n- `q` (1-bit): data output\n\nThe module should be named `d_ff_async_reset` and should be implemented using behavioral modeling.\n\nWrite the verilog code for the `d_ff_async_reset` module.\n\n", "output": "module d_ff_async_reset (\n    q,\n    clk,\n    d,\n    reset_b\n);\n\n    output q;\n    input clk;\n    input d;\n    input reset_b;\n\n    reg q;\n\n    always @(posedge clk or negedge reset_b) begin\n        if (~reset_b) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module called `arriaiigz_ena_reg` which is a register with enable and asynchronous clear and preset signals. The module has five input ports and one output port. The input ports are:\n- `d`: Data input\n- `clk`: Clock input\n- `clrn`: Asynchronous clear input\n- `prn`: Asynchronous preset input\n- `ena`: Enable input\n\nThe output port is:\n- `q`: Register output\n\nThe module has the following functionality:\n- When the `clrn` input is asserted (i.e., `clrn` = 0), the register output `q` is set to 0.\n- When the `prn` input is asserted (i.e., `prn` = 0), the register output `q` is set to 1.\n- When the `ena` input is asserted (i.e., `ena` = 1), the register is enabled and can store data.\n- When the `ena` input is deasserted (i.e., `ena` = 0), the register is disabled and cannot store data.\n- When the `clrn` input is asserted (i.e., `clrn` = 0), the register is cleared and cannot store data.\n- When the `prn` input is asserted (i.e., `prn` = 0), the register is preset to 1 and can store data.\n- When the `d` input changes, the register stores the new value if the `ena` input is asserted.\n- The register is sensitive to the rising edge of the `clk` input.\n\nYour task is to implement the `arriaiigz_ena_reg` module using Verilog.\n\n", "output": "module arriaiigz_ena_reg (\n    input clk,\n    input ena,\n    input d,\n    input clrn,\n    input prn,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (clrn == 1'b0) begin\n            q <= 1'b0;\n        end else if (prn == 1'b0) begin\n            q <= 1'b1;\n        end else if (ena == 1'b1) begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module with 4 inputs and 4 outputs that behaves like a 4-bit adder with overflow detection. The module should take two 4-bit inputs, add them together, and output the 4-bit result and a single bit indicating overflow. If the sum of the two inputs is greater than 15, the overflow bit should be set to 1, otherwise it should be set to 0.", "output": "module adder_overflow_detection (\n  input [3:0] a,\n  input [3:0] b,\n  output reg [3:0] sum,\n  output reg overflow\n);\n  \n  always @(a, b) begin\n    sum = a + b;\n    if (sum > 15) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a register file. \nA register file is a type of digital circuit that is used to store and access a set of registers. \nThe inputs to the circuit are the read and write enable signals, the register address, and the write data. \nThe outputs are the read data from the selected register.\nYour module should have the following inputs and outputs:\n\nInputs: \n- a set of n-bit write data signals (write_data)\n- a set of m-bit register address signals (reg_addr)\n- a read enable signal (read_en)\n- a write enable signal (write_en)\n\nOutputs: \n- a set of n-bit read data signals (read_data)\n\nThe module should also have the following parameters:\n- n: the number of bits in the write data and read data signals\n- m: the number of registers in the register file\n\nYour module should implement the following functionality:\n\n- When the write enable signal is high, the circuit should write the write data to the selected register specified by the register address signals.\n- When the read enable signal is high, the circuit should read the data from the selected register specified by the register address signals and output it as the read data signals.\n\nTo implement the register file, you should use Verilog code to define the storage elements (registers) as an array of n-bit vectors. \nYou should then use the read and write enable signals to control the write and read operations on the selected register. \nFinally, you should use the selected register's data as the output read data signals.", "output": "module register_file (\n  input [n-1:0] write_data,\n  input [m-1:0] reg_addr,\n  input read_en,\n  input write_en,\n  output [n-1:0] read_data\n);\n\nparameter n = 8; // number of bits in write_data and read_data signals\nparameter m = 16; // number of registers in the register file\n\nreg [n-1:0] registers [0:m-1];\n\nalways @ (posedge clk) begin\n  if (write_en) begin\n    registers[reg_addr] <= write_data;\n  end\nend\n\nassign read_data = (read_en) ? registers[reg_addr] : 0;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that takes in two 8-bit inputs (a, b) and produces a 16-bit output (out). The out output is generated by concatenating the 8-bit input a with the 8-bit input b. The module should also have a control input (ctrl) that determines whether the output should be the concatenation of a and b (ctrl = 1) or the concatenation of b and a (ctrl = 0). Please write the Verilog code for this module, including the module name and IO definition.", "output": "module concat_8bit (\n  input clk,\n  input reset,\n  input [7:0] a,\n  input [7:0] b,\n  input ctrl,\n  output [15:0] out\n);\n\nreg [15:0] temp;\n\nalways @ (posedge clk or posedge reset) begin\n  if (reset) begin\n    temp <= 16'b0;\n  end else begin\n    if (ctrl) begin\n      temp <= {a, b};\n    end else begin\n      temp <= {b, a};\n    end\n  end\nend\n\nassign out = temp;\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a modulo operator. \nThe modulo operator is a mathematical operator that returns the remainder of a division operation. \nFor example, the expression 7 % 3 evaluates to 1, because 7 divided by 3 has a remainder of 1. \nYour module should take two inputs, a dividend (div) and a divisor (divisor), and produce one output, the remainder (rem).\n\nTo implement the modulo operator, you should use Verilog code to divide the dividend by the divisor and calculate the remainder. \nYou can use the modulus operator (%) in Verilog to perform the division and calculate the remainder. \nHowever, you should not use the modulus operator directly in your Verilog code, as this would defeat the purpose of the exercise. \nInstead, you should use bitwise operations and conditional statements to calculate the remainder.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- div: the dividend, a non-negative integer \n- divisor: the divisor, a non-negative integer greater than zero \n\nOutputs: \n- rem: the remainder, an integer between 0 and divisor-1\n\nTo finish this task, you should first calculate the quotient by dividing the dividend by the divisor. \nThen, you should multiply the quotient by the divisor to get the product. \nFinally, you should subtract the product from the dividend to get the remainder. \nYou should use conditional statements to check if the divisor is equal to zero or if the dividend is negative. \nIf either of these conditions is true, your module should output an error message.\n\nHere is the suggested Verilog module definition and input/output definitions:", "output": "module modulo_operator (\n  input [31:0] div, // the dividend\n  input [31:0] divisor, // the divisor\n  output [31:0] rem // the remainder\n);\n\n  reg [31:0] quotient;\n  reg [31:0] product;\n\n  // Check for errors\n  always @(*) begin\n    if (divisor == 0) begin\n      $display(\"Error: divisor cannot be zero\");\n      rem = 0;\n    end\n    else if (div < 0) begin\n      $display(\"Error: dividend cannot be negative\");\n      rem = 0;\n    end\n    else begin\n      quotient = div / divisor;\n      product = quotient * divisor;\n      rem = div - product;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit input signal `in_signal` and outputs a 2-bit signal `out_signal`. The 2-bit output signal should represent the highest and lowest bits of the input signal.\n\nDesign the module `high_low` with the following ports:\n- `input  logic [3:0] in_signal`\n- `output logic [1:0] out_signal`\n\nEnsure that your module has the following functionality:\n- The highest bit of `in_signal` should be assigned to `out_signal[1]`.\n- The lowest bit of `in_signal` should be assigned to `out_signal[0]`.\n\n", "output": "module high_low\n  (\n   input  logic [3:0] in_signal,\n   output logic [1:0] out_signal\n   );\n\n   always_comb out_signal[1] = in_signal[3];\n   always_comb out_signal[0] = in_signal[0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a pipelined module that implements an 8-bit ripple-carry adder with a carry-in input and a carry-out output. \nThe module should have three inputs (A, B, and X) and two outputs (sum and carry_out). The module should use pipeline structure to achieve the same functionality as the given prompt. \nHowever, the module should add an additional functionality that XORs the input B with input X before performing addition or subtraction. \nIf X is high, the module should perform A - B - (not carry_in) and output the borrow-out. If X is low, the module should perform A + B + carry_in and output the carry-out.", "output": "module ripple_carry_adder (\n    input [7:0] A,\n    input [7:0] B,\n    input carry_in,\n    input X,\n    output reg [7:0] sum,\n    output reg carry_out\n);\n\nreg [7:0] A_reg, B_reg, sum_reg;\nreg carry_in_reg, carry_out_reg;\n\nalways @(*) begin\n    A_reg = A;\n    B_reg = B ^ X; // XOR B with X\n    carry_in_reg = carry_in;\nend\n\nalways @(posedge clk) begin\n    sum_reg = A_reg + B_reg + carry_in_reg;\n    carry_out_reg = (A_reg[7] & B_reg[7]) | (B_reg[7] & carry_in_reg) | (A_reg[7] & carry_in_reg);\nend\n\nalways @(posedge clk) begin\n    sum <= sum_reg;\n    carry_out <= carry_out_reg;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will generate a 4-bit Gray code sequence. The module should have an input `clk` and an output `gray_code`. The `gray_code` output should change on every rising edge of `clk`. The initial value of `gray_code` should be 0b0000. The module should be synthesizable and should not use any procedural assignments.\n\n", "output": "module gray_code (\n  input clk,\n  output reg [3:0] gray_code\n);\n\n  always @(posedge clk) begin\n    gray_code <= gray_code ^ (gray_code >> 1);\n  end\n\nendmodule"}
{"instruction": "Create a 2-to-1 multiplexer that selects between two input signals, a and b, based on the values of sel_b1 and sel_b2. If both sel_b1 and sel_b2 are high, the output should be b. Otherwise, the output should be a. However, you are not allowed to use if statements in your implementation. Instead, you should use a combination of logical and arithmetic operators to achieve the same functionality.", "output": "module mux_2to1(\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output reg out_always\n);\n\nalways @(*) begin\n    out_always = (sel_b2 & ~sel_b1) ? b : a;\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in a 4-bit binary number as input and returns the 2's complement of that number. The module should be designed using Verilog and should be self-contained. You should not use any other modules except for the basic logic gates.\n\nThe module should have the following input and output ports:\n- input [3:0] num_in: the 4-bit binary number to be converted\n- output [3:0] num_out: the 2's complement of the input number\n\nThe module should implement the following algorithm to calculate the 2's complement of the input number:\n1. Invert all the bits of the input number\n2. Add 1 to the result from step 1\n\nFor example, if the input number is 0101, the module should return 1011 as the 2's complement.\n\n", "output": "module twos_complement (\n    input [3:0] num_in,\n    output [3:0] num_out\n);\n\n    wire [3:0] inverted_num;\n    wire [3:0] one = 4'b0001;\n    \n    assign inverted_num = ~num_in;\n    assign num_out = inverted_num + one;\n    \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a watchdog timer.\nA watchdog timer is a timer that is used to detect and recover from software malfunctions.\nYour module should have the following inputs and outputs:\n\nInputs: a clock signal (clk) and a reset signal (rst)\nOutputs: a signal (wdt) that is used to reset the system if the timer expires\nThe module should also have the following parameters:\n\ntimeout: the length of the timer in clock cycles\nYour module should implement the following functionality:\n\nThe timer should start counting when the reset signal is set to 0 and should continue to count as long as the reset signal is 0 and the clock signal is toggling.\nIf the timer reaches the timeout value, the wdt signal should be set to 1, which can be used to reset the system.\nIf the reset signal is set to 1, the timer should be reset to 0 and the wdt signal should be set to 0.\nTo implement the watchdog timer, you should use Verilog code to define a counter that counts the clock cycles and compares it to the timeout value.\nYou should also use an if statement to check if the reset signal is 1 and reset the counter and the wdt signal accordingly.\nFinally, you should use a combinational logic to set the wdt signal to 1 if the counter reaches the timeout value.", "output": "module watchdog_timer (\n  input clk,\n  input rst,\n  output wdt\n);\n\n  parameter timeout = 100; // timeout value in clock cycles\n  \n  reg [7:0] counter; // 8-bit counter to count clock cycles\n  \n  always @(posedge clk) begin\n    if (rst == 1) begin\n      counter <= 0;\n      wdt <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n      if (counter == timeout) begin\n        wdt <= 1;\n      end\n    end\n  end\n  \nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that will implement a 2:1 MUX using a 2-input AND gate, a 2-input OR gate, and an inverter. The module should take in two data inputs, a select input, and output the selected input. The module should be named `mux_2to1` and have the following ports:\n\n- `in0`: input data bit 0\n- `in1`: input data bit 1\n- `sel`: select input bit\n- `out`: output data bit\n\nWrite the verilog code for this module using only the specified gates. \n\n", "output": "module mux_2to1(\n    input in0,\n    input in1,\n    input sel,\n    output out\n);\n\n    wire and_out;\n    wire or_out;\n    wire not_sel;\n\n    assign not_sel = ~sel;\n    assign and_out = in0 & not_sel;\n    assign or_out = in1 | and_out;\n    assign out = ~or_out;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in a 4-bit binary number and outputs the 2's complement representation of the input. The module should have an asynchronous reset input that sets the output to 0 when asserted. The module should also have an enable input that determines whether the output is updated on each clock cycle or not.", "output": "module twos_complement (\n    input clk,\n    input rst_n,\n    input en,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            out <= 4'b0000;\n        end else if (en) begin\n            out <= (~in) + 4'b0001;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in five inputs and produces one output. The module should be named `my_module` and should have the following port declarations:\n\n- `input [3:0] A`\n- `input [3:0] B`\n- `input [3:0] C`\n- `input [3:0] D`\n- `input [3:0] E`\n- `output reg X`\n\nInside the module, you should declare the following signals:\n\n- `reg [3:0] sum`\n- `reg [3:0] max`\n\nThe behavior of the module should be as follows:\n\n- `sum` should be the sum of all the inputs `A`, `B`, `C`, `D`, and `E`.\n- `max` should be the maximum value of all the inputs `A`, `B`, `C`, `D`, and `E`.\n- `X` should be 1 if the value of `sum` is greater than or equal to `max`, and 0 otherwise.\n\nYour task is to write the verilog code for the `my_module` module that implements this behavior.\n\n", "output": "module my_module(\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input [3:0] E,\n    output reg X\n);\n\n    reg [3:0] sum;\n    reg [3:0] max;\n\n    always @*\n    begin\n        sum = A + B + C + D + E;\n        max = A;\n        if (B > max) max = B;\n        if (C > max) max = C;\n        if (D > max) max = D;\n        if (E > max) max = E;\n    end\n\n    always @(sum, max)\n    begin\n        if (sum >= max) X = 1;\n        else X = 0;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two 8-bit inputs, A and B, and outputs their sum in binary, S. The module should also output a carry bit, C, which indicates if there is a carry-out from the most significant bit. The module should be named `adder8` and should be written in Verilog within 200 lines of code.\n\nThe inputs A and B are unsigned integers, and the output S should also be an unsigned integer. The module should have the following interface:\n\n```verilog\nmodule adder8 (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] S,\n    output C\n);\n```\n\nThe module should implement a ripple-carry adder, which adds the two inputs one bit at a time and propagates any carry to the next bit. You may use any additional modules or gates you deem necessary, but the `adder8` module should be self-contained and not rely on any external modules.\n\nYour implementation should be optimized for speed, as the module will be used in a critical path in a larger design. \n\n", "output": "module adder8 (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] S,\n    output C\n);\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign sum[0] = A[0] ^ B[0];\n    assign carry[0] = A[0] & B[0];\n\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin : adder_loop\n            assign sum[i] = A[i] ^ B[i] ^ carry[i-1];\n            assign carry[i] = (A[i] & B[i]) | (A[i] & carry[i-1]) | (B[i] & carry[i-1]);\n        end\n    endgenerate\n\n    assign S = sum;\n    assign C = carry[7];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an energy harvesting block. \nAn energy harvesting block is a circuit that converts different types of energy, such as solar or piezoelectric energy, into usable electrical energy. \nYour module should have the following inputs and outputs:\n\nInputs: a power source signal (power_source)\nOutputs: an electrical energy signal (electrical_energy)\nThe module should also have the following parameters:\n\nvoltage_gain: the voltage gain of the energy harvesting block\nefficiency: the efficiency of the energy harvesting block\nYour module should implement the following functionality:\n\nThe circuit should take a power source signal and convert it into electrical energy.\nThe output electrical energy signal should be the product of the input power source signal, the voltage gain, and the efficiency.\nTo implement the energy harvesting block, you should use Verilog code to define the voltage gain and efficiency as parameters. \nYou should then use these parameters to convert the power source signal into electrical energy signal. Finally, you should output the electrical energy signal.", "output": "module energy_harvesting_block (\n  input power_source,\n  output electrical_energy\n);\n\nparameter voltage_gain = 5; // voltage gain of the energy harvesting block\nparameter efficiency = 0.8; // efficiency of the energy harvesting block\n\nassign electrical_energy = power_source * voltage_gain * efficiency;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 2-bit adder using the Verilog Hardware Description Language. The module should have 2 inputs, A and B, and 2 outputs, S and C, where S is the sum of A and B, and C is the carry out. The module should be named \"two_bit_adder\".\n\nThe module should use the following module signature:\n```\nmodule two_bit_adder(\n  input [1:0] A,\n  input [1:0] B,\n  output [1:0] S,\n  output C\n);\n```\n\nYou are required to implement the two-bit adder using only basic gates such as AND, OR, NOT, and XOR. You should not use any pre-existing Verilog or SystemVerilog modules, primitives, or operators. You may, however, use intermediate wires or variables to simplify the implementation.\n\nYou should also ensure that the module has the following functionality:\n- The module should correctly add the two input numbers, A and B, and produce the correct sum, S, and carry out, C.\n- The module should be synthesizable and should not contain any syntax errors.\n\n", "output": "module two_bit_adder(\n  input [1:0] A,\n  input [1:0] B,\n  output [1:0] S,\n  output C\n);\n\n  // Calculate the sum of the least significant bits of A and B\n  wire sum_lsb = A[0] ^ B[0];\n\n  // Calculate the sum of the most significant bits of A and B along with the carry out from the previous step\n  wire sum_msb = A[1] ^ B[1] ^ sum_lsb;\n  wire carry_out = (A[1] & B[1]) | (A[1] & sum_lsb) | (B[1] & sum_lsb);\n\n  // Combine the two sums and the carry out to produce the final output\n  assign S = {sum_msb, sum_lsb};\n  assign C = carry_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a D flip-flop with asynchronous reset. The module should have the following inputs and outputs:\n\nInputs:\n- `D`: Data input\n- `RESET_B`: Asynchronous reset input (active low)\n- `CLK`: Clock input\n\nOutputs:\n- `Q`: Output of the flip-flop\n\nThe module should operate as follows:\n- When `RESET_B` is low, `Q` should be set to 0 regardless of the value of `D`.\n- When `RESET_B` is high, `Q` should follow the value of `D` on the rising edge of `CLK`.\n\nYour Verilog module should be named `d_ff_async_reset` and should be solvable within 200 lines of code.\n\n", "output": "module d_ff_async_reset (\n    input D, RESET_B, CLK,\n    output Q\n);\n\nreg Q;\n\nalways @(posedge CLK, negedge RESET_B) begin\n    if (!RESET_B) begin\n        Q <= 0;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in four input signals A1, A2, B1, and C1, and produces a single output signal X. The module should be named `four_input_gate` and should be defined as follows:\n\n- A1, A2, B1, and C1 are all single-bit input signals.\n- X is a single-bit output signal.\n- The module should implement the following logic: X = (A1 & A2) | (~A1 & B1) | (~A1 & ~B1 & C1)\n\nWrite the verilog code for the `four_input_gate` module. \n\n", "output": "module four_input_gate (\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  C1  ,\n    output X   \n);\n\n    assign X = (A1 & A2) | (~A1 & B1) | (~A1 & ~B1 & C1);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit shift register with a parallel load input. The module should have four 1-bit inputs (D0, D1, D2, D3), a 1-bit parallel load input (LOAD), a 1-bit shift input (SHIFT), and a 4-bit output (Q). When LOAD is high, the output Q should be the value of the inputs. When SHIFT is high, the output Q should be the value of the inputs shifted left by one bit, with the leftmost bit being replaced by a 0.", "output": "module shift_register (\n    input [3:0] D,\n    input LOAD,\n    input SHIFT,\n    output reg [3:0] Q\n);\n\n    always @ (posedge SHIFT) begin\n        Q <= {Q[2:0], 1'b0};\n    end\n    \n    always @ (posedge LOAD) begin\n        if (LOAD) begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that will take in various inputs and produce several outputs. The module must be named \"multi_io_module\" and should have the following inputs and outputs:\n\nInputs:\n- a 4-bit vector named \"in1\"\n- a 3-bit vector named \"in2\"\n- a single bit named \"in3\"\n- a clock signal named \"clk\"\n\nOutputs:\n- a 2-bit vector named \"out1\"\n- a single bit named \"out2\"\n- a 3-bit vector named \"out3\"\n- a single bit named \"out4\"\n\nThe module should perform the following operations:\n- The 2-bit vector \"out1\" should be the sum of \"in1\" and \"in2\".\n- The single bit \"out2\" should be the XOR of \"in1\" and \"in3\".\n- The 3-bit vector \"out3\" should be the concatenation of \"in1\" and \"in2\".\n- The single bit \"out4\" should be the AND of \"in2\" and \"in3\".\n\nWrite the Verilog code for the \"multi_io_module\" module.\n\n", "output": "module multi_io_module(\n  input [3:0] in1,\n  input [2:0] in2,\n  input in3,\n  input clk,\n  output [1:0] out1,\n  output out2,\n  output [2:0] out3,\n  output out4\n);\n\n  assign out1 = in1[1:0] + in2;\n  assign out2 = in1[0] ^ in3;\n  assign out3 = {in1, in2};\n  assign out4 = in2 & in3;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a multiplier block in Verilog. The multiplier block takes a 32-bit input `i_data0` and produces a 32-bit output `o_data0`. The multiplier block consists of several multipliers and wires. \n\nThe following variables have been declared and initialized in the code snippet:\n- `w1`: a 32-bit wire assigned to `i_data0`\n- `w64`: a 32-bit wire assigned to `w1` shifted left by 6 bits\n- `w63`: a 32-bit wire assigned to `w64` subtracted by `w1`\n- `w252`: a 32-bit wire assigned to `w63` shifted left by 2 bits\n- `w315`: a 32-bit wire assigned to `w63` added to `w252`\n- `w256`: a 32-bit wire assigned to `w1` shifted left by 8 bits\n- `w257`: a 32-bit wire assigned to `w1` added to `w256`\n- `w4112`: a 32-bit wire assigned to `w257` shifted left by 4 bits\n- `w4427`: a 32-bit wire assigned to `w315` added to `w4112`\n\nYour task is to complete the multiplier block by implementing the missing Verilog code. \n\n", "output": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w64,\n    w63,\n    w252,\n    w315,\n    w256,\n    w257,\n    w4112,\n    w4427;\n\n  assign w1 = i_data0;\n  assign w64 = w1 << 6;\n  assign w63 = w64 - w1;\n  assign w252 = w63 << 2;\n  assign w315 = w63 + w252;\n  assign w256 = w1 << 8;\n  assign w257 = w1 + w256;\n  assign w4112 = w257 << 4;\n  assign w4427 = w315 + w4112;\n\n  assign o_data0 = w4427;\n\n  //multiplier_block area estimate = 7125.14888406029;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a 4-bit counter in Verilog that counts up from 0 to 15 and then resets to 0. The counter should have a synchronous active-high reset input and a clock input. Additionally, the counter should have an enable input that allows the counter to be turned on and off. When the enable input is low, the counter should hold its current value.\n\nDesign the counter as a single Verilog module within 200 lines of code. You should include comments in your code to explain the functionality of each section.\n\n", "output": "module counter(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 4'b0000;\n  end else if (enable) begin\n    count <= count + 1;\n  end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 3-bit shift register with parallel load. The module should have three inputs (A, load, and clk) and three outputs (Q2, Q1, and Q0). When the load input is high, the register should load the value of A into Q2Q1Q0 on the next clock cycle. When the load input is low, the register should shift the current value of Q2Q1Q0 to the left on each clock cycle, with the value of A being shifted into Q0. The output Q2 should be the most significant bit and Q0 should be the least significant bit.", "output": "module shift_register_3_bit (\n    input A,\n    input load,\n    input clk,\n    output reg Q2,\n    output reg Q1,\n    output reg Q0\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            Q2 <= A;\n            Q1 <= A;\n            Q0 <= A;\n        end\n        else begin\n            Q2 <= Q1;\n            Q1 <= Q0;\n            Q0 <= A;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-bit adder-subtractor. The module should have two input ports, A and B, which are both 4-bit wide. It should also have a control input port, SUB, which will be used to determine whether the operation should be addition or subtraction. When SUB is high, the output should be the result of A - B. When SUB is low, the output should be the result of A + B. The module should have a single output port, OUT, which is also 4-bit wide.\n\nYour task is to implement this module in verilog and ensure that it works as expected.\n\n", "output": "module adder_subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] OUT\n);\n\n    wire [3:0] negB;\n    assign negB = ~B + 1;\n\n    assign OUT = (SUB) ? A + negB : A + B;\n\nendmodule"}
{"instruction": "\n\nCreate a Verilog module that implements a 4-bit comparator that compares two 4-bit inputs A and B. The module should have two outputs, EQ and GT. EQ should be high if A and B are equal, and low otherwise. GT should be high if A is greater than B, and low otherwise. You can assume that the inputs A and B are unsigned integers. \n\n", "output": "module comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output EQ,\n    output GT\n    );\n\n    assign EQ = (A == B);\n    assign GT = (A > B);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a voltage supply module for a circuit. You need to create a module that includes two supply signals: VPWR and VGND. VPWR should be a supply of 1V, while VGND should be a supply of 0V. You should create a module that can be used as a base for other modules.\n\nCreate a module named \"voltage_supply\" with the following inputs and outputs:\n\nInputs:\n- None\n\nOutputs:\n- output reg VPWR: 1-bit output representing the 1V supply\n- output reg VGND: 1-bit output representing the 0V supply\n\nYour module should be self-contained and should not use any other modules. Your module should also be synthesizable and should follow good design practices.\n\n", "output": "module voltage_supply (\n    output reg VPWR,\n    output reg VGND\n);\n\n    // Set VPWR to 1V\n    always @* begin\n        VPWR = 1;\n    end\n\n    // Set VGND to 0V\n    always @* begin\n        VGND = 0;\n    end\n\nendmodule"}
{"instruction": "Design a module that implements an AND gate using a behavioral model. The module should have two input ports, each capable of accepting a single binary value. The output port should be able to provide a single binary value that is the result of ANDing the two input values. The module must be designed using a conditional operator.", "output": "module and_gate(\n    input a, \n    input b,\n    output reg out\n);\n\n    always @(*) begin\n        out = (a & b) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a 4-input NOR gate. The module should have the following inputs and outputs:\n\nInputs:\n- A, B, C, D: 1-bit inputs representing the four inputs to the NOR gate\n- VPWR, VGND: power and ground supply voltages\n- VPB, VNB: positive and negative voltage supplies\n\nOutputs:\n- Y: 1-bit output representing the output of the NOR gate\n\nYou are given the following code snippet as a starting point:\n\n```\nmodule sky130_fd_sc_lp__nor4_0 (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_lp__nor4 base (\n        .Y(Y),\n        .A(A),\n        .B(B),\n        .C(C),\n        .D(D),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n```\n\nYour task is to complete the module implementation by writing the Verilog code for the NOR gate.\n\n", "output": "module sky130_fd_sc_lp__nor4_0 (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    assign Y = ~(A | B | C | D);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes in two 8-bit binary numbers A and B and outputs their sum in binary. The module should also output a carry-out signal indicating whether an overflow occurred during addition. You may assume that the inputs are valid 8-bit binary numbers.\n\nUse the following code snippet as a starting point:\n```\nmodule binary_adder (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum,\n    output carry_out\n);\n\nendmodule\n```\n\n", "output": "module binary_adder (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum,\n    output carry_out\n);\n\n    wire [8:0] temp_sum;\n    assign temp_sum = A + B;\n\n    assign carry_out = temp_sum[8];\n    assign sum = temp_sum[7:0];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit adder-subtractor. The module should have two 4-bit inputs (A and B), one 1-bit input (SUB), and one 4-bit output (Q). If SUB is 0, the module should perform addition and output the sum of A and B. If SUB is 1, the module should perform subtraction and output the difference between A and B. The module should use combinational logic to perform the addition or subtraction operation.", "output": "module add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] Q\n);\n\n    wire [3:0] sum;\n    wire [3:0] diff;\n\n    assign sum = A + B;\n    assign diff = A - B;\n\n    assign Q = SUB ? diff : sum;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a register with a single bit of storage. The module should have four inputs and one output. The inputs are:\n- `clk`: a clock signal that runs the module\n- `rst`: a reset signal that sets the output to 0\n- `flush`: a signal that clears the output to 0\n- `LLbit_i`: a single-bit input that is written to the register when `we` is high\n- `we`: a write-enable signal that indicates when `LLbit_i` should be written to the register\n\nThe output of the module is a single bit `LLbit_o`, which is the value stored in the register.\n\nThe module should have the following behavior:\n- When `rst` is high, the output should be 0.\n- When `flush` is high, the output should be cleared to 0.\n- When `we` is high, the input `LLbit_i` should be written to the register.\n- The output should always reflect the value stored in the register.\n\nWrite a Verilog module that implements this behavior. Your module should be self-contained and should not require any external modules or libraries. Your module should be no more than 200 lines of Verilog code.\n\n", "output": "module LLbit_reg(\n    input wire clk,\n    input wire rst,\n    input wire flush,\n    input wire LLbit_i,\n    input wire we,\n    output reg LLbit_o\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            LLbit_o <= 1'b0;\n        end else if (flush) begin\n            LLbit_o <= 1'b0;\n        end else if (we) begin\n            LLbit_o <= LLbit_i;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module for a digital logic circuit that implements a 4-to-1 multiplexer. The module should have four input signals, one output signal, and two control signals. The output signal should be the value of the selected input signal based on the values of the control signals. The truth table for the 4-to-1 multiplexer is shown below:\n\n| Sel1 | Sel0 | Input0 | Input1 | Input2 | Input3 | Output |\n|------|------|--------|--------|--------|--------|--------|\n| 0    | 0    | I0     | I1     | I2     | I3     | I0     |\n| 0    | 1    | I0     | I1     | I2     | I3     | I1     |\n| 1    | 0    | I0     | I1     | I2     | I3     | I2     |\n| 1    | 1    | I0     | I1     | I2     | I3     | I3     |\n\nThe module should be named `mux4to1` and have the following input and output ports:\n- `input [3:0] in`: the four input signals\n- `input [1:0] sel`: the two control signals\n- `output out`: the output signal\n\nYou should use Verilog to implement the module.\n\n", "output": "module mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output out\n);\n\n    wire sel1_not, sel0_not;\n    assign sel1_not = ~sel[1];\n    assign sel0_not = ~sel[0];\n\n    wire w0, w1, w2, w3;\n    assign w0 = in[0] & sel0_not & sel1_not;\n    assign w1 = in[1] & sel0_not & sel[1];\n    assign w2 = in[2] & sel[0] & sel1_not;\n    assign w3 = in[3] & sel[0] & sel[1];\n\n    assign out = w0 | w1 | w2 | w3;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that takes in a 4-bit binary number and outputs the 2's complement representation of the number as a 4-bit binary number. Use a combinational logic design to implement the module.", "output": "module twos_complement (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nassign out = (~in) + 4'b1;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 8-bit priority encoder. The module should have eight inputs, I0 through I7, and three outputs, EN, V, and Q. If multiple inputs are asserted at the same time, the input with the highest priority (highest index) should be encoded. The EN output should be high when at least one input is asserted, and low otherwise. The V output should be high if more than one input is asserted, and low otherwise. The Q output should be a 3-bit binary number representing the index of the highest-priority asserted input.", "output": "module priority_encoder (\n    input [7:0] I,\n    output reg EN,\n    output reg V,\n    output reg [2:0] Q\n);\n    \n    always @(*) begin\n        if (|I) begin\n            EN = 1;\n            V = (|I) & (~&I);\n            Q = $onehot0(I);\n        end\n        else begin\n            EN = 0;\n            V = 0;\n            Q = 0;\n        end\n    end\n    \nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes an 8-bit input signal `data_in` and performs a bit-wise left shift by a variable amount specified by a 3-bit input signal `shift_amount`. The output signal `data_out` should be the result of the left shift operation. If the value of `shift_amount` is greater than 7, the output should be 0.\n\n", "output": "module BitwiseLeftShift(\n    input [7:0] data_in,\n    input [2:0] shift_amount,\n    output reg [7:0] data_out\n    );\n\n    always @(*) begin\n        if (shift_amount > 7) begin\n            data_out = 8'b0;\n        end else begin\n            data_out = data_in << shift_amount;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in an 18-bit input signal, `Din`, and outputs a 10-bit signal, `Dout`. The module `RAT_xlslice_0_0` is provided as a black box, which has two ports, `Din` and `Dout`. The input port `Din` is 18 bits wide, while the output port `Dout` is 10 bits wide. You are required to instantiate the `RAT_xlslice_0_0` module and connect it to the input and output ports of your design module.\n\nDesign module interface:\n```\nmodule my_design_module(\n  input [17:0] Din,\n  output [9:0] Dout\n);\n```\n\nYour task is to write the body of the `my_design_module` module that properly instantiates and connects the `RAT_xlslice_0_0` module to the input and output ports of `my_design_module`. \n\n", "output": "module my_design_module(\n  input [17:0] Din,\n  output [9:0] Dout\n);\n\n  wire [9:0] rat_out;\n\n  RAT_xlslice_0_0 rat_inst (\n    .Din(Din),\n    .Dout(rat_out)\n  );\n\n  assign Dout = rat_out;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 16-bit input and outputs the maximum value of the input. The module should have one input: in. The output should be a 16-bit value representing the maximum value of the input. Hint: Use a for loop to compare each bit of the input to find the maximum value.", "output": "module max_value (\n    input [15:0] in,\n    output reg [15:0] out\n);\n\n    reg [15:0] max_val;\n    integer i;\n\n    always @(*) begin\n        max_val = in[0];\n        for (i = 1; i < 16; i = i + 1) begin\n            if (in[i] > max_val) begin\n                max_val = in[i];\n            end\n        end\n        out = max_val;\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-to-2 priority encoder. The module should have four inputs (A, B, C, and D) and two outputs (Y1 and Y2). If only one input is high, Y1 should be set to the index of the high input (0 for A, 1 for B, 2 for C, and 3 for D) and Y2 should be low. If multiple inputs are high, Y1 should be set to the index of the highest input and Y2 should be high.", "output": "module priority_encoder (\n    input [3:0] inputs,\n    output reg [1:0] outputs\n);\n\nalways @* begin\n    case(inputs)\n        4'b0001: outputs = 2'b00;\n        4'b0010: outputs = 2'b01;\n        4'b0100: outputs = 2'b10;\n        4'b1000: outputs = 2'b11;\n        4'b0011, 4'b0111, 4'b1110, 4'b1101, 4'b1011, 4'b0110: outputs = 2'b10;\n        default: outputs = 2'b00;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-to-1 multiplexer. The module should have four input signals, one output signal, and two select signals. The output signal should be the value of the selected input signal. The select signals should be used to determine which input signal to output. \n\nDesign the module with the following specifications:\n- The module name should be \"MUX4X1\".\n- The input signals should be named \"A\", \"B\", \"C\", and \"D\".\n- The select signals should be named \"S0\" and \"S1\".\n- The output signal should be named \"Y\".\n- The module should be synthesizable.\n- The module should have a single always block.\n\n", "output": "module MUX4X1 (A, B, C, D, S0, S1, Y);\ninput A, B, C, D;\ninput S0, S1;\noutput Y;\n\nreg Y;\n\nalways @ (S1 or S0 or A or B or C or D) begin\n   case ({S1, S0})\n      2'b00: Y = A;\n      2'b01: Y = B;\n      2'b10: Y = C;\n      2'b11: Y = D;\n   endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a priority encoder. The priority encoder should take a 4-bit input \"in\" and output a 2-bit value \"pos\". \"pos\" should represent the highest priority bit set in \"in\". For example, if \"in\" is 0101, \"pos\" should be 01. If \"in\" is 1100, \"pos\" should be 10. If \"in\" is 0000, \"pos\" should be 00. If multiple bits in \"in\" are set, the highest priority bit should be selected. If \"in\" is 0100 and \"in\" is 0010, \"pos\" should be 10. If \"in\" is 1111 and \"in\" is 0010, \"pos\" should be 11. If \"in\" is 1111 and \"in\" is 0000, \"pos\" should be 11. The value of \"pos\" should be set every clock cycle.", "output": "module priority_encoder (\n  input clk,\n  input reset,\n  input [3:0] in,\n  output reg [1:0] pos\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      pos <= 2'b00;\n    end else begin\n      casez(in)\n        4'b0001: pos <= 2'b00;\n        4'b0010: pos <= 2'b01;\n        4'b0100: pos <= 2'b10;\n        4'b1000: pos <= 2'b11;\n        4'b0011, 4'b0111, 4'b1111: pos <= 2'b11;\n        4'b0101, 4'b0110, 4'b1011, 4'b1101: pos <= 2'b10;\n        4'b1001, 4'b1010, 4'b1100: pos <= 2'b01;\n        default: pos <= 2'b00;\n      endcase\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in three input bits and outputs their XOR value. The module should be named \"xor_gate\" and should have the following IO ports:\n\n- A: input bit\n- B: input bit\n- C: input bit\n- Y: output bit\n\nUse the provided code snippet as a reference for the IO port format. \n\n", "output": "module xor_gate (\n    A,\n    B,\n    C,\n    Y\n);\n\n    input A;\n    input B;\n    input C;\n    output Y;\n\n    assign Y = A ^ B ^ C;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 2-bit input signal `data`, and outputs a 1-bit signal `q` and a 1-bit signal `zero`. The `q` output should be the inverse of the least significant bit of `data`, while the `zero` output should be 1 if both bits of `data` are 0, and 0 otherwise.\n\nDesign a Verilog module that implements this functionality. The module should be named `two_bit_encoder` and should have the following inputs and outputs:\n\nInputs:\n- `data`: a 2-bit input signal\n\nOutputs:\n- `q`: a 1-bit output signal that is the inverse of the least significant bit of `data`\n- `zero`: a 1-bit output signal that is 1 if both bits of `data` are 0, and 0 otherwise\n\nYour module should have the following behavior:\n- When `data[0]` is 0, `q` should be 1. When `data[0]` is 1, `q` should be 0.\n- If both `data[0]` and `data[1]` are 0, `zero` should be 1. Otherwise, `zero` should be 0.\n\n", "output": "module two_bit_encoder(\n    input [1:0] data,\n    output reg q,\n    output reg zero\n);\n\nalways @(*) begin\n    q = ~data[0];\n    zero = ~(data[0] | data[1]);\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a 2-input NAND gate using Verilog. The module should have three input ports, A and B for the inputs, and Y for the output. The module should also have four voltage supply signals: VPWR for the positive voltage supply, VGND for the ground, VPB for the positive voltage bias, and VNB for the negative voltage bias.\n\nYour module should implement the logical operation of a NAND gate using the input signals A and B. The output signal Y should be high only when both A and B are low. The module should also ensure that the output signal Y is only affected by the input signals A and B, and not by any other signals. \n\nIn addition, your module should be completely self-contained and not rely on any other modules. You should also ensure that the module follows the standard Verilog syntax.\n\nWrite a Verilog module that implements a 2-input NAND gate with the above requirements.\n\n", "output": "module nand_gate (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ~(A & B);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that generates a clock and uses a case statement to set specific bits in a 8-bit register based on the value of a 4-bit signal. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a 1-bit clock signal\n- `sig`: a 4-bit input signal\n\nOutputs:\n- `thing`: an 8-bit register with specific bits set based on the value of `sig`\n\nThe behavior of the module should be as follows:\n- The clock signal should toggle every 10 time units.\n- When `sig` is equal to 4'b0000, set the least significant bit (`thing[0]`) to 1.\n- When `sig` is equal to 4'b0010, set the third bit (`thing[2]`) to 1.\n- When `sig` is equal to 4'b0011, set the ninth bit (`thing[9]`) to 1.\n- The module should finish execution after the initial block.\n\nWrite a verilog module that implements this behavior.\n\n", "output": "module clock_and_case (\n  input clk,\n  input [3:0] sig,\n  output reg [7:0] thing\n);\n\n  // generate a clock\n  always #10 clk = ~clk;\n\n  // set specific bits in thing based on sig\n  always @ (sig)\n    case (sig)\n      4'b0000: thing[0] = 1'b1;\n      4'b0010: thing[2] = 1'b1;\n      4'b0011: thing[9] = 1'b1;\n      default:  thing = thing; // do nothing\n    endcase\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that takes in a 4-bit input and outputs a 2-bit output. The module should have a clock input, a reset input, and an enable input. The module should only output the 2-bit output when the enable input is high. The module should also have a counter that counts up every clock cycle when the enable input is high and resets to zero when the reset input is high. The 2-bit output should be equal to the count value modulo 4.\n\nYou are provided with the following code snippet as a starting point:\n\n```\nmodule counter (\n    input clk,\n    input reset,\n    input enable,\n    input [3:0] in,\n    output reg [1:0] out\n);\n\n    // your code here\n\nendmodule\n```\n\nPlease complete the module by adding the necessary Verilog code to meet the requirements specified above.\n\n", "output": "module counter (\n    input clk,\n    input reset,\n    input enable,\n    input [3:0] in,\n    output reg [1:0] out\n);\n\n    reg [3:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (enable) begin\n            out <= count[1:0];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit input and outputs a 4-bit output. The module should have two inputs and one output. The first input is a 50MHz clock signal, and the second input is a 4-bit binary number. The output should be the 2's complement of the input number. \n\nDesign the module and name it \"TwosComplement\".\n\n", "output": "module TwosComplement (\n   input clk,\n   input [3:0] in,\n   output reg [3:0] out\n   );\n\n   always @(posedge clk) begin\n      out <= ~in + 1;\n   end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in eight inputs and produces one output. The module should be named `multifunc` and should be written in Verilog. The eight inputs are as follows:\n\n- `a`: 1-bit input\n- `b`: 1-bit input\n- `c`: 1-bit input\n- `d`: 1-bit input\n- `e`: 1-bit input\n- `f`: 1-bit input\n- `g`: 1-bit input\n- `h`: 1-bit input\n\nThe output of the module, `out`, should be a 1-bit value that is determined by the following rules:\n\n- If `a` is 1, `out` should be the logical AND of `b` and `c`.\n- If `a` is 0, `out` should be the logical OR of `d`, `e`, `f`, `g`, and `h`.\n\nWrite the Verilog code for the `multifunc` module that satisfies the above requirements.\n\n", "output": "module multifunc(\n  input a,\n  input b,\n  input c,\n  input d,\n  input e,\n  input f,\n  input g,\n  input h,\n  output out\n);\n\n  wire and_out;\n  wire or_out;\n  \n  and and_gate(b, c, and_out);\n  or or_gate(d, e, f, g, h, or_out);\n  \n  assign out = a ? and_out : or_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a 4-to-1 multiplexer using Verilog. The module should have 4 input bits (A0, A1, A2, A3), 2 select bits (S0, S1), and 1 output bit (Y). The multiplexer should select one of the four inputs based on the values of the select bits. If S1S0 is 00, Y should be equal to A0. If S1S0 is 01, Y should be equal to A1. If S1S0 is 10, Y should be equal to A2. If S1S0 is 11, Y should be equal to A3. The module should also have two input pins for power (VPWR) and ground (VGND).\n\nYour task is to write a Verilog module that implements this 4-to-1 multiplexer. The module should be named \"mux4to1\" and should have the following inputs and outputs:\n\nInputs:\n- A0, A1, A2, A3: 4-bit input signals\n- S0, S1: 2-bit select signals\n- VPWR: power input\n- VGND: ground input\n\nOutputs:\n- Y: 1-bit output signal\n\nYou should ensure that your design follows good Verilog coding practices, and that it synthesizes correctly.\n\n", "output": "module mux4to1(\n    input [3:0] A0,\n    input [3:0] A1,\n    input [3:0] A2,\n    input [3:0] A3,\n    input S0,\n    input S1,\n    input VPWR,\n    input VGND,\n    output reg Y\n);\n\n    always @ (S1 or S0 or A0 or A1 or A2 or A3) begin\n        case ({S1, S0})\n            2'b00: Y <= A0;\n            2'b01: Y <= A1;\n            2'b10: Y <= A2;\n            2'b11: Y <= A3;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that increments the write pointer of a first-in first-out (FIFO) buffer. The module should take in three inputs: `ge2_free`, `ge3_free`, and `input_tm_cnt`, and output a 4-bit signal `fifo_wrptr_inc`. \n\nThe `ge2_free` and `ge3_free` inputs are single-bit signals that indicate whether there are two or three free slots in the FIFO buffer, respectively. The `input_tm_cnt` input is a 2-bit signal that indicates the number of slots that will be used in the FIFO buffer. \n\nThe `fifo_wrptr_inc` output should be set according to the following conditions:\n- If `ge3_free` is high and `input_tm_cnt` is equal to 3, `fifo_wrptr_inc` should be set to 3.\n- If `ge2_free` is high and `input_tm_cnt` is greater than or equal to 2, `fifo_wrptr_inc` should be set to 2.\n- If `input_tm_cnt` is greater than or equal to 1, `fifo_wrptr_inc` should be set to 1.\n- Otherwise, `fifo_wrptr_inc` should be set to 0.\n\nDesign a Verilog module that implements this logic.\n\n", "output": "module fifo_write_ptr_inc (\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [3:0] fifo_wrptr_inc\n);\n\n  always @*\n    case ({ge3_free, input_tm_cnt})\n      2'b11: fifo_wrptr_inc = 3;\n      2'b10: if (ge2_free) fifo_wrptr_inc = 2;\n              else fifo_wrptr_inc = 1;\n      2'b01: fifo_wrptr_inc = 1;\n      default: fifo_wrptr_inc = 0;\n    endcase\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a 2:1 multiplexer that selects between two inputs based on a control signal. The module should have the following inputs and outputs:\n\n- `input [7:0] A`: the first input to the multiplexer\n- `input [7:0] B`: the second input to the multiplexer\n- `input sel`: the control signal that selects between `A` and `B`\n- `output [7:0] Y`: the output of the multiplexer\n\nUse the provided code snippet as a reference for the module header and port definitions, and ensure that the module uses the `sky130_fd_sc_hd__mux2_1` cell for the actual selection logic.\n\n", "output": "module mux_2to1 (\n    input [7:0] A,\n    input [7:0] B,\n    input sel,\n    output [7:0] Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_hd__mux2_1 select (\n        .A(A),\n        .B(B),\n        .S(sel),\n        .Z(Y)\n    );\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-bit counter with an enable input and a synchronous reset input. The counter should be able to count up to 7 and wrap around to 0. When the counter reaches the maximum value, it should stop counting until the enable input goes low and then starts counting again. When the synchronous reset input is high, the counter should reset to 0.", "output": "module counter_3bit (\n  input clk,\n  input reset,\n  input enable,\n  output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 0;\n  end else if (enable) begin\n    if (count == 7) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\nend\n\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2-to-1 multiplexer with an enable input. The module should have two 1-bit inputs (A and B), an enable input (EN), and a 1-bit output (Y). When EN is low, Y should be equal to A. When EN is high, Y should be equal to B.", "output": "module mux_2to1_enable (\n    input A,\n    input B,\n    input EN,\n    output reg Y\n);\n\nalways @ (A, B, EN) begin\n    if (EN == 1'b0) begin\n        Y = A;\n    end else begin\n        Y = B;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that takes two 1-bit inputs, `In0` and `In1`, and concatenates them into a 2-bit output signal, `dout`. The module should be named `concat_1bit_to_2bit` and should include the following:\n- A module declaration with the specified inputs and output\n- A combinational logic implementation that concatenates the two input signals into the output signal\n- Any necessary input and output signal declarations\n\n", "output": "module concat_1bit_to_2bit(\n  input [0:0] In0,\n  input [0:0] In1,\n  output [1:0] dout\n);\n\n  assign dout = {In1, In0};\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple calculator that performs addition and subtraction operations on two 8-bit inputs. The calculator should have the following interface:\n\nInputs:\n- `clk`: the clock signal\n- `rst`: the reset signal, active high\n- `op`: a 1-bit signal that determines the operation to be performed, where `0` indicates addition and `1` indicates subtraction\n- `a`: an 8-bit input value\n- `b`: an 8-bit input value\n\nOutputs:\n- `out`: an 8-bit output value that represents the result of the operation\n- `valid`: a 1-bit signal that indicates when the output value is valid (i.e., after the first clock cycle)\n\nThe module should perform the following operations:\n- If `rst` is high, the output `out` and `valid` should be set to `0`\n- If `op` is `0`, the output `out` should be the sum of `a` and `b`\n- If `op` is `1`, the output `out` should be the difference between `a` and `b`\n- The output `valid` should be set to `1` after the first clock cycle where the operation is complete\n\n", "output": "module simple_calculator(\n    input clk,\n    input rst,\n    input op,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg valid\n);\n\nreg [7:0] sum;\nreg [7:0] diff;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        out <= 0;\n        valid <= 0;\n    end else begin\n        if (op == 0) begin\n            sum <= a + b;\n            out <= sum;\n        end else begin\n            diff <= a - b;\n            out <= diff;\n        end\n        valid <= 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with asynchronous set, asynchronous reset, and scan enable features. The module should have the following inputs and outputs:\n\nInputs:\n- `in` (1 bit): data input\n- `clock` (1 bit): clock input\n- `sin` (1 bit): asynchronous set input\n- `scanen` (1 bit): scan enable input\n\nOutputs:\n- `out` (1 bit): data output\n\nImplement the flip-flop using the following code snippet as a starting point:\n\n```\nmodule Mflipflop_s (out, in, scanen, sin, clock);\noutput out ;\ninput in ;\ninput clock ;\ninput sin ;\ninput scanen ;\n\n\n\tASFFA dff (\n\t    .Q(out),\n\t    .D(in),\n\t    .SM(scanen),\n\t    .SI(sin),\n\t    .CK(clock)\n\t);\n\nendmodule\n```\n\nYour task is to complete the implementation of the flip-flop by adding the necessary logic for the asynchronous reset feature. The reset input should be active-low and should reset the flip-flop to 0 when asserted. Assume that the reset input is not affected by the scan enable feature.\n\n", "output": "module Mflipflop_s (out, in, scanen, sin, clock, reset);\noutput out ;\ninput in ;\ninput clock ;\ninput sin ;\ninput scanen ;\ninput reset;\n\nwire reset_nor;\nassign reset_nor = ~(reset & ~clock);\n\n\tASFFA dff (\n\t    .Q(out),\n\t    .D(in),\n\t    .SM(scanen),\n\t    .SI(sin),\n\t    .CK(clock),\n\t    .R(reset_nor)\n\t);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that can perform the same functionality as a D flip-flop, but this time, use pipeline structure to achieve it. The module should have one input port for the data signal and one input port for the clock signal. The output port should provide a signal that is the result of the data signal being delayed by one clock cycle. Please provide a brief explanation within 100 words on how to achieve this using pipeline structure.", "output": "module pipeline_dff (\n    input clk,\n    input d,\n    output reg q,\n    output reg q_delayed\n);\n\nreg q_pipeline;\n\nalways @(posedge clk) begin\n    q_pipeline <= d;\n    q <= q_pipeline;\nend\n\nalways @(posedge clk) begin\n    q_delayed <= q_pipeline;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit memory block with look-up table (LUT) functionality. The module should have four inputs and one output. The inputs are:\n- `clka`: a clock signal\n- `ena`: an enable signal\n- `addra`: a 4-bit address signal\n- `dina`: a 4-bit data input signal\n\nThe output is:\n- `douta`: a 4-bit data output signal\n\nThe module should store the input data in memory at the specified address when the `ena` signal is high. When the `ena` signal is low, the module should output the data stored at the address specified by `addra`.\n\nYou are given the following code snippet as a starting point for your module:\n\n```\nmodule lut_mem_block(\n  input wire clka,\n  input wire ena,\n  input wire [3:0] addra,\n  input wire [3:0] dina,\n  output wire [3:0] douta\n);\n\n// your code goes here\n\nendmodule\n```\n\nPlease write the code for the `lut_mem_block` module that implements the memory block with LUT functionality as described above.\n\n", "output": "module lut_mem_block(\n  input wire clka,\n  input wire ena,\n  input wire [3:0] addra,\n  input wire [3:0] dina,\n  output wire [3:0] douta\n);\n\n  reg [3:0] mem [0:15];\n  wire [3:0] douta;\n\n  always @(posedge clka) begin\n    if (ena) begin\n      mem[addra] <= dina;\n    end\n    douta <= mem[addra];\n  end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module that implements a multiplier block. The module has one input port and one output port, where the input port is a 32-bit data signal and the output port is a 32-bit data signal. The module has multiple internal wires that are used to implement the multiplier block. \n\nThe module has the following internal wires:\n- w1: a 32-bit wire that is assigned the value of the input port.\n- w4: a 32-bit wire that is assigned the value of w1 left-shifted by 2 bits.\n- w5: a 32-bit wire that is assigned the sum of w1 and w4.\n- w8192: a 32-bit wire that is assigned the value of w1 left-shifted by 13 bits.\n- w8187: a 32-bit wire that is assigned the difference between w8192 and w5.\n- w160: a 32-bit wire that is assigned the value of w5 left-shifted by 5 bits.\n- w8027: a 32-bit wire that is assigned the difference between w8187 and w160.\n- w16054: a 32-bit wire that is assigned the value of w8027 left-shifted by 1 bit.\n\nYou are required to implement the multiplier block module.\n\n", "output": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w4,\n    w5,\n    w8192,\n    w8187,\n    w160,\n    w8027,\n    w16054;\n\n  assign w1 = i_data0;\n  assign w4 = w1 << 2;\n  assign w5 = w1 + w4;\n  assign w8192 = w1 << 13;\n  assign w8187 = w8192 - w5;\n  assign w160 = w5 << 5;\n  assign w8027 = w8187 - w160;\n  assign w16054 = w8027 << 1;\n\n  assign o_data0 = w16054;\n\n  //multiplier_block area estimate = 5272.34396680147;\nendmodule"}
{"instruction": "Create an XOR gate using a behavioral always block and a case statement. The module should take two input bits and output their XOR result.", "output": "module xor_gate(input a, b, output out);\n    reg out;\n    always @ (a, b)\n        case ({a, b})\n            2'b00: out = 1'b0;\n            2'b01: out = 1'b1;\n            2'b10: out = 1'b1;\n            2'b11: out = 1'b0;\n        endcase\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a dual-port RAM with the following specifications:\n\n- The RAM should have a data width of 24 bits and an address width of 9 bits.\n- The module should have two clock inputs, `clk_a` and `clk_b`, and two address inputs, `addr_a` and `addr_b`.\n- The module should have a write enable input, `we_a`, and a data input, `data_a`.\n- The module should have an output, `q_b`, which outputs the data stored at the address specified by `addr_b`.\n\nDesign a Verilog module that meets these specifications. \n\n", "output": "module pixel_ram\n#(parameter DATA_WIDTH=24, parameter ADDR_WIDTH=9)\n(\n\tinput [(DATA_WIDTH-1):0] data_a,\n\tinput [(ADDR_WIDTH-1):0] addr_a, addr_b,\n\tinput we_a, clk_a, clk_b,\n\toutput reg [(DATA_WIDTH-1):0] q_b\n);\n\n\t// Declare the RAM variable\n\treg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];\n\n\talways @ (posedge clk_a)\n\tbegin\n\t\tif (we_a) \n\t\t\tram[addr_a] <= data_a;\n\tend\n\n\talways @ (posedge clk_b)\n\tbegin\n\t\tq_b <= ram[addr_b];\n\tend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary adder-subtractor. The module should have three inputs: two 4-bit binary numbers, A and B, and a mode select input, M. When M is 0, the module should perform addition, and when M is 1, the module should perform subtraction. The module should have one 4-bit binary output, Y, which represents the result of the addition or subtraction operation.\n\nYou should implement the module using only combinational logic, and not use any built-in Verilog operators or functions for addition or subtraction.\n\nAssume that A, B, and Y are all unsigned binary numbers, and that overflow should not be considered.\n\nDesign a module named \"adder_subtractor\" that meets the above requirements.\n\n", "output": "module adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input M,\n    output [3:0] Y\n);\n\n    wire [3:0] B_comp;\n    wire [3:0] temp_sum;\n    wire [3:0] temp_diff;\n\n    // Complement B if M is 1\n    assign B_comp = M ? ~B + 1 : B;\n\n    // Calculate the sum and difference\n    assign temp_sum = A + B_comp;\n    assign temp_diff = A - B_comp;\n\n    // Select output based on M\n    assign Y = M ? temp_diff : temp_sum;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit adder that takes in two 4-bit inputs (A and B) and outputs a 4-bit sum (S) and a carry-out bit (Cout). The adder should be implemented using full adders (FA) and a carry-in bit (Cin). The module should have the following interface:\n\nInputs:\n- A (4-bit input)\n- B (4-bit input)\n- Cin (1-bit input)\n\nOutputs:\n- S (4-bit output)\n- Cout (1-bit output)\n\nYou should instantiate the FA module in your design, which has the following interface:\n\nInputs:\n- A (1-bit input)\n- B (1-bit input)\n- Cin (1-bit input)\n\nOutputs:\n- S (1-bit output)\n- Cout (1-bit output)\n\nYou should also use the following verilog code snippet to implement the 4-bit adder:\n\n```\nmodule FA (\n\tinput A, B, Cin,\n\toutput S, Cout\n);\n\n\tassign S = A ^ B ^ Cin;\n\tassign Cout = (A & B) | (A & Cin) | (B & Cin);\n\nendmodule\n\nmodule four_bit_adder (\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n);\n\n\twire c0, c1, c2;\n\n\tFA fa0 (.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(c0));\n\tFA fa1 (.A(A[1]), .B(B[1]), .Cin(c0), .S(S[1]), .Cout(c1));\n\tFA fa2 (.A(A[2]), .B(B[2]), .Cin(c1), .S(S[2]), .Cout(c2));\n\tFA fa3 (.A(A[3]), .B(B[3]), .Cin(c2), .S(S[3]), .Cout(Cout));\n\nendmodule\n```\n\nImplement the `four_bit_adder` module using the `FA` module.\n\n", "output": "module FA (\n\tinput A, B, Cin,\n\toutput S, Cout\n);\n\n\tassign S = A ^ B ^ Cin;\n\tassign Cout = (A & B) | (A & Cin) | (B & Cin);\n\nendmodule\n\nmodule four_bit_adder (\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n);\n\n\twire c0, c1, c2;\n\n\tFA fa0 (.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(c0));\n\tFA fa1 (.A(A[1]), .B(B[1]), .Cin(c0), .S(S[1]), .Cout(c1));\n\tFA fa2 (.A(A[2]), .B(B[2]), .Cin(c1), .S(S[2]), .Cout(c2));\n\tFA fa3 (.A(A[3]), .B(B[3]), .Cin(c2), .S(S[3]), .Cout(Cout));\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module that includes a Test module that has one output and one input. The output is a 32-bit wire signal and the input is a 32-bit wire signal. There is also a result signal that is a 64-bit wire signal and a clock signal that is a single bit. The module has a test loop that executes on the positive edge of the clock signal. Inside the loop, the module increments a cycle counter, updates a Cyclic Redundancy Check (CRC) signal, and updates a sum signal. The module also has a conditional statement that checks the value of the cycle counter. If the cycle counter is zero, the module initializes the CRC and sum signals. If the cycle counter is less than 10, the module sets the sum signal to zero. If the cycle counter is between 10 and 90, the module does nothing. If the cycle counter is 99, the module prints the cycle count, the CRC value, and the sum value. The module then checks if the CRC and sum values match pre-defined values. If either value does not match its pre-defined value, the module stops execution. You need to write the Verilog code to implement the Test module.\n\nWrite a Verilog module named Test that has one output and one input. The output is a 32-bit wire signal named \"out\" and the input is a 32-bit wire signal named \"in\". The Test module should generate a 32-bit output signal that is the result of performing a bitwise XOR operation on the input signal with a pre-defined 32-bit value. \n\n", "output": "module Test (\n   input [31:0] in,\n   output [31:0] out\n);\n\n   assign out = in ^ 32'h5a5a5a5a;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a 2-bit comparator module that compares two 2-bit inputs, A and B, and returns a 2-bit output, Z. If A is greater than B, Z should be 2'b01. If A is less than B, Z should be 2'b10. If A is equal to B, Z should be 2'b11. You can implement this module using combinational logic or a state machine.", "output": "module two_bit_comparator (\n  input [1:0] A,\n  input [1:0] B,\n  output reg [1:0] Z\n);\n\n  always @* begin\n    if (A > B) begin\n      Z = 2'b01;\n    end else if (A < B) begin\n      Z = 2'b10;\n    end else begin\n      Z = 2'b11;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a digital circuit that performs a bitwise AND operation between two 8-bit input vectors, A and B. The result of the operation should be stored in an 8-bit output vector, C. \n\nDesign a Verilog module that implements this circuit. The module should have the following inputs and outputs:\n- A: an 8-bit input vector\n- B: an 8-bit input vector\n- C: an 8-bit output vector\n\nYour design should use the \"AND\" operator to perform the bitwise AND operation. You may not use any other operators or functions to perform this operation. \n\nWrite a testbench to verify that your design is correct. Your testbench should generate random input vectors A and B, and compare the output vector C produced by your design to the expected output vector.\n\n", "output": "module bitwise_and(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] C\n);\n\n    assign C = A & B;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module in Verilog for a simple digital circuit that implements a D flip-flop with asynchronous reset and set. The module should have the following input and output ports:\n\n- Data input port (D)\n- Output port (Q)\n- Asynchronous reset input port (RESET)\n- Asynchronous set input port (SET)\n- Negative edge-triggered clock input port (CLK_N)\n- Power-related input ports (NOTIFIER, VPWR, VGND)\n\nThe module should implement the following behavior:\n\n- When the reset input is asserted (i.e., RESET = 1), the output Q should be set to 0, regardless of the value of the data input.\n- When the set input is asserted (i.e., SET = 1), the output Q should be set to 1, regardless of the value of the data input.\n- When the clock input transitions from high to low (i.e., CLK_N changes from 1 to 0), the output Q should be updated with the value of the data input.\n\nNote that the power-related input ports (NOTIFIER, VPWR, VGND) are not relevant to the functionality of the module, but are included for completeness.\n\nWrite a Verilog module that implements the behavior described above, using no more than 200 lines of code.\n\n", "output": "module dff_reset_set (\n    input  D,\n    output Q,\n    input  RESET,\n    input  SET,\n    input  CLK_N\n);\n\nreg Q_reg;\n\nalways @ (negedge CLK_N) begin\n    if (RESET) begin\n        Q_reg <= 0;\n    end else if (SET) begin\n        Q_reg <= 1;\n    end else begin\n        Q_reg <= D;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `t` which has an input clock signal `clk`. The module instantiates another module `t_inst_v2k_sub` and connects its inputs and outputs. The `t_inst_v2k_sub` module has the following inputs and outputs:\n- `isizedwire`: an 8-bit wide register\n- `ionewire`: a single bit register\n- `oonewire`: a single bit wire\n- `tied`: a 2-bit wide wire\n- `tied_also`: a 4-bit wide wire\n- `osizedreg`: an 8-bit wide wire\n\nThe module `t` also has the following internal variables:\n- `cyc`: an integer initialized to 1\n- `low`: a 2-bit wide supply0 vector\n- `high`: a 2-bit wide supply1 vector\n\nThe module `t` instantiates another module `hello` and connects its input `tied_also`. The `hello` module has no outputs and only one input `tied_also` which is a 4-bit wide wire.\n\nThe module `t` has an always block which executes on the positive edge of `clk`. Inside the always block, there are several if statements which execute based on the value of `cyc`. The code checks if the values of `low`, `high`, `oonewire`, `isizedwire`, `tied`, and `tied_also` are as expected. If any of these values are not as expected, the simulation is stopped. The simulation is stopped after all the checks are passed.\n\nYou are required to write the Verilog code for the `hello` module. The `hello` module should have an input `tied_also` which is a 4-bit wide wire. The module should output nothing. The `hello` module should take the input `tied_also` and perform the following operation on it: if the 2nd bit of `tied_also` is 0, the 3rd bit of `tied_also` should be inverted. If the 2nd bit of `tied_also` is 1, the 1st bit of `tied_also` should be inverted. The output of the `hello` module should be the modified `tied_also` signal.\n\n", "output": "module hello (\n   input [3:0] tied_also\n   );\n\n   wire [3:0] inverted_tied_also;\n\n   assign inverted_tied_also[3] = tied_also[3];\n   assign inverted_tied_also[2] = tied_also[2];\n   assign inverted_tied_also[1] = ~tied_also[1];\n   assign inverted_tied_also[0] = tied_also[0];\n\n   assign tied_also = (tied_also[2] == 1'b0) ? inverted_tied_also : (tied_also[1] == 1'b0) ? inverted_tied_also : tied_also;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit binary adder. The module should have two inputs, A and B, representing the two binary numbers to be added, and one output, Z, representing the sum of the two binary numbers. The input and output should be 4-bit vectors. The module should also have a control input, C, which determines whether the addition should be performed in binary or two's complement form.\n\nIf C is 0, the module should perform binary addition. In this case, the module should simply add the two binary numbers and output the result in binary form.\n\nIf C is 1, the module should perform two's complement addition. In this case, the module should first convert the two binary numbers to their two's complement form, add them together, and then convert the result back to binary form. The module should output the result in binary form.\n\nYou should write a Verilog module that satisfies the above requirements. Your module should be named \"binary_adder\" and should be no longer than 200 lines of code.\n\n", "output": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input C,\n    output [3:0] Z\n);\n\n    wire [3:0] A_comp, B_comp;\n    wire [4:0] sum;\n    wire carry;\n\n    assign A_comp = (~A) + 1;\n    assign B_comp = (~B) + 1;\n\n    assign sum = A_comp + B_comp + C;\n\n    assign carry = sum[4];\n\n    assign Z = (C) ? (~sum[3:0] + 1) : sum[3:0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Build a circuit that always outputs a HIGH, except when the input signal is a specific value. Use a 3-bit input signal and define the specific value as any combination of two bits being HIGH.", "output": "module always_high_except_specific (\n  input [2:0] data,\n  output reg out\n);\n\n  always @(*) begin\n    if (data[2:1] == 2'b11 || data[1:0] == 2'b11) begin\n      out <= 1'b0;\n    end else begin\n      out <= 1'b1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-input AND gate. The module should have the following inputs and outputs:\n\nInputs:\n- A1 (1-bit)\n- A2 (1-bit)\n- A3 (1-bit)\n- A4 (1-bit)\n\nOutputs:\n- X (1-bit)\n\nThe module should be named \"and_gate\" and should be designed using structural verilog. You are only allowed to use basic logic gates (AND, OR, NOT, etc.) and not any pre-existing modules.\n\n", "output": "module and_gate (\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  A4  ,\n    output X   \n);\n\nwire w1, w2, w3;\n\nand(w1, A1, A2);\nand(w2, A3, A4);\nand(w3, w1, w2);\nassign X = w3;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that performs unsigned multiplication of two 8-bit numbers using a shift and add algorithm. The module should have two 8-bit inputs (a and b) and a 16-bit output (p). The output should be the product of a and b.", "output": "module unsigned_multiplier (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n\nreg [7:0] shift_reg;\nreg [3:0] count;\n\nalways @(*) begin\n    p = 0;\n    shift_reg = b;\n    count = 8;\n    \n    while(count > 0) begin\n        if(shift_reg[0] == 1) begin\n            p = p + (a << (8 - count));\n        end\n        shift_reg = shift_reg >> 1;\n        count = count - 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a combinational circuit with two outputs: HI and LO. The module should have two input ports, pullup0 and pulldown0, which are respectively connected to a pull-up resistor and a pull-down resistor. The HI and LO outputs should be connected to the output of the pull-up and pull-down resistors, respectively.\n\nYour module should implement the following logic:\n- If both pullup0 and pulldown0 are high, then HI should be high and LO should be low.\n- If both pullup0 and pulldown0 are low, then HI should be low and LO should be high.\n- If pullup0 is high and pulldown0 is low, then HI should be high and LO should be high.\n- If pullup0 is low and pulldown0 is high, then HI should be low and LO should be low.\n\nYou should write a Verilog module named \"combinational_circuit\" that implements this logic. Your module should have the following ports:\n- input pullup0\n- input pulldown0\n- output HI\n- output LO\n\nYour module should be self-contained and solvable by only one module within 200 lines of Verilog code. Your code should be syntactically correct, and should be written in a way that is easy to read and understand.\n\n", "output": "module combinational_circuit (\n    input pullup0,\n    input pulldown0,\n    output HI,\n    output LO\n);\n\n    assign HI = pullup0 & ~pulldown0;\n    assign LO = ~pullup0 & pulldown0;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a simple counter. The counter should have a 4-bit output and should increment by one on each clock cycle. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK` : a clock signal\n- `RST` : a reset signal\n\nOutputs:\n- `Q` : a 4-bit output representing the current count value\n\n\nThe module should reset to zero when the reset signal is high and should count up on each rising edge of the clock signal. \n\n", "output": "module simple_counter (\n    input CLK,\n    input RST,\n    output [3:0] Q\n);\n\nreg [3:0] count;\n\nalways @(posedge CLK) begin\n    if(RST) begin\n        count <= 0;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nassign Q = count;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a demultiplexer (DEMUX). \nA demultiplexer is a digital circuit that takes a single input signal and selects one of several output signals based on the value of a select signal. \nThe select signal is used to choose which output signal should be active.\nYour module should have the following inputs and outputs:\n\nInputs: a single input signal (in), a select signal (sel)\nOutputs: a set of n output signals (out1, out2, ..., outn)\nThe module should also have the following parameter:\n\nn: the number of output signals\nYour module should implement the following functionality:\nThe circuit should have n output signals, each of which is connected to a separate output pin.\nThe circuit should have a single input signal, which is connected to the input pin.\nThe circuit should have a select signal, which is used to determine which output signal is active.\nWhen the select signal is 0, the first output signal should be active and all other output signals should be inactive.\nWhen the select signal is 1, the second output signal should be active and all other output signals should be inactive.\nWhen the select signal is 2, the third output signal should be active and all other output signals should be inactive.\nAnd so on, up to the nth output signal.\nTo implement the DEMUX, you should use Verilog code to define the functionality of the select signal. \nYou should then use this signal to connect the input signal to the appropriate output signal.\nFinally, you should use the appropriate output signal to compute the output signals.", "output": "module DEMUX (\n  input in,\n  input [log2(n)-1:0] sel,\n  output [n-1:0] out\n);\n\nparameter n = 8; // number of output signals\n\nassign out = {n{1'b0}}; // initialize all output signals to 0\n\nalways @(*) begin\n  case(sel)\n    0: out[0] = in;\n    1: out[1] = in;\n    2: out[2] = in;\n    3: out[3] = in;\n    4: out[4] = in;\n    5: out[5] = in;\n    6: out[6] = in;\n    7: out[7] = in;\n    default: out = {n{1'b0}}; // if sel is out of range, set all outputs to 0\n  endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-to-2 priority encoder. The module should have four inputs (A, B, C, and D) and two outputs (Y1 and Y0). The priority encoder should output a binary number that represents the highest input that is active. If multiple inputs are active, the encoder should output the binary number that represents the input with the highest priority (A has the highest priority, followed by B, C, and D).", "output": "module priority_encoder (\n    input [3:0] ABCD,\n    output reg [1:0] Y\n);\n\nalways @* begin\n    case(ABCD)\n        4'b0001: Y = 2'b00;\n        4'b0010: Y = 2'b01;\n        4'b0100: Y = 2'b10;\n        4'b1000: Y = 2'b11;\n        4'b0011: Y = 2'b01;\n        4'b0101: Y = 2'b10;\n        4'b0110: Y = 2'b10;\n        4'b1001: Y = 2'b11;\n        4'b0111: Y = 2'b10;\n        4'b1011: Y = 2'b11;\n        4'b1101: Y = 2'b11;\n        4'b1110: Y = 2'b11;\n        default: Y = 2'b00;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit up/down counter. The circuit should have two inputs, an up/down control input (U/D) and a clock input (clk). When U/D is high, the counter should increment by one on each rising edge of the clock. When U/D is low, the counter should decrement by one on each rising edge of the clock. The circuit should have a single 4-bit output (Q) that represents the current count value.", "output": "module updown_counter (\n    input clk,\n    input U_D,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (U_D == 1'b1) begin\n            Q <= Q + 1;\n        end\n        else begin\n            Q <= Q - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock multiplexer. \nA clock multiplexer is a digital circuit that selects one of several input clocks and outputs it as the system clock. \nYour module should have the following inputs and outputs:\n\nInputs: a set of n input clock signals (clk1, clk2, ..., clkn), a select signal (sel)\nOutputs: a system clock signal (sys_clk)\nThe module should also have the following parameter:\n\nn: the number of input clock signals\nYour module should implement the following functionality:\n\nWhen the select signal is 0, the system clock signal should be equal to clk1.\nWhen the select signal is 1, the system clock signal should be equal to clk2.\nWhen the select signal is 2, the system clock signal should be equal to clk3.\nAnd so on, for all n input clock signals.\nTo implement the clock multiplexer, you should use Verilog code to define the functionality of the select signal as a binary decoder. \nYou should then use this decoder to select the appropriate input clock signal and output it as the system clock signal.", "output": "module clock_mux (\n  input [n-1:0] clk,\n  input [log2(n)-1:0] sel,\n  output sys_clk\n);\n\nparameter n = 4; // number of input clock signals\n\nreg [n-1:0] select;\n\nalways @ (sel) begin\n  case (sel)\n    0: select = 1'b0001;\n    1: select = 1'b0010;\n    2: select = 1'b0100;\n    3: select = 1'b1000;\n    default: select = 1'b0001;\n  endcase\nend\n\nassign sys_clk = clk & select;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a D-type latch. \nA D-type latch is a digital circuit that stores one bit of data. It has two inputs: a data input (D) and a clock input (CLK), and two outputs: a Q output and a Q-bar output. When the clock input is high (i.e., CLK = 1), the latch stores the value of the data input. When the clock input is low (CLK = 0), the latch holds its previous value. \n\nYour module should have the following inputs and outputs:\n\nInputs: \n- D: the data input \n- CLK: the clock input \n\nOutputs: \n- Q: the Q output \n- Q-bar: the Q-bar output \n\nYour module should implement the following functionality:\n- When CLK is high, the output Q should be equal to the input D. \n- When CLK is low, the output Q should hold its previous value.\n- The output Q-bar should be the complement of the output Q.\n\nTo implement the D-type latch, you should use Verilog code to create a positive-edge triggered flip-flop with an enable input. \nYou should then use this flip-flop to implement the D-type latch by connecting the data input to the flip-flop's D input, the clock input to the flip-flop's CLK input, and the flip-flop's Q and Q-bar outputs to the module's Q and Q-bar outputs, respectively.", "output": "module d_latch (\n  input D,\n  input CLK,\n  output Q,\n  output Q_bar\n);\n\nreg Q;\nreg Q_bar;\n\nalways @(posedge CLK)\nbegin\n  Q <= D;\n  Q_bar <= ~D;\nend\n\nendmodule"}
{"instruction": "\n\nIn the given Verilog code snippet, there is a module named \"bw_io_sstl_bscan\" that consists of both input and output ports. The module is designed to interface with a boundary-scan (bscan) chain and a memory controller. The module has 11 inputs and 5 outputs, and it is responsible for routing the data between the bscan chain and the memory controller. \n\nYour task is to implement a sub-module named \"dram_pad_scan_jtag\" that will be used inside the \"bw_io_sstl_bscan\" module. The \"dram_pad_scan_jtag\" sub-module is responsible for controlling the output enable (oe) signal of the \"bw_io_sstl_bscan\" module. The sub-module should have the following inputs and outputs:\n\nInputs:\n- \"rcv_in\": a single bit input signal that is used to control the output enable signal.\n- \"drv_oe\": a single bit input signal that is used to enable/disable the output driver.\n\nOutputs:\n- \"oe\": a single bit output signal that is used to control the output enable signal of the \"bw_io_sstl_bscan\" module.\n\nYou need to implement the \"dram_pad_scan_jtag\" sub-module that will control the \"oe\" output signal based on the input signals \"rcv_in\" and \"drv_oe\". The \"oe\" signal should be high only if both \"rcv_in\" and \"drv_oe\" signals are high, otherwise, it should be low.\n\nWrite the Verilog code for the \"dram_pad_scan_jtag\" sub-module that satisfies the above requirements. Your implementation should not exceed 20 lines of code.\n\n", "output": "module dram_pad_scan_jtag (\n    input rcv_in,\n    input drv_oe,\n    output oe\n);\n    assign oe = rcv_in & drv_oe;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a digital logic circuit. The module should take in three inputs A, B, and C_N, and output a single output X. The module should implement the logic function of an OR gate, specifically a sky130_fd_sc_lp__or3b_lp gate. The module should also have five additional inputs: VPWR, VGND, VPB, VNB, which are all inputs that are used to power and ground the circuit. \n\nYour task is to write a Verilog module that implements the sky130_fd_sc_lp__or3b_lp gate. The module should be named \"my_or_gate\" and should have the following inputs and outputs:\n\nInputs:\n- A (1-bit)\n- B (1-bit)\n- C_N (1-bit)\n- VPWR (1-bit)\n- VGND (1-bit)\n- VPB (1-bit)\n- VNB (1-bit)\n\nOutputs:\n- X (1-bit)\n\nYou should use the sky130_fd_sc_lp__or3b_lp gate to implement the OR function. You are not allowed to use any other gates or modules in your implementation. Your module should also include the necessary power and ground connections to ensure proper functionality.\n\n", "output": "module my_or_gate (\n    input A,\n    input B,\n    input C_N,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    sky130_fd_sc_lp__or3b_lp base (\n        .X(X),\n        .A(A),\n        .B(B),\n        .C_N(C_N),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that can perform a binary multiplication operation. The module should take two 8-bit inputs `a` and `b` and produce a 16-bit output `result`. You are not allowed to use any built-in verilog operators for multiplication.\n\nDesign the module `binary_multiplier` that takes the inputs `a` and `b` and produces the output `result`. The module should have the following ports:\n- `input [7:0] a`\n- `input [7:0] b`\n- `output [15:0] result`\n\nYou may use any other built-in operators or modules. However, the design should be optimized for area and not for speed.\n\n", "output": "module binary_multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n    );\n    \n    wire [15:0] temp_result;\n    \n    assign temp_result = {8'b0, a} * {8'b0, b};\n    \n    assign result = temp_result;\n    \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder with carry-in and carry-out. Use behavioral modeling to define the module. The 4-bit adder should be able to perform addition of two 4-bit numbers and output the result along with the carry-out.", "output": "module four_bit_adder (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  reg [3:0] sum;\n  reg cout;\n  \n  always @(*) begin\n    sum = a + b + cin;\n    cout = (sum > 4'b1111) ? 1 : 0;\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a D flip-flop with enable and set/reset functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK` (1-bit): clock input\n- `D` (1-bit): data input\n- `EN` (1-bit): enable input\n- `SET` (1-bit): set input\n- `RESET` (1-bit): reset input\n\nOutputs:\n- `Q` (1-bit): output\n- `Q_bar` (1-bit): complement of output\n\nThe module should operate as follows:\n- When `EN` is high, the flip-flop should operate normally, with `Q` taking on the value of `D` on the rising edge of `CLK`.\n- When `SET` is high and `EN` is high, `Q` should be set to 1 on the rising edge of `CLK`.\n- When `RESET` is high and `EN` is high, `Q` should be set to 0 on the rising edge of `CLK`.\n\nYour task is to design a Verilog module that meets the above requirements. The module should be self-contained and should not rely on any external modules or testbenches. It should be no longer than 200 lines of code.\n\n", "output": "module dff_en_sr (\n  input CLK,\n  input D,\n  input EN,\n  input SET,\n  input RESET,\n  output reg Q,\n  output reg Q_bar\n);\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      if (SET) begin\n        Q <= 1'b1;\n      end else if (RESET) begin\n        Q <= 1'b0;\n      end else begin\n        Q <= D;\n      end\n    end\n  end\n\n  assign Q_bar = ~Q;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit magnitude comparator. The module should have two 4-bit inputs, A and B, and two outputs, EQ and GT. EQ should be high if A is equal to B, and GT should be high if A is greater than B. Otherwise, both outputs should be low. You may assume that the inputs are unsigned and that the module should be synthesizable.\n\nCreate a module named \"magnitude_comparator\" that implements the above functionality. \n\n", "output": "module magnitude_comparator(\n  input [3:0] A,\n  input [3:0] B,\n  output EQ,\n  output GT\n);\n\n  assign EQ = (A == B);\n  assign GT = (A > B);\n\nendmodule"}
{"instruction": "\n\nYou have been hired by a company to design a module for a circuit that will be used in a new product. The module should be designed using Verilog and should be no more than 200 lines of code. The circuit will have 1 output and 9 inputs. The output is called `Y` and the inputs are called `A1`, `A2`, `B1`, `B2`, `C1`, `VPWR`, `VGND`, `VPB`, and `VNB`. The module should be named `sky130_fd_sc_ms__a221oi_1`.\n\nYour task is to design the module using the provided code snippet as a reference. The `sky130_fd_sc_ms__a221oi` module is already provided and should be used as a base for your module. You should connect the inputs and output of the `sky130_fd_sc_ms__a221oi` module to the inputs and output of your module.\n\nYour module should be able to take the inputs and produce an output according to the following truth table:\n\n```\nA1 | A2 | B1 | B2 | C1 | VPWR | VGND | VPB | VNB | Y\n----------------------------------------------------\n0  | 0  | 0  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 0  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 0  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 0  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 1  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 1  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 1  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 0  | 1  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 0  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 0  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 0  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 0  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 1  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 1  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 1  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n0  | 1  | 1  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 0  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 0  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 0  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 0  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 1  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 1  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 1  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 0  | 1  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 0  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 0  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 0  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 0  | 1  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 1  | 0  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 1  | 0  | 1  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 1  | 1  | 0  | 0    | 0    | 0   | 0   | 0\n1  | 1  | 1  | 1  | 1  | 0    | 0    | 0   | 0   | 1\n```\n\nYour module should follow the standard Verilog syntax and should be well documented.\n\n", "output": "module sky130_fd_sc_ms__a221oi_1 (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ms__a221oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .B2(B2),\n        .C1(C1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 3-to-8 decoder with enable input and active-high outputs. The module should have three inputs: enable (1-bit input), select (2-bit input), and invert (1-bit input). The module should have eight outputs, each corresponding to a unique combination of the select input. When enable is high, the selected output should be high if invert is low, and low if invert is high, and all other outputs should be low.", "output": "module decoder (\n    input enable,\n    input [1:0] select,\n    input invert,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case (select)\n        2'b00: out = enable ? (invert ? 8'b11111110 : 8'b00000001) : 8'b00000000;\n        2'b01: out = enable ? (invert ? 8'b11111101 : 8'b00000010) : 8'b00000000;\n        2'b10: out = enable ? (invert ? 8'b11111011 : 8'b00000100) : 8'b00000000;\n        2'b11: out = enable ? (invert ? 8'b11110111 : 8'b00001000) : 8'b00000000;\n        default: out = 8'b00000000;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 4-bit adder using Verilog. The adder should have two 4-bit inputs, A and B, and a carry-in input, Cin. The output should be a 4-bit sum, S, and a carry-out output, Cout. You are not allowed to use any built-in Verilog operators or functions for addition.\n\nDesign a Verilog module that implements the 4-bit adder described above. Your module should be named \"four_bit_adder\". The module should have the following inputs and outputs:\n\n- Inputs: A (4-bit), B (4-bit), Cin (1-bit)\n- Outputs: S (4-bit), Cout (1-bit)\n\nYour implementation should be as efficient as possible and should minimize the number of gates used.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] xor_out;\n    wire [3:0] and_out1;\n    wire [3:0] and_out2;\n\n    assign xor_out = A ^ B;\n    assign and_out1 = A & B;\n    assign and_out2 = xor_out & Cin;\n\n    assign S = xor_out ^ Cin;\n    assign Cout = and_out1 | and_out2;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit register that can store data and output it on a positive edge clock signal. The register should have a write enable signal that will allow new data to be written to the register when it is asserted. The module should have the following ports:\n\n- `data_in`: 4-bit input bus that will be written to the register when the write enable signal is asserted.\n- `data_out`: 4-bit output bus that will output the current value stored in the register on the positive edge of the clock signal.\n- `we`: Write enable signal that will allow new data to be written to the register when it is asserted.\n- `clk`: Positive edge clock signal that will trigger the output of the current value stored in the register.\n\nYou should use the `always` block to implement the logic for the register.\n\n", "output": "module four_bit_register\n(\n  input [3:0] data_in,\n  input we,\n  input clk,\n  output [3:0] data_out\n);\n\n  reg [3:0] data_out_reg;\n\n  always @(posedge clk) begin\n    if (we) begin\n      data_out_reg <= data_in;\n    end\n  end\n\n  assign data_out = data_out_reg;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that implements a 4-bit counter. The counter should have a synchronous reset input, an enable input, and an output that outputs the current count value. The counter should increment by 1 on every rising edge of the clock signal when the enable input is high. When the reset input is high, the counter should be reset to 0. The module should be named \"counter_4bit\".\n\n", "output": "module counter_4bit (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            count <= 4'b0;\n        end else if (en) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that sign-extends a 16-bit number to 64 bits. To achieve this, you need to replicate the sign bit (the most significant bit) of the 16-bit number to the left, 48 times. Then, concatenate the 16-bit number with the replicated bits to form the final 64-bit number. Please name your module \"sign_extend_16_to_64\" and define the following IOs:\n- input [15:0] num_in: the 16-bit number to be sign-extended\n- output reg [63:0] num_out: the 64-bit sign-extended number", "output": "module sign_extend_16_to_64 (\n  input [15:0] num_in,\n  output reg [63:0] num_out\n);\n\n  reg [47:0] sign_bits; // 48 replicated sign bits\n  \n  // replicate sign bit\n  always @(*) begin\n    sign_bits = {48{num_in[15]}};\n  end\n  \n  // concatenate sign bits with num_in\n  always @(*) begin\n    num_out = {sign_bits, num_in};\n  end\n  \nendmodule\n"}
{"instruction": "\n\nWrite a Verilog module that implements a 5-input LUT and four D flip-flops. The module should have the following inputs and outputs:\n\nInputs:\n- `in0`, `in1`, `in2`, `in3`, `in4`: 1-bit inputs\n- `clk`: clock input\n- `reset`: asynchronous reset input\n\nOutputs:\n- `q0`, `q1`, `q2`, `q3`: 1-bit outputs\n\nThe LUT should implement the following Boolean function:\n```\nf(in0, in1, in2, in3, in4) = in0 & in1 & in2 & in3 & in4\n```\nThe flip-flops should be positive-edge triggered and should be initialized to 0 on reset.\n\n", "output": "module lut_ff (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input in4,\n  input clk,\n  input reset,\n  output reg q0,\n  output reg q1,\n  output reg q2,\n  output reg q3\n);\n\n  wire lut_out;\n  assign lut_out = in0 & in1 & in2 & in3 & in4;\n\n  always @(posedge clk or negedge reset) begin\n    if (~reset) begin\n      q0 <= 1'b0;\n      q1 <= 1'b0;\n      q2 <= 1'b0;\n      q3 <= 1'b0;\n    end else begin\n      q0 <= lut_out;\n      q1 <= q0;\n      q2 <= q1;\n      q3 <= q2;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a register unit in Verilog that has the following inputs and outputs:\n\nInputs:\n- `data_in`: an 8-bit input signal\n- `load`: a 1-bit control signal that determines whether the value of `data_in` should be loaded into the register\n- `clk`: a clock signal\n- `rst`: a reset signal\n\nOutputs:\n- `data_out`: an 8-bit output signal that is the value stored in the register\n\nThe register unit should be implemented using a single Verilog module. The module should have a parameter `ff_sz` that determines the size of the register. The default value of `ff_sz` should be 8.\n\nThe behavior of the register unit should be as follows:\n- When `rst` is low, the value of `data_out` should be set to 0.\n- When `load` is high and the rising edge of `clk` occurs, the value of `data_in` should be loaded into the register and stored in `data_out`.\n- When `load` is low and the rising edge of `clk` occurs, the value of `data_out` should remain unchanged.\n\n", "output": "module reg_unit #(parameter ff_sz=8)\n\t(\toutput reg[ff_sz-1:0] data_out,\n\t\tinput [ff_sz-1:0] data_in,\n\t\tinput load,\n\t\tinput clk, rst);\n\n\talways @(posedge clk or negedge rst)\n\t\tif (~rst)\n\t\t\tdata_out <= 0;\n\t\telse if (load)\n\t\t\tdata_out <= data_in;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a half adder and a full adder. \nIn digital electronics, an adder is a circuit that performs the arithmetic addition of two binary numbers. A half adder adds two single binary digits and returns a sum and carry bit. A full adder adds three binary digits and returns a sum and carry bit. \n\nYour module should have the following inputs and outputs for the half adder:\n\nInputs: two single binary digits (a, b)\nOutputs: a sum bit (s) and a carry bit (c)\n\nYour module should have the following inputs and outputs for the full adder:\n\nInputs: three single binary digits (a, b, cin)\nOutputs: a sum bit (s) and a carry bit (cout)\n\nTo implement the half adder, you should use Verilog code to define the sum and carry bits as Boolean functions of the input signals. \n\nTo implement the full adder, you should use Verilog code to define the sum and carry bits as Boolean functions of the input signals and the carry bit from the previous stage. You should use the half adder module to implement the first stage of the full adder, which adds the first two digits and generates a carry bit. You should then use the Verilog code to add the generated carry bit to the third input digit to produce the final sum and carry bits.", "output": "module HalfAdder (\n  input a,\n  input b,\n  output s,\n  output c\n);\n  assign s = a ^ b;\n  assign c = a & b;\nendmodule\n\nmodule FullAdder (\n  input a,\n  input b,\n  input cin,\n  output s,\n  output cout\n);\n  wire c1;\n  wire s1;\n  HalfAdder HA1(.a(a), .b(b), .s(s1), .c(c1));\n  HalfAdder HA2(.a(s1), .b(cin), .s(s), .c(cout));\n  assign cout = c1 | cout;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit comparator. The module should have two 4-bit input ports, A and B, and three 1-bit output ports, EQ, GT, and LT. The EQ port should be high when A and B are equal, the GT port should be high when A is greater than B, and the LT port should be high when A is less than B. You may choose to use any combinatorial logic operators.", "output": "module comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  output EQ,\n  output GT,\n  output LT\n);\n\n  assign EQ = (A == B);\n  assign GT = (A > B);\n  assign LT = (A < B);\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-input AND gate. The AND gate should have four inputs named A1, A2, B1, and B2, and a single output named X. In addition, the module should have four input pins named VPWR, VGND, VPB, and VNB, which represent the power supply voltage, ground voltage, positive bias voltage, and negative bias voltage, respectively.\n\nYour module should be named \"and_gate\" and should be contained within 200 lines of verilog code. The module should be able to handle all possible combinations of input values and should output a logic high (1) only when all four inputs are high (1).\n\n", "output": "module and_gate (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    wire and1;\n    wire and2;\n    wire and3;\n    \n    assign and1 = A1 & A2;\n    assign and2 = B1 & B2;\n    assign and3 = and1 & and2;\n    \n    assign X = and3;\n    \nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in three 4-bit inputs, A, B, and C, and outputs the value of A if C is 0, B if C is 1, and A XOR B if C is 2.", "output": "module conditional_output (\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] C,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(C)\n        2: out = A ^ B;\n        1: out = B;\n        default: out = A;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 4 inputs (S0, S1, S2, S3) and 2 select signals (Sel[1], Sel[0]). The module should output one of the four inputs based on the select signals. \n\nThe select signals work as follows:\n- If Sel[1] is 0, the output will be either S0 or S1, depending on the value of Sel[0]. \n- If Sel[1] is 1, the output will be either S2 or S3, depending on the value of Sel[0].\n\nYour task is to design a Verilog module that implements this functionality. The module should be named \"MUX4_1_SL\" and should take in the following inputs and outputs:\n\nInputs:\n- Sel[1:0] (2-bit input)\n- S0, S1, S2, S3 (4-bit inputs)\n\nOutputs:\n- out (4-bit output)\n\nYou should ensure that the module is completely self-contained, meaning that it should not rely on any other modules to function.\n\n", "output": "module MUX4_1_SL(Sel, S0, S1, S2, S3, out);\n\ninput [1:0] Sel;\ninput [3:0] S0, S1, S2, S3;\noutput [3:0] out;\n\nassign out = (Sel[1] ? (Sel[0] ? S3 : S2) : (Sel[0] ? S1 : S0));\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a pulse width modulator (PWM). \nA PWM is a type of digital circuit used to control the amount of power delivered to a load by varying the width of the pulses of a periodic signal.\nYour module should have the following inputs and outputs:\n\nInputs: \n- clk: the clock signal\n- data_in: the data signal, which determines the duty cycle of the output PWM signal\n- max_count: the maximum count value for the counter\n\nOutputs: \n- pwm_out: the output PWM signal\n\nYour module should implement the following functionality:\n\n- The counter should count from 0 to max_count on each rising edge of the clock signal.\n- When the counter value is less than data_in, the output PWM signal should be high.\n- When the counter value is greater than or equal to data_in, the output PWM signal should be low.\n- The duty cycle of the PWM signal should be determined by the value of data_in relative to the value of max_count.\n- The output PWM signal should have a frequency equal to the frequency of the clock signal.\n\nTo implement the PWM, you should use Verilog code to define a counter that increments on each rising edge of the clock signal. \nYou should then use the value of data_in to determine when the output PWM signal should be high or low, and use this signal to set the output value.\nFinally, you should ensure that the output PWM signal has the correct frequency by synchronizing it with the clock signal.", "output": "module pwm (\n  input clk,\n  input [7:0] data_in,\n  input [15:0] max_count,\n  output reg pwm_out\n);\n\nreg [15:0] count;\n\nalways @(posedge clk) begin\n  if (count == max_count) begin\n    count <= 0;\n  end else begin\n    count <= count + 1;\n  end\n  \n  if (count < data_in) begin\n    pwm_out <= 1;\n  end else begin\n    pwm_out <= 0;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary counter. The counter should have an asynchronous reset input and an enable input. The counter should increment on the rising edge of the enable input. The counter should reset to 0 on the rising edge of the reset input.\n\nYour task is to design and implement the Verilog module for this 4-bit binary counter. Your module should be self-contained and should not rely on any external modules or libraries. You should implement the counter using only basic Verilog constructs such as combinational logic gates and flip-flops.\n\nYour module should have the following inputs and outputs:\n\n- `clk`: the clock input\n- `reset`: the asynchronous reset input\n- `enable`: the enable input\n- `count`: the 4-bit binary count output\n\nAssume that all inputs are synchronous to the clock and that the clock period is long enough to allow for proper operation of the counter.\n\nRemember to keep your module within 200 lines of Verilog code.\n\n", "output": "module binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit adder-subtractor. The module should have two 4-bit inputs, one 1-bit input (SUB), and one 4-bit output. If SUB is high, the module should perform subtraction of the second input from the first input. If SUB is low, the module should perform addition of the two inputs. The output should be the result of the operation.", "output": "module adder_subtractor (\n    input [3:0] in0,\n    input [3:0] in1,\n    input SUB,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        if (SUB) begin\n            out <= in0 - in1;\n        end else begin\n            out <= in0 + in1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock buffer driver. \nA clock buffer driver is an important component in digital circuits that is responsible for driving a clock signal to all the sequential logic elements in the circuit. \nThe clock buffer driver module should have the following inputs and outputs:\n\nInputs: \n- clk_in: the input clock signal\n- enable: an enable signal that enables or disables the output clock signal\n- div: a divisor parameter that determines the frequency of the output clock signal relative to the input clock signal\n\nOutputs:\n- clk_out: the output clock signal\n\nYour module should implement the following functionality:\n\n- When enable is high, the module should divide the frequency of the input clock signal by the value of the div parameter to generate the output clock signal.\n- When enable is low, the output clock signal should be high impedance.\n- The module should use a buffer to drive the output clock signal.\n\nTo implement the clock buffer driver, you should use Verilog code to define the logic for dividing the frequency of the input clock signal and for enabling/disabling the output clock signal. \nYou should then use a buffer to drive the output clock signal.", "output": "module clock_buffer_driver (\n  input clk_in,\n  input enable,\n  input [7:0] div,\n  output reg clk_out\n);\n\n  reg [7:0] counter;\n  wire clk_divided;\n\n  assign clk_divided = (counter == div) ? 1'b1 : 1'b0;\n\n  always @(posedge clk_in) begin\n    if (enable) begin\n      if (counter == div) begin\n        counter <= 0;\n        clk_out <= ~clk_out;\n      end\n      else begin\n        counter <= counter + 1;\n      end\n    end\n    else begin\n      clk_out <= 1'bz;\n    end\n  end\n\n  bufif0 buf (\n    .in(clk_divided),\n    .en(enable),\n    .out(clk_out)\n  );\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a full adder. \nA full adder is a combinational circuit that is used to add three bits: two inputs and a carry bit. \nThe outputs of a full adder are the sum of the three bits and a carry bit that is used to add the next set of bits. \nYour module should have the following inputs and outputs:\n\nInputs: three input signals (a, b, c_in)\nOutputs: two output signals (sum, c_out)\n\nYour module should implement the following functionality:\n\nThe circuit should compute the sum of the three input bits (a, b, c_in) and generate a carry bit (c_out) that is used to add the next set of bits.\nYou should use Verilog code to define the Boolean functions for the sum and carry bits in terms of the input signals. \nYou should then use these functions to connect the inputs to the outputs.", "output": "module full_adder (\n  input a,\n  input b,\n  input c_in,\n  output sum,\n  output c_out\n);\n\n  assign sum = a ^ b ^ c_in;\n  assign c_out = (a & b) | (c_in & (a ^ b));\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit synchronous counter. The module should have two inputs, a clock signal and a reset signal, and one output, the current count value. The counter should increment on each rising edge of the clock signal, and reset to zero when the reset signal is asserted. The counter should be implemented using a register.\n\nImplement the module `four_bit_counter` with the following ports:\n- `clk`: input clock signal\n- `reset`: asynchronous reset signal\n- `count`: output current count value\n\nUse the following template to define your module:\n```\nmodule four_bit_counter (\n    // inputs:\n    input clk,\n    input reset,\n    // outputs:\n    output reg [3:0] count\n);\n\n// your code here\n\nendmodule\n```\n\nNote: You can use any verilog keywords and operators as needed.\n\n", "output": "module four_bit_counter (\n    // inputs:\n    input clk,\n    input reset,\n    // outputs:\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Design a 1-bit wide, 256-to-1 multiplexer using Verilog. The inputs are packed into a single 256-bit input vector. The selection signal should be a 1-bit input, with sel=0 selecting in[0], sel=1 selecting in[255], and all other values of sel selecting the corresponding input. The module must be designed using a combinational logic architecture.", "output": "module top_module(\n    input [255:0] in,\n    input [7:0] sel,\n    output reg out\n);\n\nalways @(*) begin\n    case (sel)\n        8'b00000000: out = in[0];\n        8'b00000001: out = in[1];\n        8'b00000010: out = in[2];\n        8'b00000011: out = in[3];\n        8'b00000100: out = in[4];\n        8'b00000101: out = in[5];\n        8'b00000110: out = in[6];\n        8'b00000111: out = in[7];\n        8'b00001000: out = in[8];\n        // ...\n        8'b11111110: out = in[254];\n        8'b11111111: out = in[255];\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that can perform a simple arithmetic operation on two 8-bit input values. The operation to be performed is determined by a 2-bit control signal. The possible operations are:\n- 00: Addition\n- 01: Subtraction\n- 10: Bitwise AND\n- 11: Bitwise OR\n\nThe module should have the following ports:\n- `input [7:0] A`: the first input value\n- `input [7:0] B`: the second input value\n- `input [1:0] op`: the control signal that determines the operation to perform\n- `output [7:0] out`: the output value\n\nYour module should be able to perform the specified operation and output the result on the `out` port. You should assume that the inputs are valid and that overflow/underflow is not a concern.\n\nYou are required to write a module that solves this problem within 200 lines of Verilog code.\n\n", "output": "module simple_arithmetic (\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] op,\n    output [7:0] out\n);\n\n    wire [7:0] add_out = A + B;\n    wire [7:0] sub_out = A - B;\n    wire [7:0] and_out = A & B;\n    wire [7:0] or_out = A | B;\n\n    assign out = (op == 2'b00) ? add_out :\n                 (op == 2'b01) ? sub_out :\n                 (op == 2'b10) ? and_out :\n                                 or_out;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a pipelined OR gate module that includes a synchronous reset input. \nThe output of the module should be the logical OR of two inputs 'a' and 'b'. \nUse pipeline structure to achieve this functionality and include a synchronous reset input 'reset' that clears the output of the pipeline when asserted.", "output": "module pipelined_or_gate(\n    input a, \n    input b,\n    input reset,\n    output reg out\n);\n\nreg stage1_out, stage2_out;\n\nalways @(posedge clk) begin\n    if(reset) begin\n        stage1_out <= 1'b0;\n        stage2_out <= 1'b0;\n        out <= 1'b0;\n    end\n    else begin\n        stage1_out <= a | b;\n        stage2_out <= stage1_out;\n        out <= stage2_out;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that will take in two 8-bit inputs, A and B, and produce a 16-bit output Z. The module should have two modes of operation: a normal mode and a reset mode. In normal mode, the output Z should be the sum of all the products of A and B that have been input since the last reset. In reset mode, the output Z should be set to zero.\n\nDesign a verilog module that satisfies these requirements. Your module should have the following inputs and outputs:\n- clk: a clock input\n- rst: a reset input\n- A: an 8-bit input\n- B: an 8-bit input\n- Z: a 16-bit output\n\nYou may assume that the inputs A and B will always be valid.\n\n", "output": "module sum_of_products (\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output reg  [15:0] Z\n);\n\n    always @(posedge clk)\n        if (rst) Z <= 16'd0;\n        else     Z <= Z + (A * B);\n\nendmodule"}
{"instruction": "\n\nYou are required to design a verilog module that implements a 1-to-2 multiplexer with an asynchronous active-high reset. The module should have the following ports:\n\n- `clk`: input clock signal\n- `rst`: asynchronous active-high reset signal\n- `din0`: input data signal 0\n- `din1`: input data signal 1\n- `sel`: selection signal\n- `dout`: output data signal\n\nWhen `rst` is high, `dout` should be set to 0. When `sel` is high, `dout` should be equal to `din1`. When `sel` is low, `dout` should be equal to `din0`.\n\nYou are required to use behavioral verilog to implement this module.\n\n", "output": "module mux_1to2_async_rst(\n    input clk,\n    input rst,\n    input din0,\n    input din1,\n    input sel,\n    output dout\n);\n\n    reg dout_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dout_reg <= 0;\n        end else begin\n            if (sel) begin\n                dout_reg <= din1;\n            end else begin\n                dout_reg <= din0;\n            end\n        end\n    end\n\n    assign dout = dout_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder with carry-in and carry-out. The module should have four inputs, two 4-bit numbers A and B, a carry-in signal CIN and a clock signal CLK. The module should have two outputs, a 4-bit sum S and a carry-out signal COUT. The module should use a synchronous design approach, and the sum output should be updated on each rising edge of the clock signal.", "output": "module four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input CIN,\n  input CLK,\n  output reg [3:0] S,\n  output reg COUT\n);\n\n  always @(posedge CLK) begin\n    // calculate sum\n    S <= A + B + CIN;\n    // calculate carry-out\n    COUT <= (A[3] & B[3]) | (A[3] & CIN) | (B[3] & CIN);\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit binary number and outputs the two's complement of the number. The two's complement is calculated by inverting all the bits and adding 1 to the result. For example, the two's complement of binary 0010 is 1110 (inverting all the bits gives 1101 and adding 1 gives 1110).", "output": "module twos_complement (\n    input [3:0] binary,\n    output reg [3:0] twos_comp\n);\n\n    assign twos_comp = ~binary + 1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in four 8-bit inputs (i3, i2, i1, i0) and outputs a 32-bit signal (o). The output should be a concatenation of the four inputs in the order they are given. The module should be named \"concat_module\" and should be no longer than 200 lines of Verilog code.\n\nYour task is to write the Verilog code for the \"concat_module\" that meets the following requirements:\n- The input ports should be named \"i3\", \"i2\", \"i1\", and \"i0\", and should be of size 8 bits.\n- The output port should be named \"o\" and should be of size 32 bits.\n- The output port should be a concatenation of the four input ports in the order they are given.\n- The module should be named \"concat_module\".\n- The module should be no longer than 200 lines of Verilog code.\n\nYou can assume that the inputs will always be valid 8-bit signals.\n\n", "output": "module concat_module (\n    input [7:0] i3,\n    input [7:0] i2,\n    input [7:0] i1,\n    input [7:0] i0,\n    output [31:0] o\n);\n\nassign o = {i3, i2, i1, i0};\n\nendmodule"}
{"instruction": "Design a module that implements a 3-bit shift register using a single D flip-flop and a multiplexer. The module should have a single input and output port, and should be capable of shifting the input bits to the right by one position whenever the clock signal is triggered. The output should be the shifted input bits.", "output": "module shift_register ( input clk, input d, output reg [2:0] q );\n\n  reg [2:0] register;\n\n  always @(posedge clk) begin\n    register[0] <= d;\n    register[1] <= register[0];\n    register[2] <= register[1];\n  end\n\n  assign q = register;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock gate module that will enable or disable the clock signal to a specific register based on the state of two input signals. The module should be named \"clock_gate\" and should have the following inputs and outputs:\n\nInputs:\n- clk (1-bit): the clock signal that needs to be gated\n- en (1-bit): the enable signal that determines whether the clock should be gated or not\n- te (1-bit): the trigger enable signal that determines whether the clock should be gated or not\n\nOutputs:\n- enclk (1-bit): the gated clock signal that will be fed to the register\n\nThe module should use a D flip-flop with asynchronous set and reset to implement the clock gating functionality. The flip-flop should be sensitive to the positive edge of the clock signal. When the enable signal is high, the flip-flop should operate normally, and the gated clock signal should be the same as the original clock signal. When the enable signal is low, the gated clock signal should be held low, regardless of the state of the original clock signal. When the trigger enable signal is low, the gated clock signal should be held low, regardless of the state of the enable signal.\n\nWrite the Verilog code for the \"clock_gate\" module that implements the clock gating functionality as described above.\n\n", "output": "module clock_gate (\n  input clk,\n  input en,\n  input te,\n  output reg enclk\n);\n\n  always @ (posedge clk) begin\n    if (te == 0 || en == 1) begin\n      enclk <= clk;\n    end else begin\n      enclk <= 0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes a 4-bit input and returns a 8-bit output. The output should be the result of multiplying the input by a constant value of 20. The multiplier should be implemented using a combination of shifts and additions.\n\nUse the following template to complete the task:\n\n```\nmodule multiplier (\n    input   [3:0] i_data,\n    output  [7:0] o_data\n);\n\n  // Declare any required wires or variables here\n\n  // Implement the multiplier using shifts and additions\n\n  // Assign the output value to o_data\n\nendmodule\n```\n\n", "output": "module multiplier (\n    input   [3:0] i_data,\n    output  [7:0] o_data\n);\n\n  // Declare any required wires or variables here\n  wire [3:0] w1;\n  wire [7:0] w20;\n\n  // Implement the multiplier using shifts and additions\n  assign w1 = i_data << 2;\n  assign w20 = w1 + (i_data << 5);\n\n  // Assign the output value to o_data\n  assign o_data = w20;\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, decoupling capacitors are used to reduce noise and voltage fluctuations in the power supply. In this problem, you are tasked with designing a Verilog module that models a decoupling capacitor.\n\nYou need to implement a Verilog module named `decap` that has two input ports and no output ports. The input ports are `VPWR` and `VGND`, which represent the power supply voltage and ground, respectively. The module should simulate the behavior of a capacitor by charging and discharging based on the voltage levels of its input ports.\n\nYour module should have the following behavior:\n- When `VPWR` is high and `VGND` is low, the capacitor should charge up to the voltage level of `VPWR`.\n- When `VPWR` is low and `VGND` is high, the capacitor should discharge down to the voltage level of `VGND`.\n- When both `VPWR` and `VGND` are low or high, the capacitor should maintain its current voltage level.\n\nYou may assume that the voltage levels of `VPWR` and `VGND` are always either high or low, and that the module will be used in a larger circuit that will handle any necessary timing or clocking.\n\n", "output": "module decap (\n    input VPWR,\n    input VGND\n);\n\n    reg [31:0] voltage = 0; // initialize voltage to 0\n\n    always @(*) begin\n        if (VPWR && !VGND) begin // charge up to VPWR\n            voltage = voltage + 1;\n        end else if (!VPWR && VGND) begin // discharge down to VGND\n            voltage = voltage - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a 4-bit binary counter. The counter should have an asynchronous reset input, a clock input, and an output that represents the current count. The counter should be able to count up to 15 (1111 in binary) before rolling over to 0.\n\nDesign a verilog module that implements this counter. Your module should be named \"counter\" and should have the following inputs and outputs:\n\nInputs:\n- rst: Asynchronous reset input, active-high\n- clk: Clock input\n\nOutputs:\n- count: 4-bit output representing the current count\n\nYour module should use only combinational and sequential logic in its implementation. You should not use any pre-built counters or other modules in your design. Your module should be no more than 200 lines of verilog code.\n\n", "output": "module counter(\n    input rst,\n    input clk,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            count <= 4'b0;\n        end else if(count == 4'b1111) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a memory generator module for a digital circuit. The module should be able to read and write data to a block memory in the circuit. The memory should have a width of 12 bits and a depth of 16384 words. The module should have the following inputs and outputs:\n\nInputs:\n- `clka`: a clock signal\n- `addra`: a 15-bit address input\n- `dina`: a 12-bit data input\n- `wea`: a write enable signal\n\nOutputs:\n- `douta`: a 12-bit data output\n\nThe memory should be implemented using block RAMs and should be able to support both synchronous and asynchronous read and write operations. The module should also be parameterizable, allowing the user to specify the memory width and depth.\n\nDesign the memory generator module in Verilog, ensuring that it meets the above requirements. Your module should be self-contained and should not include other modules.\n\n", "output": "module memory_generator\n   (douta,\n    clka,\n    addra,\n    dina,\n    wea);\n  output [11:0] douta;\n  input clka;\n  input [14:0] addra;\n  input [11:0] dina;\n  input [0:0] wea;\n\n  reg [11:0] ram [0:16383];\n  reg [11:0] douta;\n  integer i;\n\n  always @(posedge clka) begin\n    if (wea) begin\n      ram[addra[14:0]] <= dina;\n    end\n    douta <= ram[addra[14:0]];\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that compares two n-bit registers, `sig` and `rfr`, and outputs a `check` signal that is high if their values are not equal. The module should also have a `verbose` signal that, when high, prints the values of `sig` and `rfr` using `$display` at each clock cycle. \n\nWrite a Verilog module that satisfies the following requirements:\n- The module should be named `register_comparator`.\n- The module should have the following inputs:\n  - `clk`: a clock signal\n  - `rst`: a synchronous active-high reset signal\n  - `check_en`: an enable signal for the `check` output\n  - `verbose_en`: an enable signal for the `verbose` output\n  - `sig`: an n-bit input register\n  - `rfr`: an n-bit input register\n- The module should have the following outputs:\n  - `check`: a 1-bit output signal that is high if `sig` and `rfr` are not equal\n  - `verbose`: a 1-bit output signal that enables printing of `sig` and `rfr` when high\n\nThe module should have the following behavior:\n- On the rising edge of `clk`, if `rst` is high, the module should reset `sig` and `rfr` to 0.\n- On the rising edge of `clk`, if `rst` is low, the module should compare `sig` and `rfr`. If they are equal, `check` should be low. If they are not equal and `check_en` is high, `check` should be high. If `verbose_en` is high, the values of `sig` and `rfr` should be printed using `$display`.\n\n", "output": "module register_comparator (\n  input clk,\n  input rst,\n  input check_en,\n  input verbose_en,\n  input [n-1:0] sig,\n  input [n-1:0] rfr,\n  output reg check,\n  output reg verbose\n);\n\n  parameter n = 8; // set n to desired bit width\n\n  always @(posedge clk) begin\n    if (rst) begin\n      sig <= 0;\n      rfr <= 0;\n    end else begin\n      sig <= sig;\n      rfr <= rfr;\n      if (sig != rfr && check_en) begin\n        check <= 1;\n      end else begin\n        check <= 0;\n      end\n      if (verbose_en) begin\n        $display(\"sig: %b, rfr: %b\", sig, rfr);\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a memory block generator module that can store and retrieve data. The module should be written in Verilog and should be able to handle 8192 memory locations, each storing 13-bit data. The module should have the following inputs and outputs:\n\n- `clka` : clock input\n- `ena` : enable input\n- `wea` : write enable input\n- `addra` : address input (13-bit wide)\n- `dina` : data input (13-bit wide)\n- `douta` : data output (13-bit wide)\n\nThe module should have the following behavior:\n- On the rising edge of `clka`, if `ena` is high, the module should output the data stored at the memory location specified by `addra` on `douta`.\n- If `wea` is high, the module should write the data on `dina` to the memory location specified by `addra`.\n- The module should not write or output any data if `ena` is low.\n\nWrite a Verilog module that implements the above behavior. Your module should be no longer than 200 lines of code.\n\n", "output": "module memory_block_generator(clka, ena, wea, addra, dina, douta);\n\n  parameter MEM_SIZE = 8192;\n  parameter DATA_WIDTH = 13;\n  \n  input clka;\n  input ena;\n  input wea;\n  input [DATA_WIDTH-1:0] dina;\n  input [MEM_SIZE-1:0] addra;\n  output [DATA_WIDTH-1:0] douta;\n  \n  reg [DATA_WIDTH-1:0] mem [MEM_SIZE-1:0];\n  \n  always @(posedge clka) begin\n    if (ena) begin\n      if (wea) begin\n        mem[addra] <= dina;\n      end\n      douta <= mem[addra];\n    end\n  end\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-stage delay gate with synchronous reset functionality. The module should have the following ports:\n\n- `input A`: the input signal to be delayed\n- `input reset`: a synchronous reset signal that resets the output to 0 when high\n- `output X`: the delayed output signal\n- `input clk`: the clock signal for the synchronous reset\n\nThe module should be named `delay_gate` and should be written in behavioral verilog.\n\n", "output": "module delay_gate(\n    input A,\n    input reset,\n    output reg X,\n    input clk\n);\n\n    reg [3:0] delay_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            delay_reg <= 0;\n            X <= 0;\n        end else begin\n            delay_reg <= {delay_reg[2:0], A};\n            X <= delay_reg[3];\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are given a Verilog module `sky130_fd_sc_ls__a211oi_4` with 8 input ports and 1 output port. The module instantiates another module `sky130_fd_sc_ls__a211oi` and connects its 9 ports to the corresponding ports of `sky130_fd_sc_ls__a211oi_4`. Your task is to write the Verilog code for the `sky130_fd_sc_ls__a211oi` module.\n\nThe `sky130_fd_sc_ls__a211oi` module has 5 input ports and 1 output port. The input ports are named `A1`, `A2`, `B1`, `C1`, and `VPWR`. The output port is named `Y`. The module should implement the following logic:\n\n- If `A1` and `A2` are both high, `Y` should be high.\n- If `A1` and `A2` are both low, `Y` should be low.\n- If `A1` is high and `A2` is low, `Y` should be high if `B1` is high and `C1` is low, and low otherwise.\n- If `A1` is low and `A2` is high, `Y` should be high if `B1` is low and `C1` is high, and low otherwise.\n\nIn addition to the input and output ports, the module should also have 4 power and ground ports named `VPWR`, `VGND`, `VPB`, and `VNB`. You can assume that these ports are connected to the appropriate power and ground sources.\n\n", "output": "module sky130_fd_sc_ls__a211oi (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    assign Y = (A1 & A2) | ((!A1) & (!A2) & B1 & (!C1)) | ((!A1) & (!A2) & (!B1) & C1);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit multiplier using a combinational circuit. The module should have two inputs, each 4 bits wide, and one output, 8 bits wide. The output should represent the product of the two inputs in binary. You can assume that the inputs are unsigned (i.e., non-negative).", "output": "module multiplier (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] product\n);\n\nalways @(*) begin\n    product = {a[0]*b, a[1]*b, a[2]*b, a[3]*b};\nend\n\nendmodule"}
{"instruction": "\n\nYou have been given a verilog module called `multiplier_block` which contains a set of multipliers and a single output. The module has one input port `i_data0` which is a 32-bit wide input bus and one output port `o_data0` which is also a 32-bit wide bus. The module contains the following wires:\n\n- `w1`: a 32-bit wide wire\n- `w511`: a 32-bit wide wire\n- `w512`: a 32-bit wide wire\n- `w128`: a 32-bit wide wire\n- `w129`: a 32-bit wide wire\n- `w1022`: a 32-bit wide wire\n- `w893`: a 32-bit wide wire\n- `w7144`: a 32-bit wide wire\n\nThe following assignments have been made:\n\n- `w1` is assigned the value of `i_data0`\n- `w1022` is assigned the value of `w511` shifted left by 1 bit\n- `w128` is assigned the value of `w1` shifted left by 7 bits\n- `w129` is assigned the sum of `w1` and `w128`\n- `w511` is assigned the difference between `w512` and `w1`\n- `w512` is assigned the value of `w1` shifted left by 9 bits\n- `w7144` is assigned the value of `w893` shifted left by 3 bits\n- `w893` is assigned the difference between `w1022` and `w129`\n\nYour task is to write a verilog code to implement the `multiplier_block` module.\n\n", "output": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w512,\n    w511,\n    w128,\n    w129,\n    w1022,\n    w893,\n    w7144;\n\n  assign w1 = i_data0;\n  assign w1022 = w511 << 1;\n  assign w128 = w1 << 7;\n  assign w129 = w1 + w128;\n  assign w511 = w512 - w1;\n  assign w512 = w1 << 9;\n  assign w7144 = w893 << 3;\n  assign w893 = w1022 - w129;\n\n  assign o_data0 = w7144;\n\n  //multiplier_block area estimate = 5012.88474054412;\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock divider circuit. \nA clock divider circuit is a digital circuit that takes an input clock signal and divides its frequency by a certain factor. \nYour module should have the following inputs and outputs:\n\nInputs: \n- clock: the input clock signal\n- reset: a reset signal that resets the circuit to its initial state\n\nOutputs: \n- clk_out: the output clock signal with divided frequency\n\nThe module should also have the following parameter:\n\n- divisor: the factor by which the frequency of the input clock signal is divided\n\nYour module should implement the following functionality:\n\n- When the reset signal is asserted, the circuit should reset to its initial state, with the output clock signal set to 0.\n- When the reset signal is deasserted, the circuit should start counting the input clock cycles.\n- After every divisor cycles of the input clock signal, the output clock signal should toggle its value.\n\nTo implement the clock divider, you should use Verilog code to count the input clock cycles and toggle the output clock signal after every divisor cycles. \nYou should also use a state machine to ensure that the circuit resets to its initial state when the reset signal is asserted.", "output": "module clock_divider (\n  input clock,\n  input reset,\n  output reg clk_out\n);\n\nparameter divisor = 2; // factor by which the frequency of the input clock signal is divided\n\nalways @ (posedge clock, posedge reset) begin\n  if (reset) begin\n    clk_out <= 0;\n    counter <= 0;\n  end else begin\n    if (counter == divisor - 1) begin\n      clk_out <= ~clk_out;\n      counter <= 0;\n    end else begin\n      counter <= counter + 1;\n    end\n  end\nend\n\nreg [log2(divisor)-1:0] counter;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a simple 4-bit binary adder in Verilog. The module should have two inputs (A and B) and two outputs (S and C_out), where S is the sum of A and B and C_out is the carry-out bit. The module should also have a reset input (RST) that clears the output signals to 0 when asserted.\n\nYour module should be named \"adder_4bit\" and should have the following interface:\n\nInputs:\n- A (4-bit input)\n- B (4-bit input)\n- RST (1-bit input)\n\nOutputs:\n- S (4-bit output)\n- C_out (1-bit output)\n\nYour module should be synthesizable and should use only combinational logic (no stateful elements like registers or flip-flops). Your design should be optimized for area.\n\n", "output": "module adder_4bit(\n  input [3:0] A,\n  input [3:0] B,\n  input RST,\n  output [3:0] S,\n  output C_out\n);\n\n  assign S = A + B;\n  assign C_out = (A[3] & B[3]) | (A[3] & ~S[3]) | (B[3] & ~S[3]);\n\n  // Reset logic\n  assign S = RST ? 4'b0000 : S;\n  assign C_out = RST ? 1'b0 : C_out;\n\nendmodule"}
{"instruction": "\n\nYou have been hired to design a verilog module that implements a D flip-flop with asynchronous reset and set inputs. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: an asynchronous reset signal\n- `set`: an asynchronous set signal\n- `d`: the data input\n\nOutputs:\n- `q`: the output of the flip-flop\n- `q_bar`: the complement of the output\n\nThe module should operate as follows:\n- When the `rst` input is asserted, the output `q` should be set to 0 and `q_bar` should be set to 1.\n- When the `set` input is asserted, the output `q` should be set to 1 and `q_bar` should be set to 0.\n- When neither `rst` nor `set` are asserted, the output `q` should follow the input `d`, and `q_bar` should be the complement of `q`.\n- The output `q` and `q_bar` should be updated on the rising edge of the `clk` signal.\n\nImplement the module using behavioral Verilog code.\n\n", "output": "module d_ff_async_set_reset(clk, rst, set, d, q, q_bar);\n\n  input clk, rst, set, d;\n  output reg q, q_bar;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      q <= 1'b0;\n      q_bar <= 1'b1;\n    end else if (set) begin\n      q <= 1'b1;\n      q_bar <= 1'b0;\n    end else begin\n      q <= d;\n      q_bar <= ~q;\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a memory module using Verilog. The module should be able to store and retrieve data, and should have the following inputs and outputs:\n\nInputs:\n- `data` (64-bit): the data to be written to memory\n- `rdaddress` (26-bit): the address to read from\n- `rdclken` (1-bit): the clock enable for reading\n- `wraddress` (26-bit): the address to write to\n- `wrclock` (1-bit): the clock for writing\n- `wren` (1-bit): write enable signal\n\nOutputs:\n- `q` (64-bit): the data read from memory\n\nThe memory should be implemented using an array of registers, with each register being 64 bits wide. The memory should be able to store up to 67,108,864 (2^26) 64-bit words.\n\nImplement a Verilog module that meets the above requirements. Your module should be self-contained and no more than 200 lines of code.\n\n", "output": "module memory (\n  input [63:0] data,\n  input [25:0] rdaddress,\n  input rdclken,\n  input [25:0] wraddress,\n  input wrclock,\n  input wren,\n  output reg [63:0] q\n);\n\n  reg [63:0] mem_array [67108863:0];\n  reg [25:0] read_address;\n  \n  always @(rdaddress)\n    read_address <= rdaddress;\n\n  always @(posedge wrclock)\n    if (wren)\n      mem_array[wraddress] <= data;\n\n  always @(posedge rdclken)\n    q <= mem_array[read_address];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a module that implements a 2-input AND gate using only NAND gates. The module should have the following inputs and outputs:\n\n- Inputs: A (1-bit), B (1-bit)\n- Output: X (1-bit)\n\nYou can assume that the NAND gate module has the following inputs and outputs:\n\n- Inputs: A (1-bit), B (1-bit)\n- Output: X (1-bit)\n\nYour task is to implement the 2-input AND gate module using only the NAND gate module. You should not use any other gates or modules.\n\nWrite the code for the 2-input AND gate module using only the NAND gate module and ensure that it passes the provided test cases.\n\n", "output": "module nand_gate (\n    input A,\n    input B,\n    output X\n);\n\n    assign X = ~(A & B);\n\nendmodule\n\nmodule and_gate (\n    input A,\n    input B,\n    output X\n);\n\n    wire nand1_out;\n    wire nand2_out;\n\n    nand_gate nand1(.A(A), .B(A), .X(nand1_out));\n    nand_gate nand2(.A(B), .B(B), .X(nand2_out));\n    nand_gate nand3(.A(nand1_out), .B(nand2_out), .X(X));\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit shift register using Verilog. A shift register is a digital circuit that can shift the bits of a binary word by one or more positions. In this case, the shift register should be able to shift the bits to the left or right, depending on a control signal.\n\nThe module should have the following inputs and outputs:\n\n- `data_in`: a 4-bit input that represents the data to be loaded into the shift register.\n- `shift_left`: a control signal that determines the direction of the shift. When `shift_left` is high, the shift register should shift the bits to the left. When `shift_left` is low, the shift register should shift the bits to the right.\n- `clock`: a clock input that is used to synchronize the shift register.\n- `reset`: a reset input that is used to reset the shift register to its initial state.\n- `data_out`: a 4-bit output that represents the current state of the shift register.\n\nThe shift register should operate as follows:\n\n- When the `reset` input is high, the shift register should be reset to all zeros.\n- When the `shift_left` input is high and the `clock` input transitions from low to high (a rising edge), the shift register should shift its contents one bit to the left. The leftmost bit should be discarded, and the `data_in` input should be loaded into the rightmost bit.\n- When the `shift_left` input is low and the `clock` input transitions from low to high (a rising edge), the shift register should shift its contents one bit to the right. The rightmost bit should be discarded, and the `data_in` input should be loaded into the leftmost bit.\n\nWrite a module `shift_register` that implements the above functionality. You can assume that the inputs will always be valid, and that the `clock` input will have a period of 10ns.\n\n", "output": "module shift_register (\n    input [3:0] data_in,\n    input shift_left,\n    input clock,\n    input reset,\n    output [3:0] data_out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clock) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            if (shift_left) begin\n                shift_reg <= {shift_reg[2:0], data_in};\n            end else begin\n                shift_reg <= {data_in, shift_reg[3:1]};\n            end\n        end\n    end\n\n    assign data_out = shift_reg;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a verilog module that implements a 4-to-1 multiplexer. The module should have 4 inputs, 2-bit each, and 2 control inputs, 2-bit each. The output of the module should be the value of the input selected by the control inputs. The module should have the following ports:\n\n* `input [1:0] A, B, C, D`: input values\n* `input [1:0] S1, S0`: control inputs\n* `output reg [1:0] Y`: output value\n\nImplement the module using behavioral modeling and a `case` statement.\n\n", "output": "module MUX4(A, B, C, D, S1, S0, Y);\n  input [1:0] A, B, C, D;\n  input [1:0] S1, S0;\n  output reg [1:0] Y;\n\n  always @(*) begin\n    case ({S1, S0})\n      2'b00: Y = A;\n      2'b01: Y = B;\n      2'b10: Y = C;\n      2'b11: Y = D;\n    endcase\n  end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple calculator that can perform addition, subtraction, multiplication, and division operations on two 8-bit input numbers. The module should have four input ports, two for the 8-bit operands and two for selecting the operation to be performed. The module should also have an 8-bit output port that will hold the result of the operation.\n\nThe operation selection inputs should be encoded as follows:\n- 00: addition\n- 01: subtraction\n- 10: multiplication\n- 11: division\n\nThe module should implement the following operations:\n\n- Addition: The module should add the two input operands and store the result in the output port.\n- Subtraction: The module should subtract the second input operand from the first input operand and store the result in the output port.\n- Multiplication: The module should multiply the two input operands and store the result in the output port.\n- Division: The module should divide the first input operand by the second input operand and store the result in the output port. If the second input operand is 0, the output should be set to 0.\n\nYou should write a verilog module that implements the above requirements. Your module should be named \"simple_calculator\" and should be solvable within 200 lines of verilog code.\n\n", "output": "module simple_calculator(\n    input [7:0] operand1,\n    input [7:0] operand2,\n    input [1:0] operation,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case(operation)\n        2'b00: result = operand1 + operand2; // Addition\n        2'b01: result = operand1 - operand2; // Subtraction\n        2'b10: result = operand1 * operand2; // Multiplication\n        2'b11: begin // Division\n            if(operand2 == 0) begin\n                result = 0;\n            end else begin\n                result = operand1 / operand2;\n            end\n        end\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a simple calculator that performs basic arithmetic operations. The calculator should be able to add, subtract, multiply, and divide two 8-bit numbers. The inputs to the module are two 8-bit numbers, a 3-bit opcode that specifies the operation to be performed, and a clock signal. The output of the module is the result of the arithmetic operation, also an 8-bit number.\n\nThe opcode is defined as follows:\n- 000: addition\n- 001: subtraction\n- 010: multiplication\n- 011: division\n\nYou must implement the calculator using a single Verilog module that is no more than 200 lines long. Your module should be able to handle all possible combinations of inputs and opcodes, and should produce the correct result for each operation.\n\nAssume that the inputs are valid 8-bit numbers, and that division by zero will not occur. You may use any Verilog constructs or operators that you wish, but your implementation should be efficient and use minimal resources.\n\n", "output": "module calculator(input [7:0] num1, num2, input [2:0] opcode, input clk, output reg [7:0] result);\n\nalways @(posedge clk) begin\n    case(opcode)\n        3'b000: result <= num1 + num2;\n        3'b001: result <= num1 - num2;\n        3'b010: result <= num1 * num2;\n        3'b011: result <= num1 / num2;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes three inputs, A1, A2, and B1, and produces a single output, Y. The output Y should be the result of the following logic operations:\n\n1. A1 OR A2\n2. B1 NAND (A1 OR A2)\n\nThe module should be named \"logic_gate\" and should include the necessary input and output ports. You can assume that all inputs are single-bit signals.\n\nWrite the Verilog code for the \"logic_gate\" module that satisfies the above requirements.\n\n", "output": "module logic_gate (\n    input A1,\n    input A2,\n    input B1,\n    output Y\n);\n\n    // Local signals\n    wire or_out;\n    wire nand_out;\n\n    // OR gate\n    or or_gate (\n        .A(A1),\n        .B(A2),\n        .Y(or_out)\n    );\n\n    // NAND gate\n    nand nand_gate (\n        .A(B1),\n        .B(or_out),\n        .Y(nand_out)\n    );\n\n    // Output buffer\n    buf buf_gate (\n        .A(nand_out),\n        .Y(Y)\n    );\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with implementing a verilog module for a 4-bit binary adder that performs addition and subtraction simultaneously. The module should have two 4-bit input ports, A and B, and a single bit input port, sel, which determines whether the operation is addition or subtraction. The module should have two 4-bit output ports, sum and cout. The sum port should output the result of the addition or subtraction, and the cout port should output the carry bit. \n\nImplement the module `addsub` that performs the following operations:\n- If `sel` is 1, the module should perform subtraction, and `sum` should output A-B and `cout` should output the borrow bit.\n- If `sel` is 0, the module should perform addition, and `sum` should output A+B and `cout` should output the carry bit.\n\n", "output": "module addsub(\n    input [3:0] A,\n    input [3:0] B,\n    input sel,\n    output [3:0] sum,\n    output cout\n    );\n\n    wire [3:0] B_comp;\n\n    assign B_comp = ~B + 1;\n\n    assign sum = (sel == 1) ? A + B_comp : A + B;\n    assign cout = (sel == 1) ? (A < B) : (sum < A);\n\nendmodule"}
{"instruction": "Design a 4-bit binary counter that counts from 0 to 15 with a period of 16. The counter should be asynchronous and reset to 0 when the count reaches 15. The module should have one input port for the clock signal, one input port for the asynchronous reset signal, and one output port for the 4-bit binary count.", "output": "module binary_counter (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output reg [3:0] q);\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (q == 4'b1111) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n    \nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output [3:0] q);\n    \n    binary_counter counter(\n        .clk(clk),\n        .reset(reset),\n        .q(q)\n    );\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a clock signal `clk` and a single-bit input `d`. The module should have an output `q` which is a two-bit register. The most significant bit of `q` should always be equal to `d`. The least significant bit of `q` should always be equal to the previous value of the most significant bit of `q`. You should assume that `q` is initialized to `0`.\n\nHowever, there is a bug in the code that needs to be fixed. Due to this bug, the `disable` statement that is used to turn off certain verilator lints is being ignored. You need to fix this bug and ensure that the `disable` statement is properly executed.\n\nYour task is to write the corrected verilog code that implements the above-described functionality.\n\n", "output": "module m2\n  (\n   input clk,\n   input d,\n   // Due to bug the below disable used to be ignored.\n   // verilator lint_off UNOPT\n   // verilator lint_off UNOPTFLAT\n   output reg [1:0] q\n   // verilator lint_on UNOPT\n   // verilator lint_on UNOPTFLAT\n   );\n\n   always @(posedge clk) begin\n      q[1] <= d;\n      q[0] <= q[1];\n   end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-input XOR gate using only AND, OR, and NOT gates.", "output": "module xor_gate(\n    input a,\n    input b,\n    input c,\n    output out\n);\n\nwire nand1, nand2, nand3, nand4, nand5;\n\nassign nand1 = ~(a & b);\nassign nand2 = ~(a & nand1);\nassign nand3 = ~(b & nand1);\nassign nand4 = ~(c & nand2);\nassign nand5 = ~(nand1 & nand3);\n\nassign out = ~(nand4 & nand5);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a Single Port RAM (SRAM) module in Verilog. The SRAM module should support both read and write operations, and have a configurable depth and data width. The module should have the following inputs and outputs:\n\nInputs:\n- `read`: A single bit that specifies if we want to read from the SRAM.\n- `write`: A single bit that specifies if we want to write to the SRAM.\n- `address`: An integer that specifies the address for read/write.\n- `dataIn`: The input data packet.\n- `clk`: The clock input.\n\nOutputs:\n- `dataOut`: The output data packet.\n\nThe SRAM module should be implemented using a Verilog module with the following parameters:\n- `bits`: The data width of each memory location.\n- `depth`: The number of memory locations in the SRAM.\n\nThe SRAM module should have the following behavior:\n- When `write` is asserted, the data at the specified address should be updated with `dataIn`.\n- When `read` is asserted, the data at the specified address should be output on `dataOut`.\n- If both `read` and `write` are asserted simultaneously, an error should be displayed and the simulation should stop.\n\nYou should implement the SRAM module within 200 lines of Verilog code.\n\n", "output": "module SRAM(\n  input read,\n  input write,\n  input [7:0] dataIn,\n  input [2:0] address,\n  input clk,\n  output [7:0] dataOut\n);\n\n  parameter bits = 8;\n  parameter depth = 8;\n\n  reg [bits-1:0] memArray [depth-1:0];\n  reg [bits-1:0] dataOut;\n\n  always @(posedge clk) begin\n    if (write) begin\n      memArray[address] <= dataIn;\n    end\n    if (read) begin\n      dataOut <= memArray[address];\n    end\n    if (read & write) begin\n      $display(\"ERROR: simultaneous read and write to memory\");\n      $stop;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4x4 matrix keypad scanner. The module should have four output signals (row1-row4) and four input signals (col1-col4). When a key is pressed, the corresponding row and column signals should be output. If no key is pressed, all output signals should be low. The module should be triggered by the positive edge of the clock signal (clk).", "output": "module keypad_scanner (\n    input clk,\n    input [3:0] col,\n    output reg [3:0] row\n);\n\nreg [3:0] row_temp;\n\nalways @(posedge clk) begin\n    row_temp <= 4'b1110;\n    if (col[0] == 1) row_temp <= 4'b1101;\n    if (col[1] == 1) row_temp <= 4'b1011;\n    if (col[2] == 1) row_temp <= 4'b0111;\n    if (col[3] == 1) row_temp <= 4'b1110;\nend\n\nalways @(posedge clk) begin\n    row <= row_temp;\nend\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `sky130_fd_sc_ms__and3` that implements a 3-input AND gate with power and ground inputs. The module also has two pairs of differential inputs and outputs, `VPWR`/`VGND` and `VPB`/`VNB`, respectively. The `X` output is connected to the AND gate's output. \n\nThe module also includes a testbench that initializes the inputs to `1'bX` and then sets them to various values at specific time intervals. The `VPWR`, `VGND`, `VPB`, and `VNB` inputs are not used in the testbench.\n\nYour task is to complete the `sky130_fd_sc_ms__and3` module by implementing the AND gate logic using the 3 inputs `A`, `B`, and `C`. The output `X` should be high only if all three inputs are high. \n\n", "output": "module sky130_fd_sc_ms__and3 (\n    input A,\n    input B,\n    input C,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    // Implement AND gate logic\n    assign X = A & B & C;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock gating module for a register adder circuit. The module should have the following inputs and outputs:\n\n- `CLK`: a clock signal\n- `EN`: an enable signal\n- `TE`: a test enable signal\n- `ENCLK`: an output enable clock signal\n\nThe module should implement a gated D flip-flop, which should be triggered on the rising edge of the clock signal. The flip-flop should be enabled when the `EN` signal is high and the `TE` signal is low. The output of the flip-flop should be connected to the `ENCLK` signal.\n\nWrite a Verilog module that implements the clock gating circuit described above. Your module should be named `register_adder_clock_gate` and should have the inputs and outputs described above.\n\n", "output": "module register_adder_clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  reg gated_clk;\n\n  always @(posedge CLK) begin\n    if (EN && !TE) begin\n      gated_clk <= 1'b1;\n    end else begin\n      gated_clk <= 1'b0;\n    end\n  end\n\n  assign ENCLK = gated_clk & CLK;\n\nendmodule"}
{"instruction": "Create a module that implements an XOR gate with two input ports and one output port. The XOR gate should be designed using combinational logic and should be capable of operating at high speeds. In addition, the module must be designed to minimize power consumption.", "output": "module xor_gate(\n    input a,\n    input b,\n    output reg out\n);\n\nalways @(*) begin\n    out = a ^ b;\nend\n\nendmodule"}
{"instruction": "Develop an XOR gate utilizing a non-clocked always block and assign the output to a wire. The module should have two inputs, a and b, and one output, out_wire.", "output": "module xor_gate(\n    input a,\n    input b,\n    output out_wire\n);\n\n    assign out_wire = a ^ b;\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output out_wire\n);\n\n    xor_gate xor_inst(\n        .a(a),\n        .b(b),\n        .out_wire(out_wire)\n    );\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module for a 4-bit adder with carry-in and carry-out capabilities. The module should have two inputs, A and B, which are 4-bit numbers, and one output, S, which is also a 4-bit number. The module should also have two control inputs, C_in and C_out, which are single-bit signals. If C_in is set to 1, the adder should include a carry-in bit, and if C_out is set to 1, the adder should include a carry-out bit.\n\nThe module should be designed to be synthesizable and should be implemented in no more than 200 lines of verilog code. You may use any standard verilog libraries, but you should not use any non-standard libraries or constructs.\n\nYour module should be named \"four_bit_adder\" and should be defined in a file named \"four_bit_adder.v\". The module should be tested using a separate testbench file named \"four_bit_adder_tb.v\". The testbench should be designed to test the adder with a variety of inputs, including all possible combinations of A and B, as well as different values of C_in and C_out.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input C_in,\n    input C_out,\n    output reg [3:0] S,\n    output reg C\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    assign sum = A + B + C_in;\n    assign carry = (A[3] & B[3]) | (A[3] & C_in) | (B[3] & C_in);\n\n    assign C = C_out ? carry[3] : 0;\n    always @(*) begin\n        if(C_out) begin\n            S = {carry[2:0], sum[3]};\n        end else begin\n            S = sum;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs the logical AND operation on four input bits (A, B, C, and D) and outputs the result to a single output bit (X). The module should be named `my_and4` and should be written in Verilog. \n\nYour module should have the following interface:\n```\nmodule my_and4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg X\n);\n```\n\nYou are required to implement the AND operation using only basic logic gates (AND, OR, NOT). The output bit X should be high (1'b1) only when all the input bits are high, and low (1'b0) otherwise.\n\nYour implementation should not exceed 200 lines of Verilog code. You should also ensure that your code is properly formatted and commented.\n\n", "output": "module my_and4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg X\n);\n\n    wire AB;\n    wire CD;\n    wire ABCD;\n\n    // AND gate for A and B\n    and gate_AB (\n        .a(A),\n        .b(B),\n        .o(AB)\n    );\n\n    // AND gate for C and D\n    and gate_CD (\n        .a(C),\n        .b(D),\n        .o(CD)\n    );\n\n    // AND gate for AB and CD\n    and gate_ABCD (\n        .a(AB),\n        .b(CD),\n        .o(ABCD)\n    );\n\n    // NOT gate for ABCD\n    not gate_X (\n        .a(ABCD),\n        .o(X)\n    );\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a constant voltage driver. \nA constant voltage driver is a type of digital circuit that generates a constant voltage output signal. The input to the circuit is a control signal, and the output is a voltage signal that remains constant regardless of changes in the control signal.\nYour module should have the following inputs and outputs:\n\nInputs: a control signal (ctrl)\nOutputs: a constant voltage signal (vout)\n\nYour module should implement the following functionality:\n\nThe output signal should be a constant voltage signal that remains constant regardless of changes in the control signal.\nThe output signal voltage level should be programmable using a parameter (voltage_level)\nTo implement the constant voltage driver, you should use Verilog code to define the output as a constant voltage signal that depends on the voltage level parameter. \nYou should then use the control signal as an enable signal to enable or disable the output signal.\nFinally, you should add some test benches to verify the functionality of the module.", "output": "module const_voltage_driver (\n  input ctrl,\n  output reg vout\n);\n\nparameter voltage_level = 3.3; // voltage level of the output signal in volts. Can be changed according to requirements.\n\nreg [15:0] voltage_level_int;\n\ninitial begin\n  voltage_level_int = voltage_level * 1000; // Convert voltage level to an integer value (in millivolts)\nend\n\nalways @(*) begin\n  if (ctrl) begin\n    vout = voltage_level_int;\n  end\n  else begin\n    vout = 0;\n  end\nend\n\n\nendmodule"}
{"instruction": "Design a circuit that combines two dual-edge triggered flip-flops, as described in the given prompt, and adds an additional functional module that takes in outputs from both flip-flops to calculate the XOR of the two outputs. The circuit should have one input port for the clock signal, two input ports for the data signals, and two output ports for the output signals of the flip-flops. The functional module should have one input port for each of the outputs of the flip-flops and one output port for the XOR result.", "output": "module top_module (\n    input clk,\n    input d1,\n    input d2,\n    output q1,\n    output q2,\n    output xor_output\n);\n\n    reg q1_reg, q2_reg;\n    wire xor_wire;\n    \n    always @(posedge clk) begin\n        q1_reg <= d1;\n        q2_reg <= d2;\n    end\n    \n    assign q1 = q1_reg;\n    assign q2 = q2_reg;\n    \n    xor_gate xor_inst (\n        .a(q1_reg),\n        .b(q2_reg),\n        .xor_output(xor_wire)\n    );\n    \n    assign xor_output = xor_wire;\n    \nendmodule\n\nmodule xor_gate (\n    input a,\n    input b,\n    output xor_output\n);\n\n    assign xor_output = a ^ b;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that detects when a button is being continuously pressed. The module should have two inputs and one output: \n\n- `clk10hz` (1-bit reg) - a clock signal with a frequency of 10 Hz\n- `pb` (1-bit reg) - a push button input\n- `isKP` (1-bit wire) - a flag output indicating if the button is being continuously pressed\n\nThe `isKP` output should be high when the button is pressed continuously for at least 200ms (20 clock cycles). The output should be low otherwise. \n\nDesign a Verilog module that implements this functionality. \n\n", "output": "module keepPressing(\n    input clk10hz,\n    input pb,\n    output reg isKP\n);\n\nreg [4:0] count;\n\nalways @(posedge clk10hz) begin\n    if (pb) begin\n        count <= count + 1;\n        if (count == 20) begin\n            isKP <= 1;\n        end\n    end else begin\n        count <= 0;\n        isKP <= 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit binary adder. The module should have two 4-bit input ports, A and B, and a 4-bit output port, S, representing the sum of A and B. The module should also have a carry-out output port, C_out, which is high if the addition of A and B results in a carry-out.\n\nThe module should be named \"binary_adder\" and should be implemented in Verilog within 200 lines of code. You may use any standard Verilog libraries.\n\nYour module should be able to handle signed and unsigned binary numbers. If the most significant bit of A or B is high, the numbers should be treated as signed. If the most significant bit is low, the numbers should be treated as unsigned.\n\nYour module should also be able to handle overflow conditions. If the addition of A and B results in a 5-bit number, the carry-out should be high and the least significant bit of S should be dropped. If the addition of A and B results in a 4-bit number, the carry-out should be low and the least significant bit of S should be preserved.\n\n", "output": "module binary_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C_out\n);\n\n    wire [4:0] temp_sum;\n    wire temp_carry;\n\n    assign temp_sum = A + B;\n    assign temp_carry = temp_sum[4];\n\n    assign S = (temp_carry) ? temp_sum[3:0] : temp_sum[2:0];\n    assign C_out = temp_carry;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit counter with a synchronous reset input. The module should have four outputs, Q[3:0], which should count up on each clock cycle. When the reset input is high, the counter should be reset to zero.", "output": "module counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements an 8-bit ripple carry adder/subtractor. The module should have four inputs: A and B, the two 8-bit operands; SUB, a single-bit control input that determines whether the operation is addition or subtraction; and CLK, the clock signal. The module should have two outputs: SUM, the 8-bit result of the addition/subtraction operation; and CARRY_OUT, a single-bit output that indicates whether there was a carry-out from the most significant bit during addition or a borrow-out during subtraction. The addition/subtraction operation should be performed on the rising edge of CLK.", "output": "module ripple_addsub (\n    input [7:0] A,\n    input [7:0] B,\n    input SUB,\n    input CLK,\n    output reg [7:0] SUM,\n    output reg CARRY_OUT\n);\n\n    reg [7:0] temp_sum;\n    reg carry_in;\n\n    always @(posedge CLK) begin\n        if(SUB) begin\n            temp_sum <= A - B - carry_in;\n            CARRY_OUT <= ~((~A[7] & B[7]) | (~B[7] & temp_sum[7]) | (temp_sum[7] & ~A[7]));\n        end else begin\n            temp_sum <= A + B + carry_in;\n            CARRY_OUT <= (temp_sum[8] == 1);\n        end\n        SUM <= temp_sum[7:0];\n        carry_in <= CARRY_OUT;\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a simple binary counter. The counter should have a synchronous reset input, a clock input, and an output that represents the current count value. The counter should increment on each rising edge of the clock input, and reset to zero on the rising edge of the reset input.\n\nDesign a Verilog module that meets the following specifications:\n\n- The module should be named `BinaryCounter`.\n- The module should have the following inputs:\n  - `clk`: a 1-bit clock input\n  - `rst`: a 1-bit synchronous reset input\n- The module should have the following output:\n  - `count`: a 4-bit output representing the current count value\n- The module should use only combinational logic and D flip-flops to implement the counter.\n- The counter should increment on each rising edge of the clock input and reset to zero on the rising edge of the reset input.\n- The counter should count from 0 to 15 (in binary) and then wrap around to 0.\n\nWrite a Verilog module that implements the `BinaryCounter` module as described above.\n\n", "output": "module BinaryCounter(clk, rst, count);\n  input clk, rst;\n  output reg [3:0] count;\n  \n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      count <= 4'b0;\n    end else begin\n      if (count == 4'b1111) begin\n        count <= 4'b0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit Johnson counter. The module should have one input (clk) for the clock signal and one output (Q) for the counter value. The counter should cycle through the sequence 0001, 0011, 0111, 1110, 1100, 1000, and repeat. Hint: Use a shift register and a feedback loop to implement the Johnson counter.", "output": "module johnson_counter (\n    input clk,\n    output reg [3:0] Q\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[2:0], shift_reg[3]};\n    Q <= shift_reg[0] ^ shift_reg[3];\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit shift register with parallel load capability. The shift register should have a synchronous reset input (active high) and a clock input. The parallel load input should be active high and should load the input data into the shift register on the rising edge of the clock signal. The output of the shift register should be available on a 4-bit output bus.", "output": "module shift_reg (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] data_in,\n  output reg [3:0] shift_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      shift_out <= 4'b0;\n    end\n    else if (load) begin\n      shift_out <= data_in;\n    end\n    else begin\n      shift_out <= {shift_out[2:0], shift_out[3]};\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 8-bit inputs, `A` and `B`, and outputs the result of performing a bitwise XOR operation between the two inputs. The module should also include a 1-bit input `enable` which determines whether the operation should be performed or not. If `enable` is 0, the output should be 0 regardless of the values of `A` and `B`.\n\nYou may assume that the inputs `A` and `B` are valid 8-bit binary numbers and that the input `enable` is a valid 1-bit binary number.\n\nWrite a verilog module that meets the above requirements. You may use any necessary wires and registers.\n\n", "output": "module bitwise_xor (\n    input [7:0] A,\n    input [7:0] B,\n    input enable,\n    output reg [7:0] result\n);\n\n    always @ (A, B, enable) begin\n        if (enable) begin\n            result = A ^ B;\n        end\n        else begin\n            result = 8'b0;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a multiplexer (MUX). \nA multiplexer is a digital circuit that selects one of several input signals and forwards the selected input to the output.\nYour module should have the following inputs and outputs:\n\nInputs: a set of n input signals (in1, in2, ..., inn)\nSelect: a selection signal (sel) that determines which input signal is forwarded to the output\nOutputs: a single output signal (out)\n\nYour module should also have the following parameters:\n\nn: the number of input signals\n\nYour module should implement the following functionality:\n\nWhen sel is 0, the output should be equal to in1\nWhen sel is 1, the output should be equal to in2\nWhen sel is 2, the output should be equal to in3\n...\nWhen sel is n-1, the output should be equal to inn\n\nTo implement the MUX, you should use a Verilog code to compare the value of sel with the indices of the input signals. \nYou should then forward the input signal that corresponds to the value of sel to the output signal. \nYour code should be able to handle any value of n and sel, and should output an error message if sel is out of range.", "output": "module mux (\n  input [n-1:0] in,\n  input [log2(n)-1:0] sel,\n  output out\n);\n\nparameter n = 4; // number of input signals\n\n  always @(*) begin\n    case(sel)\n      0: out = in[0];\n      1: out = in[1];\n      2: out = in[2];\n      3: out = in[3];\n      default: begin\n        $display(\"Error: sel is out of range\");\n        out = 0;\n      end\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit ripple carry adder. The module should have three inputs and two outputs. The inputs are two 4-bit binary numbers, A and B, and a carry-in bit, Cin. The outputs are a 4-bit binary number, S, which represents the sum of A and B, and a carry-out bit, Cout, which represents the carry generated by the addition.\n\nThe module should be named \"ripple_adder\" and should be completely self-contained. You may use any Verilog constructs and modules that you deem necessary, but the solution should be contained within a single module that is no more than 200 lines of code.\n\nYour module should be synthesizable and should not contain any logic errors. You may assume that the inputs A and B will always be valid 4-bit binary numbers, and that the carry-in bit Cin will be either 0 or 1.\n\n", "output": "module ripple_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nreg [3:0] S;\nreg Cout;\n\nassign S = A + B + Cin;\n\nalways @(*) begin\n    if (S > 15) begin\n        Cout = 1;\n    end else begin\n        Cout = 0;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit binary counter. The counter should have a synchronous reset input, an enable input, and a clock input. When the enable input is high, the counter should increment on each rising edge of the clock signal. When the reset input is high, the counter should be set to 0. The module should have a 4-bit output that represents the current count value.\n\nDesign a Verilog module that implements the above functionality. The module should be self-contained and should not rely on any external modules. The module should be named \"binary_counter\" and should be no more than 200 lines of code.\n\n", "output": "module binary_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module for a binary counter that can count up to a user-defined maximum value. The counter should have the following inputs and outputs:\n- `clk` (input): the clock signal\n- `reset` (input): a synchronous reset signal\n- `max_count` (input): a parameter that determines the maximum count value\n- `count` (output): the current count value\n- `overflow` (output): a flag that indicates when the counter has reached its maximum value and overflowed\n\nDesign the verilog module to meet the above requirements. \n\n", "output": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [log2(MAX_COUNT):0]count,\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 3-input AND gate with an additional input that acts as an enable signal. The module should be named `and_en` and should have the following inputs and outputs:\n\nInputs:\n- `a`, `b`, `c`: 3-bit binary inputs\n- `en`: 1-bit binary enable signal\n\nOutputs:\n- `y`: 1-bit binary output\n\nThe module should only output the AND of `a`, `b`, and `c` if the `en` signal is high. If `en` is low, the output should be set to 0.\n\nYour module should be implemented within 200 lines of Verilog code and should be self-contained, with all necessary components included.\n\n", "output": "module and_en(\n    input [2:0] a, b, c,\n    input en,\n    output y\n);\n\n    wire [2:0] and_result;\n    assign and_result = a & b & c;\n    \n    assign y = en ? and_result[0] & and_result[1] & and_result[2] : 1'b0;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 16-bit input and outputs the number of 1's in the binary representation of the input. The module should have one input (data_in) and one output (ones_count). The module should use a loop to iterate through each bit of the input and count the number of 1's. The output ones_count should be 4 bits wide.", "output": "module binary_ones_counter (\n    input [15:0] data_in,\n    output reg [3:0] ones_count\n);\n\n    integer i;\n    reg [15:0] temp;\n\n    always @ (data_in) begin\n        temp = data_in;\n        ones_count = 0;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp[0] == 1'b1) begin\n                ones_count = ones_count + 1;\n            end\n            temp = temp >> 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit binary up-counter with asynchronous reset functionality. The module should have four inputs and one output. The inputs are: \n\n- `clk`: a clock input signal\n- `rst`: an asynchronous reset input signal\n- `en`: an enable input signal\n- `load`: a load input signal\n\nThe output is a 4-bit binary signal named `count`.\n\nThe module should operate as follows:\n\n- When `rst` is asserted, the counter should be reset to 0.\n- When `en` is asserted, the counter should count up by 1 on each rising edge of the `clk` signal.\n- When `load` is asserted, the counter should load the value present on the 4-bit input signal `load_val` on the next rising edge of the `clk` signal.\n\nAssume that the counter should be able to count up to the maximum value of 15 (1111 in binary), and then wrap around back to 0.\n\nYour module should be named `up_counter` and should be contained within a single file that is no more than 200 lines of Verilog code.\n\n", "output": "module up_counter(\n    input clk, rst, en, load,\n    input [3:0] load_val,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge rst)\nbegin\n    if (rst)\n        count <= 4'b0;\n    else if (en)\n        count <= count + 4'b1;\n    else if (load)\n        count <= load_val;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that can perform a simple mathematical operation on two input values. The module should take in two 8-bit unsigned integers, `a` and `b`, and output their sum as an 8-bit unsigned integer, `c`. The module should be named `add8`.\n\nIn addition to the basic functionality, the module should also include a control input, `reset`, which when set to 1, will reset the output `c` to 0. The module should also include a control input, `enable`, which when set to 1, will enable the module to perform the addition operation.\n\nYou are only allowed to use one module within 200 lines of Verilog code to complete this task.\n\n", "output": "module add8 (\n  input wire clk,\n  input wire reset,\n  input wire enable,\n  input wire [7:0] a,\n  input wire [7:0] b,\n  output reg [7:0] c\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      c <= 8'b0;\n    end\n    else if (enable) begin\n      c <= a + b;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit signed magnitude to 2's complement converter. The module should have one input (signed_mag) and one output (twos_comp). If the most significant bit of signed_mag is 1, the module should convert the number from signed magnitude to 2's complement form. Otherwise, it should pass the number through unchanged.", "output": "module signed_mag_to_twos_comp (\n    input [3:0] signed_mag,\n    output reg [3:0] twos_comp\n);\n\n    always @(*) begin\n        if (signed_mag[3] == 1) begin\n            twos_comp = ~(signed_mag) + 1;\n        end else begin\n            twos_comp = signed_mag;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a simple binary counter. The counter should be able to count up to a maximum value of 15 (in binary, 1111) before resetting to 0. The counter should have a synchronous reset input that should reset the counter to 0 when asserted. The counter should also have an enable input that should allow the counter to count when asserted. The counter should output the current count value on a 4-bit output port. \n\nDesign the Verilog module for the binary counter, ensuring that it meets the above requirements.\n\n", "output": "module binary_counter(\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if(rst) begin\n      count <= 4'b0000;\n    end\n    else if(en) begin\n      if(count == 4'b1111) begin\n        count <= 4'b0000;\n      end\n      else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a specific logic function. The function takes in a 4-bit input, `din`, and outputs a single bit, `dout`. The module should be named `logic_function` and should have the following ports:\n- `clk`: the clock signal\n- `rst`: the reset signal\n- `din`: a 4-bit input\n- `dout`: a single bit output\n\nThe logic function is defined as follows:\n- `dout` should be 1 if the number of 1's in `din` is even.\n- `dout` should be 0 if the number of 1's in `din` is odd.\n\nYou are only allowed to use combinational logic in your design, and your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module logic_function (\n    input clk,\n    input rst,\n    input [3:0] din,\n    output dout\n);\n\n// XOR the bits of the input together to count the number of 1's\nwire [1:0] xor1 = din[0] ^ din[1];\nwire [1:0] xor2 = din[2] ^ din[3];\nwire [1:0] xor3 = xor1 ^ xor2;\nwire [0:0] xor4 = xor3[0] ^ xor3[1];\n\n// Invert the output to get the desired output\nassign dout = ~xor4;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a speech codec block. \nA speech codec block is a digital circuit that can be used to compress and decompress speech signals for transmission over a communication network. \nThere are several standardized speech codecs, including G.711, G.722, G.726, and G.729. \nFor this task, you should implement one of these codecs in Verilog.\n\nYour module should have the following inputs and outputs:\n\nInputs: a set of n input samples (in1, in2, ..., inn)\nOutputs: a set of m output samples (out1, out2, ..., outm)\nThe module should also have the following parameters:\n\nn: the number of input samples\nm: the number of output samples\nsample_rate: the sampling rate of the input and output signals\ncodec_type: the type of speech codec to be implemented\nYour module should implement the following functionality:\n\nThe circuit should compress the input speech signal using the selected speech codec.\nThe circuit should decompress the compressed speech signal to generate the output speech signal.\nTo implement the speech codec, you should use Verilog code to define the compression and decompression algorithms as specified in the standard. \nYou should then use these algorithms to compress and decompress the input and output speech signals.", "output": "module speech_codec (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 160; // number of input samples (for 20ms frame at 8kHz)\nparameter m = 80; // number of output samples (for 10ms frame at 8kHz)\nparameter sample_rate = 8000; // sampling rate of the input and output signals\nparameter codec_type = \"G.729\"; // type of speech codec to be implemented\n\n// Verilog code to implement the G.729 speech codec\n// ...\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes a 16-bit input and outputs the same 16-bit value. The module should have the following ports:\n- `input_port`: a 16-bit input\n- `output_port`: a 16-bit output\n- `clk`: a clock input\n- `ce`: an active-high clock enable input\n- `clr`: an active-high clear input\n\nYou must implement the following logic:\n- When `ce` is high and `clr` is low, the module should pass the value of `input_port` directly to `output_port`.\n- When `ce` is low, the output should remain constant, holding the previous value of `input_port`.\n- When `clr` is high, the output should be forced to 0.\n\nYou should implement this logic using only one module within 200 lines of verilog code.\n\n", "output": "module pass_through (\n  input [(16 - 1):0] input_port,\n  output reg [(16 - 1):0] output_port,\n  input clk,\n  input ce,\n  input clr\n);\n\n  always @(posedge clk) begin\n    if (ce && !clr) begin\n      output_port <= input_port;\n    end\n  end\n  \n  always @(posedge clk) begin\n    if (!ce) begin\n      output_port <= output_port;\n    end\n  end\n  \n  always @(posedge clk) begin\n    if (clr) begin\n      output_port <= 0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that acts as a 1-bit full adder. The module should have three inputs: A, B, and Cin (carry-in), and two outputs: S (sum) and Cout (carry-out). The module should implement the following truth table:\n\n| A | B | Cin | S | Cout |\n|:-:|:-:|:---:|:-:|:----:|\n| 0 | 0 |  0  | 0 |   0  |\n| 0 | 0 |  1  | 1 |   0  |\n| 0 | 1 |  0  | 1 |   0  |\n| 0 | 1 |  1  | 0 |   1  |\n| 1 | 0 |  0  | 1 |   0  |\n| 1 | 0 |  1  | 0 |   1  |\n| 1 | 1 |  0  | 0 |   1  |\n| 1 | 1 |  1  | 1 |   1  |\n\nWrite a verilog module that implements this truth table.\n\n", "output": "module full_adder(input A, input B, input Cin, output S, output Cout);\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will take in a 4-bit binary input and output the Gray code equivalent of that input. Gray code is a binary code where two consecutive values differ by only one bit. For example, the Gray code equivalent of 0010 (decimal 2) is 0110 (decimal 3). \n\nDesign a verilog module that takes in a 4-bit binary input, converts it to Gray code, and outputs the Gray code equivalent. Your module should be named \"gray_converter\" and have the following inputs and outputs:\n\nInputs:\n- `bin_in`: a 4-bit binary input\n\nOutputs:\n- `gray_out`: a 4-bit Gray code output\n\nAssume that the input is valid (i.e., it will always be a 4-bit binary number).\n\n", "output": "module gray_converter(bin_in, gray_out);\ninput [3:0] bin_in;\noutput [3:0] gray_out;\n\nassign gray_out[3] = bin_in[3];\nassign gray_out[2] = bin_in[3] ^ bin_in[2];\nassign gray_out[1] = bin_in[2] ^ bin_in[1];\nassign gray_out[0] = bin_in[1] ^ bin_in[0];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4:1 multiplexer. The module should have four inputs (A, B, C, D) and two select lines (S0, S1). The output of the module should be the selected input based on the select lines. The truth table for the module is as follows:\n\n| S1 | S0 | Output |\n|----|----|--------|\n| 0  | 0  | A      |\n| 0  | 1  | B      |\n| 1  | 0  | C      |\n| 1  | 1  | D      |\n\nDesign the verilog module for the 4:1 multiplexer.\n\n", "output": "module mux4to1 (\n    output reg Y,\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1\n);\n\n    always @(*) begin\n        case ({S1, S0})\n            2'b00: Y = A;\n            2'b01: Y = B;\n            2'b10: Y = C;\n            2'b11: Y = D;\n        endcase\n    end\n\nendmodule"}
{"instruction": "Build a 4-to-1 multiplexer that selects between four input signals based on the value of two selection signals. If sel1 and sel2 are both 0, output the first input signal. If sel1 is 0 and sel2 is 1, output the second input signal. If sel1 is 1 and sel2 is 0, output the third input signal. If sel1 and sel2 are both 1, output the fourth input signal. Please use a procedural if statement to implement the module.", "output": "module mux_4to1(\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [3:0] in4,\n    input sel1,\n    input sel2,\n    output reg [3:0] out_always\n);\n\nalways @(*) begin\n    if(sel1 == 0 && sel2 == 0) begin\n        out_always = in1;\n    end\n    else if(sel1 == 0 && sel2 == 1) begin\n        out_always = in2;\n    end\n    else if(sel1 == 1 && sel2 == 0) begin\n        out_always = in3;\n    end\n    else begin\n        out_always = in4;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit counter that counts from 0 to 9 and then resets to 0. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a synchronous reset signal\n\nOutputs:\n- `count`: a 4-bit output representing the current count value\n\nYour module should have the following behavior:\n- On the rising edge of the `clk` signal, the counter should increment by 1.\n- If the counter reaches 10, it should reset to 0 on the next clock cycle.\n- If the `rst` signal is asserted, the counter should immediately reset to 0.\n\nWrite the verilog code for this module.\n\n", "output": "module counter(clk, rst, count);\n  input clk, rst;\n  output reg [3:0] count;\n  \n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      count <= 4'b0;\n    end else if (count == 4'b1001) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n  \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a reset synchronizer. \nA reset synchronizer is a digital circuit that is used to synchronize the reset signal in a design. \nWhen an asynchronous reset signal is used in a design, it is important to synchronize it with the clock signal to prevent metastability. \nA reset synchronizer consists of a flip-flop and a chain of two or more delay elements.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- async_reset: the asynchronous reset signal\n- clk: the clock signal\n\nOutputs:\n- sync_reset: the synchronized reset signal\n\nYour module should implement the following functionality:\n\n- The async_reset signal should be synchronized with the clk signal.\n- The synchronized reset signal should be low for a specified number of clock cycles after the async_reset signal goes high.\n- The number of clock cycles for which the sync_reset signal should be low should be configurable.\n\nTo implement the reset synchronizer, you should use Verilog code to define the flip-flop and the delay elements. \nYou should then use these elements to connect the async_reset signal to the flip-flop and to the delay chain. \nFinally, you should use the delay chain to generate the sync_reset signal.", "output": "module reset_synchronizer (\n  input async_reset,\n  input clk,\n  output sync_reset\n);\n\nparameter delay = 3; // number of clock cycles for which sync_reset should be low\n\nreg sync_reset_reg;\nreg [delay-1:0] delay_chain;\n\nalways @(posedge clk) begin\n  delay_chain <= {delay_chain[(delay-2):0], async_reset}; // shift in async_reset signal\n  sync_reset_reg <= ~(|delay_chain); // sync_reset is low when any bit in delay_chain is high\nend\n\nassign sync_reset = sync_reset_reg;\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module for a 2-to-1 multiplexer (MUX) with the following specifications:\n\n- The module should be named \"MUX2to1\".\n- The module should have three inputs: \"a\", \"b\", and \"sel\".\n- The module should have one output: \"out\".\n- When \"sel\" is 0, \"out\" should be equal to \"a\".\n- When \"sel\" is 1, \"out\" should be equal to \"b\".\n\nUse behavioral modeling to implement the MUX2to1 module.\n\n", "output": "module MUX2to1 (a, b, sel, out);\ninput a, b, sel;\noutput out;\n\n   always @ (*)\n   begin\n      if (sel == 0)\n         out = a;\n      else\n         out = b;\n   end\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module for a 4-bit adder that takes two 4-bit inputs (A and B) and produces a 4-bit output (C). The module should have two inputs and one output. The inputs should be named A and B and the output should be named C. The module should also have a reset input named RST. When RST is high, the output should be 0.\n\n", "output": "module adder(\n  input [3:0] A,\n  input [3:0] B,\n  input RST,\n  output [3:0] C\n);\n\n  assign C = RST ? 4'b0000 : A + B;\n\nendmodule"}
{"instruction": "\n\nYou are designing a debounce module for a push button. The module should take in a clock signal, a button input, and output a debounced signal. The debounced signal should only change when the button has been stable for a certain amount of time, ignoring any bouncing that may occur due to the physical properties of the button. \n\nImplement the debounce module using Verilog. The module should have the following inputs and outputs:\n- clk: a clock signal\n- but: a button input\n- debounced: a debounced output signal\n\nWhen the button is first pressed, the debounced signal should change to match the button input. After that, the debounced signal should only change when the button input has been stable for at least 10 clock cycles. If the button input changes before the 10 clock cycles have elapsed, the debounced signal should not change. \n\nAssume that the clock signal has a frequency of 50 MHz. You may assume that the button input is synchronous to the clock signal.\n\n", "output": "module debounce(input clk, but, output reg debounced);\n    reg [9:0] debTimer;\n    always @(posedge clk) begin\n        if (debounced == but) // button is stable\n            debTimer <= 0;\n        else if (debTimer != 10'd9) // button is bouncing\n            debTimer <= debTimer + 1;\n        else if (debTimer == 10'd9) // button has been stable for 10 cycles\n            debounced <= but;\n    end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a touch sensor interface. \nThe touch sensor interface should be either a capacitive or resistive touch sensor.\nThe inputs to the circuit are connected to the touch sensor, and the outputs are connected to a controller that can detect the touch.\nYour module should have the following inputs and outputs:\n\nInputs: a touch sensor signal (touch)\nOutputs: a touch detection signal (touch_detected)\nThe module should also have the following parameter:\n\nt: the threshold voltage of the touch sensor\nYour module should implement the following functionality:\n\nThe circuit should detect when the touch sensor signal exceeds the threshold voltage.\nThe circuit should then output a touch detection signal.\nTo implement the touch sensor interface, you should use Verilog code to define the threshold voltage and compare it with the touch sensor signal.\nIf the touch sensor signal exceeds the threshold voltage, then the touch detection signal should be set to high. Otherwise, it should be set to low.", "output": "module touch_sensor (\n  input touch,\n  output touch_detected\n);\n\nparameter t = 5; // threshold voltage of the touch sensor\n\nassign touch_detected = (touch > t) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4:1 multiplexer (MUX). The module should have four input ports, one output port, and two select lines. The output port should be connected to one of the four input ports based on the values of the select lines. The truth table for the 4:1 MUX is as follows:\n\n| Select Lines | Output |\n|--------------|--------|\n| 0 0          | Input 0|\n| 0 1          | Input 1|\n| 1 0          | Input 2|\n| 1 1          | Input 3|\n\nPlease write the verilog code for the 4:1 MUX module.\n\n", "output": "module mux4_1\n(\n  input [3:0] data_in,\n  input [1:0] select,\n  output reg data_out\n);\n\n  always @(*)\n  begin\n    case (select)\n      2'b00: data_out = data_in[0];\n      2'b01: data_out = data_in[1];\n      2'b10: data_out = data_in[2];\n      2'b11: data_out = data_in[3];\n      default: data_out = 1'b0;\n    endcase\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 16-bit adder/subtractor. The module should have three inputs: a 16-bit minuend, a 16-bit subtrahend, and a control signal that determines whether the operation is addition or subtraction. The module should have one output: a 16-bit result that is the sum or difference of the two inputs based on the control signal.", "output": "module add_sub_16bit (\n    input [15:0] minuend,\n    input [15:0] subtrahend,\n    input control,\n    output [15:0] result\n);\n\n    wire [15:0] twos_complement_subtrahend;\n    assign twos_complement_subtrahend = (~subtrahend) + 1;\n\n    always @(*) begin\n        if (control) begin\n            result = minuend + twos_complement_subtrahend;\n        end else begin\n            result = minuend + subtrahend;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a binary to gray code converter. The module should have the following ports:\n\n- `input wire [7:0] bin`: 8-bit binary input\n- `output wire [7:0] gray`: 8-bit gray code output\n\nThe module should convert the binary input to its corresponding gray code and output it through the `gray` port. The module should be synchronous and operate on the positive edge of the clock signal `clk`.\n\n", "output": "module bin_to_gray(\n    input wire clk,\n    input wire [7:0] bin,\n    output wire [7:0] gray\n);\n\n    always @(posedge clk) begin\n        gray[0] <= bin[0];\n        gray[1] <= bin[0] ^ bin[1];\n        gray[2] <= bin[1] ^ bin[2];\n        gray[3] <= bin[2] ^ bin[3];\n        gray[4] <= bin[3] ^ bin[4];\n        gray[5] <= bin[4] ^ bin[5];\n        gray[6] <= bin[5] ^ bin[6];\n        gray[7] <= bin[6] ^ bin[7];\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that generates three outputs, Z1, Z2, and Z3, based on the inputs a, b, and c. Z1 is generated by taking the logical AND of the inputs a and b. Z2 is generated by taking the logical OR of the inputs a and c. Z3 is generated by taking the logical XOR of the inputs b and c.", "output": "module logic_operations (\n  input a,\n  input b,\n  input c,\n  output reg Z1,\n  output reg Z2,\n  output reg Z3\n);\n\n  always @*\n    begin\n      Z1 = a & b;\n      Z2 = a | c;\n      Z3 = b ^ c;\n    end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit binary input and outputs the decimal equivalent of the binary number. The output should be a 3-bit decimal number. Assume that the input will always be a valid 4-bit binary number.\n\n", "output": "module bin2dec(input [3:0] bin, output reg [2:0] dec);\n\n  always @ (bin) begin\n    case(bin)\n      4'b0000: dec = 3'b000;\n      4'b0001: dec = 3'b001;\n      4'b0010: dec = 3'b010;\n      4'b0011: dec = 3'b011;\n      4'b0100: dec = 3'b100;\n      4'b0101: dec = 3'b101;\n      4'b0110: dec = 3'b110;\n      4'b0111: dec = 3'b111;\n      4'b1000: dec = 3'b000;\n      4'b1001: dec = 3'b001;\n      4'b1010: dec = 3'b010;\n      4'b1011: dec = 3'b011;\n      4'b1100: dec = 3'b100;\n      4'b1101: dec = 3'b101;\n      4'b1110: dec = 3'b110;\n      4'b1111: dec = 3'b111;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a delay circuit with reset functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK_IN`: a clock signal\n- `reset`: a reset signal\n- `enb_1_2000_0`: an enable signal\n- `Reset_1`: a reset signal that is used internally\n- `In`: a signed 32-bit input value\n\nOutputs:\n- `Out`: a signed 32-bit output value\n\nThe module should implement the following functionality:\n\n1. When `reset` is high, the output `Out` should be set to 0.\n2. When `enb_1_2000_0` is high, the input `In` should be passed through to the output `Out`.\n3. When `enb_1_2000_0` is low, the output `Out` should remain constant at the value it had when `enb_1_2000_0` was last high.\n4. When `Reset_1` is high, the output `Out` should be set to 0.\n5. When `Reset_1` is low, the output `Out` should be delayed by one clock cycle before being output.\n\nYour task is to write a Verilog module that implements this functionality.\n\n", "output": "module delay_reset_controller (\n    input CLK_IN,\n    input reset,\n    input enb_1_2000_0,\n    input Reset_1,\n    input signed [31:0] In,\n    output reg signed [31:0] Out\n);\n\n    reg signed [31:0] In_Delay_out1;  // sfix32_En27\n\n    always @(posedge CLK_IN) begin\n        if (reset) begin\n            Out <= 0;\n        end else if (enb_1_2000_0) begin\n            Out <= In;\n        end\n    end\n\n    always @(posedge CLK_IN) begin\n        if (Reset_1) begin\n            Out <= 0;\n        end else begin\n            In_Delay_out1 <= Out;\n            Out <= In_Delay_out1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog coder. Create a system that detects a high-to-low transition in an 8-bit input signal, and uses it to trigger a pulse generator. The pulse generator should generate a pulse of a specified duration, which is then used to control a 4-bit counter. The counter should increment on each rising edge of the pulse, and reset to 0 when it reaches its maximum value. The final output of the system should be the 4-bit value of the counter, and should be updated on each rising edge of the pulse.", "output": "module top_module (\n    input clk,\n    input [7:0] in,\n    output [3:0] q\n);\n\n    reg [7:0] prev_in;\n    reg edge_detect;\n    reg pulse;\n    reg [3:0] counter;\n\n    always @(posedge clk) begin\n        prev_in <= in;\n        edge_detect <= (prev_in[0] == 1) && (in[0] == 0);\n        pulse <= (edge_detect == 1) ? 1 : 0;\n        if (pulse == 1) begin\n            if (counter == 15) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign q = counter;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a modulo operator. \nThe modulo operator is a mathematical operator that calculates the remainder of a division between two numbers. \nFor example, the expression \"5 mod 2\" would evaluate to 1, because 5 divided by 2 leaves a remainder of 1.\n\nYour module should have the following inputs and outputs:\n\nInputs: a 16-bit dividend signal (dividend) and a 4-bit divisor signal (divisor).\nOutputs: a 4-bit remainder signal (remainder).\n\nYour module should implement the following functionality:\n\nThe circuit should divide the dividend by the divisor and calculate the remainder.\nThe remainder should be output as a 4-bit signal.\nIf the divisor is zero, the remainder should be set to zero.\nIf the dividend is negative, the remainder should be negative.\n\nTo implement the modulo operator, you should use Verilog code to define the division and remainder operations as mathematical functions of the input signals. \nYou should then use these functions to compute the remainder and output it as a 4-bit signal.\nNote that the division and remainder operations can be implemented using a series of bit-wise operations, such as shifting and subtracting, which are available in Verilog.", "output": "module modulo_operator (\n  input [15:0] dividend,\n  input [3:0] divisor,\n  output [3:0] remainder\n);\n\n  reg [15:0] dividend_reg;\n  reg [3:0] divisor_reg;\n  reg [3:0] remainder_reg;\n  \n  always @(*) begin\n    dividend_reg = dividend;\n    divisor_reg = divisor;\n    \n    if (divisor_reg == 0) begin\n      remainder_reg = 0;\n    end else begin\n      if (dividend_reg < 0) begin\n        remainder_reg = -((-dividend_reg) % divisor_reg);\n      end else begin\n        remainder_reg = dividend_reg % divisor_reg;\n      end\n    end\n  end\n  \n  assign remainder = remainder_reg;\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `contadorprueba` which is a digital counter that counts up to a given `cantidad` and displays the result on a 7-segment display. The counter can be enabled or disabled using the `ENABLE` input signal. The counter can be reset using the `reset` input signal. The counter increments on the rising edge of the clock signal `clk`. The input signal `entrada` is used to manually increment the counter. The output signals `an` and `seg` are used to display the count on a 7-segment display. The output signal `pulse` is high for one clock cycle each time the counter reaches the maximum count value. The module includes the following submodules:\n\n- `cantidadecho`: This submodule generates an echo pulse on the `ECHO` output signal each time the input signal `entrada` is high. The `CLKOUT` output signal is used to synchronize the echo pulse with the clock signal `clk`.\n- `contador`: This submodule implements the counter logic. The `count` output signal is the current count value. The `calculate` output signal is high when the counter is at the maximum count value and needs to be reset. The `ECHO` input signal is used to synchronize the counter with the echo pulse generated by the `cantidadecho` submodule.\n- `divisorfrec`: This submodule generates a clock signal `CLKOUT` with a frequency that is half the frequency of the input signal `clk`.\n- `anteconmutador`: This submodule converts the current count value from the `count` output signal of the `contador` submodule into separate signals for the hundreds, tens, and units digits.\n- `conmutacion`: This submodule selects which digit to display on the 7-segment display based on the current value of the `mostrar` input signal and the digit values from the `anteconmutador` submodule. The `CLKOUTseg` output signal is used to synchronize the display with the clock signal `clk`.\n- `display`: This submodule converts the digit values from the `conmutacion` submodule into signals for the 7-segment display. The `an` output signal selects which digit to display and the `seg` output signal provides the segment values for the selected digit.\n- `divisorfrecdisp`: This submodule generates a clock signal `CLKOUTseg` with a frequency that is half the frequency of the input signal `clk`.\n\nYour task is to implement the `cantidadecho` submodule. The `cantidadecho` submodule should generate an echo pulse on the `ECHO` output signal each time the input signal `entrada` is high. The `CLKOUT` output signal should be used to synchronize the echo pulse with the clock signal `clk`. The echo pulse should have a duration of 10 clock cycles.\n\n", "output": "module cantidadecho (\n    input [7:0] cantidad,\n    input entrada,\n    input CLKOUT,\n    input reset,\n    output reg ECHO\n);\n\nreg [3:0] count;\nreg [3:0] delay;\n\nalways @(posedge CLKOUT, posedge reset) begin\n    if (reset) begin\n        count <= 0;\n        delay <= 0;\n        ECHO <= 0;\n    end else begin\n        if (entrada) begin\n            count <= count + 1;\n            delay <= 10;\n            ECHO <= 1;\n        end else if (delay > 0) begin\n            delay <= delay - 1;\n            ECHO <= 1;\n        end else begin\n            ECHO <= 0;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in three input signals, A1, A2, and B1_N, and outputs a single signal, Y. The module should have the following functionality:\n\n- The output signal, Y, should be the result of a series of logic gates that take in the three input signals.\n- The input signals, A1 and A2, should be OR'ed together.\n- The input signal, B1_N, should be inverted.\n- The inverted signal, B1_N, should be NAND'ed with the OR'ed signal from A1 and A2.\n- The final result of the NAND operation should be the output signal, Y.\n\nYou are required to implement the module using only one module within 200 lines of Verilog code. Your module should have the following ports:\n\n- Y: output signal\n- A1: input signal\n- A2: input signal\n- B1_N: input signal\n\nYour module should also have the following supplies:\n\n- VPWR: supply1\n- VGND: supply0\n- VPB: supply1\n- VNB: supply0\n\n", "output": "module verilog_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire b          ;\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    //   Name   Output       Other arguments\n    not  not0  (b          , B1_N           );\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, b, or0_out     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule"}
{"instruction": "Please act as professional verilog designer. Here is a Karnaugh map for a 4-bit input function F(A,B,C,D).\n\nAB\\ CD | 00 | 01 | 11 | 10 |\n   -------|----|----|----|----|\n    00 |  0 |  1 |  0 |  1 |\n    01 |  1 |  0 |  1 |  0 |\n    11 |  1 |  0 |  1 |  0 |\n    10 |  0 |  1 |  0 |  1 |\nImplement this function using a Verilog module called \"karnaugh_map\". Declare the module inputs and outputs as follows:", "output": "module karnaugh_map(\n  input wire A, B, C, D, // 4-bit input variables\n  output reg F // 1-bit output variable\n);\n\n  always @(*) begin\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b0;\n      4'b0011: F = 1'b1;\n      4'b0110: F = 1'b1;\n      4'b0111: F = 1'b0;\n      4'b1110: F = 1'b1;\n      4'b1111: F = 1'b0;\n      default: F = 1'b0;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a register file module in Verilog. The register file should have 32 registers, each 32 bits wide. The module should have the following inputs and outputs:\n\nInputs:\n- clk: a clock signal\n- regWrite: a control signal that enables writing to the register file\n- readReg1: a 5-bit input specifying the register number to read from\n- readReg2: a 5-bit input specifying the register number to read from\n- writeReg: a 5-bit input specifying the register number to write to\n- writeData: a 32-bit input specifying the data to write to the register\n\nOutputs:\n- readData1: a 32-bit output that contains the data read from the register specified by readReg1\n- readData2: a 32-bit output that contains the data read from the register specified by readReg2\n\nThe register file should be initialized to all zeros when the circuit is powered on.\n\nYour task is to implement the register file module in Verilog. You should ensure that the register file is updated only when the regWrite control signal is enabled. You should also ensure that the register file is initialized to all zeros when the circuit is powered on.\n\n", "output": "module reg_file(\n    input clk,\n    input regWrite,\n    input [4:0] readReg1,\n    input [4:0] readReg2,\n    input [4:0] writeReg,\n    input [31:0] writeData,\n    output reg [31:0] readData1, \n    output reg [31:0] readData2\n    );\n\nreg [31:0] regFile [31:0];\n\ninteger i;\ninitial begin\n    for (i=0; i<32; i=i+1) begin\n        regFile[i] <=0;\n    end\nend\n\nalways@(readReg1 or readReg2 or regFile)\nbegin\n    readData1 <= regFile[readReg1];\n    readData2 <= regFile[readReg2];\nend\n\nalways@(posedge clk) \nbegin\n    if(regWrite)\n        regFile[writeReg] <= writeData;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that takes in a 4-bit binary number and outputs its two's complement representation using a single NOT gate. The input and output ports should be named in and out, respectively.", "output": "module twos_complement(\n  input [3:0] in,\n  output [3:0] out\n);\n\n  assign out = ~in + 1;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a 2:1 multiplexer using Verilog. The module should have two input ports, `in0` and `in1`, and one select port, `sel`. When `sel` is 0, the output of the module should be equal to `in0`. When `sel` is 1, the output should be equal to `in1`. \n\nYour implementation should be within 200 lines of Verilog code and should be well-structured, making use of appropriate modules and submodules wherever necessary. Your module should be named `mux_2to1` and should be testable in a Verilog simulation environment.\n\n", "output": "module mux_2to1 (output reg out, input in0, in1, sel);\n    always @ (sel) begin\n        if (sel == 0) begin\n            out <= in0;\n        end\n        else begin\n            out <= in1;\n        end\n    end\nendmodule"}
{"instruction": "\nYou are tasked to design a verilog module for a 4:1 multiplexer with enable. The module should have 4 input ports, 1 output port, and an enable signal. The output should be equal to the input that is selected by the 2-bit select signal. If the enable signal is low, the output should be zero. Please use the following module template as a starting point:\n\n```\nmodule mux4(enable, select, in0, in1, in2, in3, out);\n    input enable;\n    input [1:0] select;\n    input in0, in1, in2, in3;\n    output out;\n    \n    // Your code here\n    \nendmodule\n```\n\n", "output": "module mux4(enable, select, in0, in1, in2, in3, out);\n    input enable;\n    input [1:0] select;\n    input in0, in1, in2, in3;\n    output out;\n    \n    wire [3:0] mux_out;\n    \n    assign mux_out[0] = (enable) ? in0 : 1'b0;\n    assign mux_out[1] = (enable) ? in1 : 1'b0;\n    assign mux_out[2] = (enable) ? in2 : 1'b0;\n    assign mux_out[3] = (enable) ? in3 : 1'b0;\n    \n    assign out = mux_out[select];\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary up-counter. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock input\n- `rst`: a synchronous reset input\n\nOutputs:\n- `count`: a 4-bit output representing the current count value\n\nThe counter should increment on every rising edge of the clock input, unless the reset input is asserted, in which case the count should be reset to 0.\n\nDesign the verilog module that implements the 4-bit binary up-counter according to the above specifications.\n\n", "output": "module binary_up_counter(clk, rst, count);\n   input clk, rst;\n   output reg [3:0] count;\n   \n   always @(posedge clk)\n     begin\n       if(rst == 1)\n         count <= 0;\n       else\n         count <= count + 1;\n     end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two 8-bit inputs, `a` and `b`, and outputs the maximum value between them. If `a` is greater than or equal to `b`, the output should be `a`. Otherwise, the output should be `b`. \n\nDesign a module that can perform this operation in Verilog. Your module should be self-contained and should not require any external modules or functions. Your module should be no more than 200 lines of Verilog code.\n\n", "output": "module max_byte(\n   input [7:0] a,\n   input [7:0] b,\n   output reg [7:0] max_val\n);\n\nalways @(*) begin\n   max_val = (a >= b) ? a : b;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to design a Verilog module that implements a clock gating cell. \nA clock gating cell is a circuit that is used to control the flow of clock signals to a particular section of a digital circuit in order to reduce power consumption. \nYour module should have the following inputs and outputs:\n\nInputs: \n- clock: the input clock signal\n- enable: the enable signal that controls the clock gating cell\nOutputs: \n- gated_clock: the output clock signal after gating\n\nYour module should implement the following functionality:\n- When the enable signal is high, the output clock signal should be the same as the input clock signal.\n- When the enable signal is low, the output clock signal should be held at a logical 0 value.\n\nTo implement the clock gating cell, you should use Verilog code to design a circuit that controls the flow of the clock signal based on the value of the enable signal. \nYou should then use this circuit to create the output clock signal that is either the same as the input clock signal or held at a logical 0 value.\nYou should also make sure that the module takes into account any potential clock skew or delay that may occur due to the clock gating.", "output": "module ClockGatingCell (\n  input clock,\n  input enable,\n  output gated_clock\n);\n\n  reg gated_clock;\n\n  always @ (posedge clock) begin\n    if (enable) begin\n      gated_clock <= clock;\n    end else begin\n      gated_clock <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in various inputs and outputs. The module should have the following ports:\n\n- `clk`: input clock\n- `reset`: asynchronous reset signal\n- `in_data`: input data of 32 bits\n- `in_valid`: input valid signal\n- `out_data`: output data of 32 bits\n- `out_valid`: output valid signal\n\nThe module should perform the following operations:\n\n- When `in_valid` is high, the module should store the `in_data` value and set `out_valid` high.\n- When `out_valid` is high, the module should output the stored `in_data` value and set `out_valid` low.\n- If `reset` is high, the module should reset the stored `in_data` value and set `out_valid` low.\n\nWrite a Verilog module that implements the above requirements.\n\n", "output": "module data_storage(\n    input clk,\n    input reset,\n    input [31:0] in_data,\n    input in_valid,\n    output reg [31:0] out_data,\n    output reg out_valid\n);\n\nreg [31:0] stored_data;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        stored_data <= 0;\n        out_valid <= 0;\n    end else if (in_valid) begin\n        stored_data <= in_data;\n        out_valid <= 1;\n    end else if (out_valid) begin\n        out_valid <= 0;\n    end\nend\n\nassign out_data = stored_data;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit counter with asynchronous reset and enable input. The module should count on the positive edge of the clock signal and reset to zero when the asynchronous reset input is high. The enable input should allow the counter to count when high and hold the current count when low.", "output": "module counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0;\n    end else if (enable) begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been hired to design a verilog module for a digital clock gate. The module should have four inputs: a clock signal `CLK`, an enable signal `EN`, a test enable signal `TE`, and an output enable clock signal `ENCLK`. The module should be named `my_clock_gate`.\n\nThe module should implement a gated clock, where the output clock signal `ENCLK` is enabled only when the input clock signal `CLK` is high and the enable signal `EN` is also high. Additionally, the clock gate should be sensitive to the test enable signal `TE`, which should be used to test the module.\n\nThe module should use a flip-flop to store the enable signal `EN`. The flip-flop should be sensitive to the clock signal `CLK` and the test enable signal `TE`. The output of the flip-flop should be connected to a buffer, which should generate the output enable clock signal `ENCLK`.\n\nYou should write the verilog code for the `my_clock_gate` module that implements the above requirements. \n\n", "output": "module my_clock_gate (\n    input CLK,\n    input EN,\n    input TE,\n    output ENCLK\n);\n\n    wire n2;\n    reg EN_reg;\n    \n    always @ (posedge CLK, posedge TE) begin\n        if (TE) begin\n            EN_reg <= 1'b0;\n        end else begin\n            EN_reg <= EN;\n        end\n    end\n    \n    assign n2 = EN_reg & CLK;\n    assign ENCLK = n2;\n    \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a memory arbiter block. A memory arbiter block is a type of digital circuit that is used to control access to a shared memory resource. The inputs to the circuit are requests from multiple sources for access to the memory, and the output is a grant signal that indicates which request has been granted access to the memory.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- a set of n request signals (REQ1, REQ2, ..., REQn)\n- a clock signal (CLK)\n- a reset signal (RST)\n\nOutputs: \n- a grant signal (GRANT)\n\nThe module should also have the following parameters:\n- n: the number of request signals\n\nYour module should implement the following functionality:\n- The circuit should grant access to the memory to only one request at a time.\n- The circuit should prioritize requests based on their order of arrival and ensure that no request is granted access to the memory twice in a row.\n- The circuit should implement a round-robin scheduling algorithm to ensure that requests are granted access in a fair and equitable manner.\n\nTo implement the memory arbiter block, you should use Verilog code to define the priority and scheduling algorithms based on the inputs and parameters. You should then use this code to connect the inputs to the output to generate the grant signal.", "output": "module memory_arbiter (\n  input [n-1:0] REQ,\n  input CLK,\n  input RST,\n  output GRANT\n);\n\nparameter n = 4; // number of request signals\n\nreg [n-1:0] req_priority;\nreg [n-1:0] req_grant;\n\nalways @ (posedge CLK) begin\n  if (RST) begin\n    req_priority <= 0;\n    req_grant <= 0;\n  end else begin\n    // Determine highest priority request\n    req_priority <= {req_priority[n-2:0], req_priority[n-1]};\n    if (REQ != 0) begin\n      req_priority[0] <= REQ & ~req_grant;\n    end\n    // Grant access to highest priority request\n    req_grant <= req_priority[0];\n  end\nend\n\nassign GRANT = req_grant;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that will take in a 4-bit input and output the input value shifted left by 1 bit. You should name your module `SHIFTLEFT4`.\n\nYour module should have the following ports:\n- `input [3:0] A`\n- `output [3:0] Z`\n\nYou should use behavioral modeling to implement the module.\n\n", "output": "module SHIFTLEFT4 (A, Z);\ninput [3:0] A;\noutput [3:0] Z;\n\ninteger i;\n\nalways @(*) begin\n    Z[0] = A[1];\n    Z[1] = A[2];\n    Z[2] = A[3];\n    Z[3] = 0;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a reset synchronizer. \nA reset synchronizer is a common technique used in digital circuits to synchronize an asynchronous reset signal with the clock domain of the circuit. \nWithout a reset synchronizer, an asynchronous reset signal could cause unpredictable behavior in the circuit and potentially damage the hardware.\nYour module should have the following inputs and outputs:\n\nInputs: an asynchronous reset signal (rst_n) and a clock signal (clk)\nOutputs: a synchronized reset signal (rst)\n\nYour module should implement the following functionality:\n\nThe circuit should detect the falling edge of the asynchronous reset signal (rst_n).\nThe circuit should synchronize the reset signal (rst) with the clock domain of the circuit.\nThe circuit should hold the synchronized reset signal (rst) low for a specified number of clock cycles (i.e., the reset period).\nThe circuit should release the synchronized reset signal (rst) high after the reset period has elapsed.\n\nTo implement the reset synchronizer, you should use Verilog code to detect the falling edge of the asynchronous reset signal and synchronize it with the clock domain of the circuit using a flip-flop. \nYou should then use a counter to hold the synchronized reset signal low for the specified number of clock cycles (reset period). \nFinally, you should release the synchronized reset signal high after the reset period has elapsed.", "output": "module reset_synchronizer (\n  input rst_n,\n  input clk,\n  output reg rst\n);\n\nparameter reset_period = 10; // reset period in clock cycles\n\nreg rst_sync;\nreg [3:0] rst_counter;\n\nalways @(posedge clk) begin\n  if (rst_n == 1'b0) begin\n    rst_sync <= 1'b0;\n    rst_counter <= 4'b0000;\n  end else begin\n    rst_sync <= rst_n;\n    if (rst_counter < reset_period) begin\n      rst_counter <= rst_counter + 1;\n    end\n  end\nend\n\nassign rst = rst_sync & (rst_counter < reset_period);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in three inputs - `a`, `b`, and `rsb` - and outputs a single value, `y`. The module should be named `and_or_not` and should be implemented using Verilog.\n\nThe `and_or_not` module should behave as follows:\n- If `rsb` is 0, then `y` should always be 1.\n- If both `a` and `b` are 1, then `y` should be 1.\n- If both `a` and `b` are 0, then `y` should be 0.\n- In all other cases, `y` should be undefined.\n\nYou should implement the `and_or_not` module using only one module within 200 lines of Verilog code. Your implementation should be as efficient as possible, and should not use any unnecessary logic.\n\nYou may assume that the inputs `a`, `b`, and `rsb` will always be either 0 or 1.\n\n", "output": "module and_or_not(y, a, b, rsb);\n    output y;\n    input a, b, rsb;\n    \n    reg yi;\n    \n    always @(a or b or rsb) begin\n        if (rsb == 0) begin\n            yi <= 1;\n        end\n        else if (a & b) begin\n            yi <= 1;\n        end\n        else if (a == 0 & b == 0) begin\n            yi <= 0;\n        end\n        else begin\n            yi <= x;\n        end\n    end\n    \n    assign #1 y = yi;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four inputs (A1, A2, B1, and C1) and produces one output (X) as shown in the code snippet above. The module consists of a series of logic gates (an OR gate, an AND gate, and a buffer) that are interconnected to produce the desired output.\n\nYour task is to implement the module in Verilog, ensuring that the output X is correctly generated based on the input values. You should also ensure that the module can be simulated in a testbench and that the output waveform matches the expected output.\n\nWrite a Verilog module that takes in four inputs (A1, A2, B1, and C1) and produces one output (X) as shown in the code snippet above. Your module should be named \"sky130_fd_sc_hdll__o211a\" and should be implemented using the logic gates shown in the code snippet. Ensure that the module can be simulated in a testbench and that the output waveform matches the expected output.\n\n", "output": "module sky130_fd_sc_hdll__o211a (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    // Local signals\n    wire or0_out   ;\n    wire and0_out_X;\n\n    //  Name  Output      Other arguments\n    or  or0  (or0_out   , A2, A1         );\n    and and0 (and0_out_X, or0_out, B1, C1);\n    buf buf0 (X         , and0_out_X     );\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in two 4-bit binary numbers and outputs their sum in binary. The module should have two inputs, a and b, and one output, sum. If the sum requires more than 4 bits to represent, the module should truncate the result to the lowest 4 bits.", "output": "module binary_adder (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n\nalways @(*) begin\n    sum = a + b;\n    if (sum > 15) begin\n        sum = sum & 4'b1111;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements hyperbolic functions, specifically sineh, cosh, and tanh. \nHyperbolic functions are used in mathematics and engineering to model a variety of phenomena, including the behavior of electromagnetic waves and the deformation of materials under stress.\n\nYour module should have the following inputs and outputs:\n\nInputs: a single input signal x, which represents the value of the hyperbolic function to be computed.\nOutputs: three output signals, which represent the values of the sineh, cosh, and tanh functions of x, respectively.\n\nTo implement the hyperbolic functions, you should use Verilog code to define the mathematical equations for each function. \nFor example, the formula for calculating the sineh function of x is:\n\nsineh(x) = (e^x - e^-x) / 2\n\nYou should use this formula to compute the sineh function of the input signal x. \nSimilarly, you should use the following formulas to compute the cosh and tanh functions of x:\n\ncosh(x) = (e^x + e^-x) / 2\ntanh(x) = (e^x - e^-x) / (e^x + e^-x)\n\nIn your Verilog module, you should use the built-in Verilog function $exp() to compute the value of e^x, where e is the mathematical constant approximately equal to 2.718.", "output": "module Hyperbolic_Functions (\n  input x,\n  output sineh,\n  output cosh,\n  output tanh\n);\n\n  reg signed [31:0] exp_x;\n  reg signed [31:0] exp_neg_x;\n  reg signed [31:0] e_to_x;\n  reg signed [31:0] e_to_neg_x;\n\n  assign sineh = (e_to_x - e_to_neg_x) >> 1;\n  assign cosh = (e_to_x + e_to_neg_x) >> 1;\n  assign tanh = (e_to_x - e_to_neg_x) / (e_to_x + e_to_neg_x);\n\n  always @(*) begin\n    exp_x = $exp(x);\n    exp_neg_x = $exp(-x);\n    e_to_x = exp_x;\n    e_to_neg_x = exp_neg_x;\n  end\n\nendmodule"}
{"instruction": "\n\nCreate a verilog module for a 2-to-1 multiplexer with the following interface:\n\nInputs:\n- `sel`: a single bit input used to select between the two inputs\n- `in0`: a 1-bit input to be selected when `sel` is 0\n- `in1`: a 1-bit input to be selected when `sel` is 1\n\nOutputs:\n- `out`: a 1-bit output that is equal to `in0` when `sel` is 0, and equal to `in1` when `sel` is 1\n\nImplement the module using the `assign` statement.\n\n", "output": "module mux_2_to_1 (\n    input sel,\n    input in0,\n    input in1,\n    output out\n);\n\n    assign out = sel ? in1 : in0;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a 4-bit binary input and outputs its 2's complement representation. The module should be named \"twos_comp\" and should have the following ports:\n\n- `in`: a 4-bit binary input\n- `out`: a 4-bit 2's complement output\n\nThe module should implement the following logic:\n\n- If the input is positive (i.e. its MSB is 0), the output should be the same as the input.\n- If the input is negative (i.e. its MSB is 1), the output should be the 2's complement representation of the input.\n\nFor example, if the input is `1101`, the output should be `0011`.\n\n", "output": "module twos_comp(\n    input [3:0] in,\n    output [3:0] out\n);\n\nwire [3:0] neg_in;\nassign neg_in = ~in + 1;\n\nassign out = (in[3] == 0) ? in : neg_in;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a simple 8-bit multiplier. The module should take in two 8-bit inputs, A and B, and output their product, P.\n\nThe module should have the following inputs and outputs:\n\n- Inputs: \n  - A (8-bit)\n  - B (8-bit)\n- Outputs: \n  - P (16-bit)\n\nThe module should use the following logic:\n\n- The module should have a for loop that iterates through each bit of the input A.\n- For each bit of A, the module should check if it is a 1 or a 0.\n- If the bit of A is a 1, the module should add B to the current value of P.\n- After iterating through all bits of A, the module should output P.\n\nWrite the Verilog code for this module.\n\n", "output": "module multiplier(\n    input [7:0] A,\n    input [7:0] B,\n    output [15:0] P\n);\n\nreg [15:0] temp;\n\nalways @(A, B)\nbegin\n    temp = 0;\n    for (i = 0; i < 8; i = i + 1)\n    begin\n        if (A[i] == 1)\n        begin\n            temp = temp + (B << i);\n        end\n    end\n    P = temp;\nend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that takes in a 4-bit input and outputs a 2-bit output. The output should be the sum of the input and a constant value, where the constant value is represented as a 2-bit binary number. If the sum exceeds 3, the output should be set to 3. The module should be named \"adder_4_2\".\n\nYou are only allowed to use one module within 200 lines of Verilog code. Additionally, the module should have the following ports:\n- input [3:0] A\n- output [1:0] Y\n\nThe module should be synthesizable and should have a single clock input. Assume that the input A will only take on values between 0 and 3.\n\n", "output": "module adder_4_2 (\n    input [3:0] A,\n    output [1:0] Y\n);\n\n    wire [2:0] sum;\n    wire [1:0] constant = 2'b10;\n\n    assign sum = A + constant;\n    assign Y = (sum > 3) ? 2'b11 : sum[1:0];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2-to-1 multiplexer using a conditional operator. The module should have two inputs (A and B), a select input (S), and an output (Y). If S is 0, Y should be equal to A. If S is 1, Y should be equal to B. Use an assign statement to implement the module.", "output": "module mux_2_to_1 (\n    input A,\n    input B,\n    input S,\n    output reg Y\n);\n\n    assign Y = (S == 0) ? A : B;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a circuit to detect and count the number of consecutive 1's in a 4-bit input signal. The circuit should have a reset input signal that resets the counter to 0. The output signal should be a 3-bit register that indicates the number of consecutive 1's detected. If the input signal contains more than 3 consecutive 1's, the output signal should be set to 3.", "output": "module consecutive_ones_counter (\n  input clk,\n  input reset,\n  input [3:0] data,\n  output reg [2:0] count\n);\n\nreg [2:0] count_reg;\nreg [2:0] count_next;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count_reg <= 0;\n  end else begin\n    count_reg <= count_next;\n  end\nend\n\nalways @(*) begin\n  count_next = 0;\n  if (data[0] == 1) begin\n    count_next = 1;\n    if (data[1] == 1) begin\n      count_next = 2;\n      if (data[2] == 1) begin\n        count_next = 3;\n      end\n    end\n  end\nend\n\nassign count = count_reg;\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that implements a binary counter. The module should have two inputs, a clock signal (CLK) and a reset signal (RST), and one output, a 4-bit binary value (Q) that represents the current count. The counter should increment on every rising edge of the CLK signal, and reset to 0000 on every rising edge of the RST signal. \n\nDesign a module that meets these specifications. The module should be self-contained and should not rely on any other modules. \n\n", "output": "module binary_counter (\n  input CLK, RST,\n  output [3:0] Q\n);\n\n  reg [3:0] count;\n\n  always @(posedge CLK) begin\n    if (RST) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n  assign Q = count;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit binary input and outputs the binary equivalent of its two's complement representation. The module should have the following ports:\n\n- `input [3:0] A`: the 4-bit input\n- `output [3:0] Y`: the 4-bit two's complement output\n\nThe two's complement representation of a binary number is obtained by inverting all the bits and adding 1 to the result. For example, the two's complement of 0101 is 1011.\n\nYour module should be self-contained and should not rely on any other modules. You may use any logic gates and operators that are available in Verilog. Your module should be synthesizable and should not use any non-synthesizable constructs.\n\nWrite a Verilog module that implements this functionality.\n\n", "output": "module twos_complement (\n    input [3:0] A,\n    output [3:0] Y\n);\n\n    assign Y = ~A + 1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit synchronous counter. The counter should have a synchronous reset input, an enable input, and an output that displays the current count value. The counter should increment on the rising edge of the clock signal only when the enable input is high. If the reset input is high, the counter should reset to 0. The counter should be designed using Verilog.\n\nDesign a Verilog module that implements the 4-bit synchronous counter described above. The module should have the following inputs and outputs:\n\n- `clk`: a clock input\n- `rst`: a synchronous reset input\n- `en`: an enable input\n- `count_out`: a 4-bit output that displays the current count value\n\nAssume that `clk` has a frequency of 50 MHz.\n\n", "output": "module counter(clk, rst, en, count_out);\n\ninput clk, rst, en;\noutput reg [3:0] count_out;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    count_out <= 4'b0000;\n  end\n  else if (en) begin\n    count_out <= count_out + 1;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in three input signals (atm_valid, dtm_valid, itm_valid) and produces a 2-bit output signal (compute_tm_count) based on the following truth table:\n\n| atm_valid | dtm_valid | itm_valid | compute_tm_count |\n|-----------|-----------|-----------|------------------|\n|     0     |     0     |     0     |         0        |\n|     0     |     0     |     1     |         1        |\n|     0     |     1     |     0     |         1        |\n|     0     |     1     |     1     |         2        |\n|     1     |     0     |     0     |         1        |\n|     1     |     0     |     1     |         2        |\n|     1     |     1     |     0     |         2        |\n|     1     |     1     |     1     |         3        |\n\nYour module should be named \"compute_tm_count\" and should have the following inputs and outputs:\n\nInputs:\n- atm_valid (1-bit)\n- dtm_valid (1-bit)\n- itm_valid (1-bit)\n\nOutputs:\n- compute_tm_count (2-bit)\n\nYour module should use a case statement to determine the value of compute_tm_count based on the input signals.\n\nWrite a Verilog module that solves the problem described above. Your solution should be contained within 200 lines of code.\n\n", "output": "module compute_tm_count (\n  input atm_valid,\n  input dtm_valid,\n  input itm_valid,\n  output reg [1:0] compute_tm_count\n);\n\n  always @(*) begin\n    case ({itm_valid, atm_valid, dtm_valid})\n      3'b000: compute_tm_count = 2'b00;\n      3'b001: compute_tm_count = 2'b01;\n      3'b010: compute_tm_count = 2'b01;\n      3'b011: compute_tm_count = 2'b10;\n      3'b100: compute_tm_count = 2'b01;\n      3'b101: compute_tm_count = 2'b10;\n      3'b110: compute_tm_count = 2'b10;\n      3'b111: compute_tm_count = 2'b11;\n    endcase\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder with carry-in and carry-out signals. The adder should take two 4-bit inputs (A and B) and a carry-in signal (Cin) and produce a 4-bit output (S) and a carry-out signal (Cout). The output should be updated on the rising edge of a clock signal (clk) and the module should be resettable with a reset signal (reset). The module should be implemented using a combinational logic block that takes into account the inputs and the carry-in signal to produce the output and the carry-out signal.", "output": "module adder_4bit (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  reg [3:0] S;\n  reg Cout;\n  \n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      S <= 4'b0;\n      Cout <= 1'b0;\n    end else begin\n      {Cout, S} <= A + B + Cin;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a buffer circuit that takes in a single input bit and outputs the same bit after one clock cycle delay. You should implement this buffer circuit using Verilog in a single module, without including any other modules. The module should have three inputs: `io_dataIn` (the input bit), `io_mainClk` (the clock signal), and `io_dataOut` (the output bit). \n\nYour module should be named `BufferCC` and should contain a single always block that is triggered on the positive edge of the clock signal. Within this always block, you should create two registers `buffers_0` and `buffers_1` that store the input and output bits respectively. On each positive edge of the clock signal, the input bit should be stored in `buffers_0` and the output bit should be updated to the value stored in `buffers_0` from the previous clock cycle.\n\nYou should ensure that your module is synthesizable and meets the timing requirements of the circuit.\n\n", "output": "module BufferCC (\n      input   io_dataIn,\n      output  io_dataOut,\n      input   io_mainClk);\n\n  reg  buffers_0;\n  reg  buffers_1;\n  \n  assign io_dataOut = buffers_1;\n  \n  always @ (posedge io_mainClk) begin\n    buffers_0 <= io_dataIn;\n    buffers_1 <= buffers_0;\n  end\n\nendmodule"}
{"instruction": "\n\nWrite a verilog module that implements a simple 4-bit adder with carry-in and carry-out. The module should have three input ports, A, B, and Cin, and two output ports, Sum and Cout. The module should be named \"fourBitAdder\" and should use the \"assign\" statement to calculate the Sum and Cout.\n\n", "output": "module fourBitAdder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] temp_sum;\n    wire temp_cout;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[3:0];\n    assign Cout = temp_sum[4];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that will take in a 16-bit input signal, and output a 16-bit signal that is the same as the input signal but with the most significant bit (MSB) set to 1 if the input signal is negative, and 0 otherwise. The module should be named \"sign_extension\".\n\nAssume that the input signal is in two's complement format, and that it is signed. The MSB is the sign bit, and it is set to 1 for negative numbers and 0 for positive numbers. \n\nWrite a Verilog module named \"sign_extension\" that takes in a 16-bit input signal \"data_in\" and outputs a 16-bit signal \"data_out\" that is the same as the input signal but with the MSB set to 1 if the input signal is negative, and 0 otherwise.\n\nYour module should be able to handle any 16-bit two's complement signed input signal, and should output a 16-bit two's complement signed signal that has the same value as the input signal but with the MSB set to 1 if the input signal is negative, and 0 otherwise.\n\n", "output": "module sign_extension(\n    input signed [15:0] data_in,\n    output signed [15:0] data_out\n);\n\nassign data_out = (data_in < 0) ? {16'b1, data_in[15:0]} : {16'b0, data_in[15:0]};\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that takes in two 8-bit inputs A and B, and outputs the sum of A and B in binary. The module should also output a carry bit indicating whether an overflow occurred. The module should be named \"addition_module\" and should have the following ports:\n- input A: 8-bit unsigned integer\n- input B: 8-bit unsigned integer\n- output sum: 9-bit unsigned integer (the most significant bit will be the carry bit)\n- output carry: 1-bit unsigned integer\n\nYour implementation should be able to handle all possible combinations of A and B inputs, including overflow conditions. You may assume that the inputs are unsigned integers and that the output will not exceed 9 bits.\n\n", "output": "module addition_module(\n    input [7:0] A,\n    input [7:0] B,\n    output [8:0] sum,\n    output carry\n);\n\n    wire [8:0] temp_sum;\n    assign temp_sum = A + B;\n    assign carry = (temp_sum[8] == 1) ? 1 : 0;\n    assign sum = temp_sum;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a T flip-flop with asynchronous set and reset inputs. The module should have the following inputs and outputs:\n\n- `T`: input bit for toggling the output\n- `S`: asynchronous set input\n- `R`: asynchronous reset input\n- `CLK`: clock input\n- `Q`: output bit\n- `QN`: complement output bit\n\nDesign the module using behavioral verilog and ensure that it has the following functionality:\n\n- When `S` is asserted, `Q` is set to 1 and `QN` is set to 0, regardless of the value of `T`.\n- When `R` is asserted, `Q` is set to 0 and `QN` is set to 1, regardless of the value of `T`.\n- When `T` is asserted, the output `Q` should toggle.\n\n", "output": "module t_ff_asr (T, S, R, CLK, Q, QN);\n  input T, S, R, CLK;\n  output Q, QN;\n  reg Q, QN;\n\n  always @(posedge CLK) begin\n    if (S) begin\n      Q <= 1;\n      QN <= 0;\n    end else if (R) begin\n      Q <= 0;\n      QN <= 1;\n    end else if (T) begin\n      Q <= ~Q;\n      QN <= ~QN;\n    end\n  end\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that simulates a simple calculator. The calculator should be able to perform addition, subtraction, multiplication, and division on two 8-bit numbers. The inputs to the module are two 8-bit numbers (A and B) and a 2-bit opcode that specifies the operation to be performed. The output of the module is the result of the operation. \n\nThe opcode should be defined as follows:\n- 2'b00: addition (A + B)\n- 2'b01: subtraction (A - B)\n- 2'b10: multiplication (A * B)\n- 2'b11: division (A / B)\n\nTo simplify the problem, you can assume that the inputs are always valid and that division by zero will not occur.\n\n", "output": "module calculator(\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] opcode,\n    output reg [15:0] result\n);\n\nalways @* begin\n    case(opcode)\n        2'b00: result = A + B;\n        2'b01: result = A - B;\n        2'b10: result = A * B;\n        2'b11: result = A / B;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module to implement a simple RAM model. The module should have the following inputs and outputs:\n\nInputs:\n- `data`: 32-bit input data to be written to memory\n- `rdaddress`: 24-bit read address\n- `wraddress`: 24-bit write address\n- `wrclock`: write clock signal\n- `wren`: write enable signal\n\nOutputs:\n- `q`: 32-bit output data read from memory\n\nThe RAM model should have a depth of 2048 and each memory location should be 32 bits wide. The RAM model should be able to read and write data on the rising edge of the write clock signal. If the write enable signal is high, the input data should be written to the memory location specified by the write address. If the read address matches a valid memory location, the output data should be the data stored in that location. If the read address does not match any valid memory location, the output data should be `32'dX`.\n\nDesign the Verilog module to implement this RAM model.\n\n", "output": "module ram_model (\n  input [31:0] data,\n  input [23:0] rdaddress,\n  input [23:0] wraddress,\n  input wrclock,\n  input wren,\n  output reg [31:0] q\n);\n\n  parameter ARRAY_DEPTH = 2048;\n\n  reg [31:0] mem_array [ARRAY_DEPTH-1:0];\n\n  always @(posedge wrclock) begin\n    if (wren) begin\n      mem_array[wraddress] <= data;\n    end\n  end\n\n  always @(*) begin\n    if (rdaddress < ARRAY_DEPTH) begin\n      q <= mem_array[rdaddress];\n    end\n    else begin\n      q <= 32'dX;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a frequency divider. \nA frequency divider is a digital circuit that takes an input clock signal and produces an output clock signal that has a lower frequency than the input clock signal. \nThe output clock signal has a frequency that is a fraction of the input clock signal frequency.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- clk_in: the input clock signal\n- reset: a reset signal that sets the output clock signal to zero\n- divider: a parameter that determines the division ratio of the frequency divider\n\nOutput: \n- clk_out: the output clock signal with a frequency that is a fraction of the input clock signal frequency\n\nYour module should implement the following functionality:\n- The output clock signal should have a frequency that is a fraction of the input clock signal frequency, determined by the value of the divider parameter.\n- The output clock signal should be reset to zero when the reset input is asserted.\n- The output clock signal should continue to operate normally after the reset input is de-asserted.\n\nTo implement the frequency divider, you should use Verilog code to divide the input clock signal frequency by the value of the divider parameter. \nYou should then use this divided clock signal to generate the output clock signal. \nYou should also use the reset input to set the output clock signal to zero.", "output": "module freq_div (\n  input clk_in,\n  input reset,\n  input [7:0] divider,\n  output reg clk_out\n);\n\n  reg [7:0] count = 0;\n\n  always @(posedge clk_in or posedge reset) begin\n    if (reset) begin\n      clk_out <= 0;\n      count <= 0;\n    end else begin\n      count <= count + 1;\n      if (count == divider) begin\n        clk_out <= ~clk_out;\n        count <= 0;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit binary up-counter that counts from 0 to 15. The counter should be synchronous with an active high reset input that sets the counter to 0. The counter should also have an enable input that allows the counter to count only when it is high.", "output": "module binary_up_counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else if (enable) begin\n      if (count == 4'b1111) begin\n        count <= 4'b0000;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-bit counter. The counter should count up on each rising edge of the clock signal (clk) and reset to 0 when the reset signal (reset) is high. The output of the counter should be displayed on the 3 output pins (out[2:0]).", "output": "module counter_3bit (\n  input clk,\n  input reset,\n  output reg [2:0] out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      out <= 3'b0;\n    end else begin\n      out <= out + 1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nWrite a Verilog module for a 4-bit synchronous up-counter with asynchronous reset and enable. The counter should increment on the rising edge of the clock signal (CK) only when the enable signal (EN) is high. When the reset signal (RST) is high, the counter should be reset to 0. The counter should output the current count value (Q).\n\n", "output": "module up_counter(CK, EN, RST, Q);\ninput CK, EN, RST;\noutput reg [3:0] Q;\n\nalways @(posedge CK or negedge RST)\nbegin\n    if(!RST) //asynchronous reset\n        Q <= 4'b0;\n    else if(EN) //check enable signal\n        Q <= Q + 1;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-input multiplexer using behavioral modeling. The module should have three input signals, sel, a, b, and one output signal, out. If sel is 0, the output should be a, and if sel is 1, the output should be b. If sel is 2, the output should be the logical AND operation between a and b. Write the Verilog code for the module using if-else statements.", "output": "module mux_3input_behavioral (\n  input [1:0] sel,\n  input a,\n  input b,\n  output reg out\n);\n\n  always @(*) begin\n    if(sel == 0)\n      out = a;\n    else if(sel == 1)\n      out = b;\n    else if(sel == 2)\n      out = a & b;\n  end\n  \nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit adder-subtractor. The module should have three inputs: a 4-bit input A, a 4-bit input B, and a 1-bit input SUB. The module should output a 4-bit signal (SUM) equal to A+B if SUB is low and A-B if SUB is high.", "output": "module adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] SUM\n);\n\n    wire [3:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    assign SUM = (SUB) ? A + B_comp : A + B;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a Verilog module that implements a 2-input XOR gate using only NOR gates. The XOR gate should have inputs a and b, and output out. You can use the NOR gate module from the given prompt to implement the XOR gate.", "output": "module xor_nor(\n  input a,\n  input b,\n  output out\n);\n\n  wire na, nb, nand1, nand2, nand3, nand4;\n\n  // Implementing NOT gates using NOR gates\n  nor(na, a, a);\n  nor(nb, b, b);\n\n  // Implementing NAND gates using NOR gates\n  nor(nand1, a, nb);\n  nor(nand2, na, b);\n\n  // Implementing OR gate using NOR gates\n  nor(nand3, nand1, nand2);\n\n  // Implementing NOT gate using NOR gate\n  nor(nand4, nand3, nand3);\n\n  // Output of XOR gate\n  assign out = nand4;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 2-input AND gate with an additional control input. The output of the gate should be high only if both inputs are high and the control input is also high. The module should have the following interface:\n\nInputs:\n- `in1`: a 1-bit input\n- `in2`: a 1-bit input\n- `ctrl`: a 1-bit input\n\nOutputs:\n- `out`: a 1-bit output\n\nYour implementation should be contained within a single module, and should not exceed 200 lines of code. You may not use any pre-built Verilog modules or constructs.\n\n", "output": "module and_with_control (\n    input in1,\n    input in2,\n    input ctrl,\n    output out\n);\n\n    wire and_out = in1 & in2;\n    wire not_ctrl = ~ctrl;\n    wire or_out = and_out | not_ctrl;\n    assign out = ~or_out;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a D flip-flop with asynchronous reset and set inputs. The module should have the following inputs and outputs:\n\n- `CLK`: clock input\n- `D`: data input\n- `RESET`: asynchronous reset input (active low)\n- `SET`: asynchronous set input (active low)\n- `Q`: output\n- `QN`: complement of output\n\nThe module should follow the following specifications:\n\n- The output `Q` should follow the input `D` when the clock is rising edge.\n- When the reset input is asserted (`RESET` = 0), the output `Q` should be set to 0.\n- When the set input is asserted (`SET` = 0), the output `Q` should be set to 1.\n- The output `QN` should be the complement of `Q`.\n- The module should have setup and hold times of 2ns for all inputs.\n\nWrite the code for the D flip-flop module.\n\n", "output": "module d_ff_async_reset_set (\n    input CLK,\n    input D,\n    input RESET,\n    input SET,\n    output Q,\n    output QN\n);\n\nreg Q;\n\nalways @(posedge CLK, negedge RESET, negedge SET) begin\n    if (!RESET) // asynchronous reset\n        Q <= 1'b0;\n    else if (!SET) // asynchronous set\n        Q <= 1'b1;\n    else // normal operation\n        Q <= D;\nend\n\nassign QN = ~Q;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a brown-out reset (BOR) circuit. \nA BOR circuit is a type of digital circuit that monitors the power supply voltage and generates a reset signal when the voltage drops below a certain threshold. \nThis is important because when the power supply voltage drops below a certain level, the digital circuits may not operate correctly, and the BOR circuit helps to prevent this.\nYour module should have the following inputs and outputs:\n\nInputs: \n- Vin: the input voltage from the power supply\n- Vth: the threshold voltage for the brown-out reset circuit\n- clk: the clock signal\n- reset: the asynchronous reset signal (active low)\n\nOutputs: \n- rst_out: the brown-out reset signal\n\nTo implement the BOR circuit, you should use Verilog code to compare the input voltage (Vin) with the threshold voltage (Vth). \nWhen the input voltage drops below the threshold voltage, the BOR circuit should generate a reset signal (rst_out) to reset the digital circuits.\nYou should use a flip-flop to hold the reset signal until the input voltage rises above the threshold voltage again. \nThe clock signal (clk) should be used to synchronize the reset signal with the digital circuits.\nFinally, you should use the asynchronous reset signal (reset) to reset the flip-flop when the system is powered on.", "output": "module BOR (\n  input Vin,\n  input Vth,\n  input clk,\n  input reset,\n  output rst_out\n);\n\n  reg bor_ff;\n\n  always @ (posedge clk or negedge reset) begin\n    if (!reset) begin\n      bor_ff <= 0;\n    end else begin\n      if (Vin < Vth) begin\n        bor_ff <= 1;\n      end else begin\n        bor_ff <= 0;\n      end\n    end\n  end\n\n  assign rst_out = bor_ff;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a combinational circuit, used for finding the minimum of four unsigned numbers. You can use standard comparison operators (a < b) to compare the numbers. The output of the module should be the minimum number among the four inputs.", "output": "module unsigned_min(\n  input [31:0] a, b, c, d,\n  output reg [31:0] min\n);\n\n  always @(*) begin\n    if(a < b && a < c && a < d)\n      min = a;\n    else if(b < c && b < d)\n      min = b;\n    else if(c < d)\n      min = c;\n    else\n      min = d;\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a combinational circuit which takes a 4-bit input and generates a 3-bit output. The output is determined based on the following rules: if the input is less than 4, the output is equal to the input plus 2; if the input is greater than or equal to 4, the output is equal to the input minus 2. Implement the circuit using a conditional operator.", "output": "module comb_circuit (\n  input [3:0] in,\n  output reg [2:0] out\n);\n\n  always @(*) begin\n    out = (in < 4) ? in + 2 : in - 2;\n  end\n\nendmodule\n"}
{"instruction": "\nYou are tasked with designing a module for a digital circuit that takes in a 4-bit binary input and outputs the binary equivalent of its Gray code. The module should be named `bin2gray` and should have the following inputs and outputs:\n\n**Inputs:**\n- `bin[3:0]`: a 4-bit binary input\n\n**Outputs:**\n- `gray[3:0]`: a 4-bit binary output representing the Gray code equivalent of `bin`\n\nThe module should be synchronous and should be triggered on the positive edge of the clock signal. The module should also have a reset input, `reset`, which when asserted should reset the output to all zeros.\n\nYou may assume that the inputs will always be valid 4-bit binary numbers.\n\n", "output": "module bin2gray (\n    input [3:0] bin,\n    output [3:0] gray,\n    input reset,\n    input clk\n);\n\nreg [3:0] gray_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        gray_reg <= 4'b0000;\n    end else begin\n        gray_reg <= bin ^ (bin >> 1);\n    end\nend\n\nassign gray = gray_reg;\n\nendmodule"}
{"instruction": "\nYou are given a Verilog module `Problem1Integrated` that takes in two 8-bit inputs `Input_A` and `Input_B` and outputs three signals `GT`, `LT`, and `EQ`. The module consists of eight instances of another module called `Problem4`, each comparing one bit of the inputs and propagating the comparison result to the next instance. The `Problem4` module takes in two 1-bit inputs `A` and `B` and three 1-bit inputs `GTI`, `LTI`, and `EQI`, and outputs three 1-bit signals `GTO`, `LTO`, and `EQO`. The module compares `A` and `B` and sets the output signals as follows:\n- `GTO` is 1 if `A` is greater than `B`, otherwise 0.\n- `LTO` is 1 if `A` is less than `B`, otherwise 0.\n- `EQO` is 1 if `A` is equal to `B`, otherwise 0.\n\nYour task is to implement the `Problem4` module. You can assume that the inputs `A` and `B` are valid 1-bit signals.\n\n", "output": "module Problem4(\n    input A,\n    input B,\n    input GTI,\n    input LTI,\n    input EQI,\n    output reg GTO,\n    output reg LTO,\n    output reg EQO\n    );\n    \n    always @(*) begin\n        if (A > B) begin\n            GTO = 1;\n            LTO = 0;\n            EQO = 0;\n        end else if (A < B) begin\n            GTO = 0;\n            LTO = 1;\n            EQO = 0;\n        end else begin\n            GTO = 0;\n            LTO = 0;\n            EQO = 1;\n        end\n    end\n    \n    initial begin\n        GTO = GTI;\n        LTO = LTI;\n        EQO = EQI;\n    end\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 4-bit adder with a carry-in and a carry-out. The module should have four inputs: two 4-bit operands A and B, a carry-in bit Cin, and a clock signal CLK. The module should also have two outputs: a 4-bit sum S and a carry-out bit Cout.\n\nYour task is to design a Verilog module that meets the following requirements:\n\n1. The module should be named \"four_bit_adder\".\n2. The module should have the inputs and outputs described above.\n3. The module should be synchronous, i.e., it should only update its outputs on the rising edge of the clock signal.\n4. The module should implement a 4-bit adder with a carry-in and a carry-out.\n5. The module should be designed such that it can be synthesized to a circuit with a maximum frequency of 100MHz.\n6. The module should be implemented within 200 lines of Verilog code.\n\nDesign constraints:\n1. You are not allowed to use any Verilog constructs that are not synthesizable, such as \"initial\" or \"force\".\n2. You are not allowed to use any Verilog constructs that are not supported by the SkyWater 130nm process, such as \"cmos\" or \"nmos\".\n3. You are not allowed to use any Verilog constructs that are not supported by the open-source Yosys synthesis tool, such as \"generate\".\n\n", "output": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input CLK,\n    output reg [3:0] S,\n    output reg Cout\n);\n\nreg [3:0] sum;\n\nalways @(posedge CLK) begin\n    sum = A + B + Cin;\n    S = sum[3:0];\n    Cout = sum[4];\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a system that incorporates a 2-to-1 mux and an XOR gate to implement a parity checker. The system should take in 8 bits of data, and output a signal indicating whether the data has odd or even parity. The 2-to-1 mux should select between the input data and the output of the XOR gate based on the value of sel_b1. If sel_b1 is true, the output of the XOR gate should be selected. Otherwise, the input data should be selected. The output of the system should be a signal indicating whether the data has odd or even parity.", "output": "module parity_checker (\n  input [7:0] data_in,\n  input sel_b1,\n  output reg parity\n);\n\n  wire xor_out;\n  assign xor_out = data_in[0] ^ data_in[1] ^ data_in[2] ^ data_in[3] ^ data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7];\n\n  always @(*) begin\n    if(sel_b1) begin\n      parity <= ~xor_out;\n    end else begin\n      parity <= xor_out;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been given a verilog module `top` that instantiates a module `sky130_fd_sc_hdll__o32ai`. The `top` module consists of 9 input ports and 1 output port. The inputs `A1`, `A2`, `A3`, `B1`, `B2`, `VPWR`, `VGND`, `VPB`, and `VNB` are registered and the output `Y` is a wire. The initial state of all inputs is `x`. The inputs are controlled by a testbench that sets the values of the inputs at specific times. The behavior of the inputs and outputs is as follows:\n\n- At time 20, the value of `A1` is set to 0.\n- At time 40, the value of `A2` is set to 0.\n- At time 60, the value of `A3` is set to 0.\n- At time 80, the value of `B1` is set to 0.\n- At time 100, the value of `B2` is set to 0.\n- At time 120, the value of `VGND` is set to 0.\n- At time 140, the value of `VNB` is set to 0.\n- At time 160, the value of `VPB` is set to 0.\n- At time 180, the value of `VPWR` is set to 0.\n- At time 200, the value of `A1` is set to 1.\n- At time 220, the value of `A2` is set to 1.\n- At time 240, the value of `A3` is set to 1.\n- At time 260, the value of `B1` is set to 1.\n- At time 280, the value of `B2` is set to 1.\n- At time 300, the value of `VGND` is set to 1.\n- At time 320, the value of `VNB` is set to 1.\n- At time 340, the value of `VPB` is set to 1.\n- At time 360, the value of `VPWR` is set to 1.\n- At time 380, the value of `A1` is set to 0.\n- At time 400, the value of `A2` is set to 0.\n- At time 420, the value of `A3` is set to 0.\n- At time 440, the value of `B1` is set to 0.\n- At time 460, the value of `B2` is set to 0.\n- At time 480, the value of `VGND` is set to 0.\n- At time 500, the value of `VNB` is set to 0.\n- At time 520, the value of `VPB` is set to 0.\n- At time 540, the value of `VPWR` is set to 0.\n- At time 560, the value of `VPWR` is set to 1.\n- At time 580, the value of `VPB` is set to 1.\n- At time 600, the value of `VNB` is set to 1.\n- At time 620, the value of `VGND` is set to 1.\n- At time 640, the value of `B2` is set to 1.\n- At time 660, the value of `B1` is set to 1.\n- At time 680, the value of `A3` is set to 1.\n- At time 700, the value of `A2` is set to 1.\n- At time 720, the value of `A1` is set to 1.\n- At time 740, the value of `VPWR` is set to x.\n- At time 760, the value of `VPB` is set to x.\n- At time 780, the value of `VNB` is set to x.\n- At time 800, the value of `VGND` is set to x.\n- At time 820, the value of `B2` is set to x.\n- At time 840, the value of `B1` is set to x.\n- At time 860, the value of `A3` is set to x.\n- At time 880, the value of `A2` is set to x.\n- At time 900, the value of `A1` is set to x.\n\nYou are required to write the verilog code for the module `sky130_fd_sc_hdll__o32ai` that implements the following logic:\n\n- If `A1`, `A2`, and `A3` are all 0, and `B1` and `B2` are both 1, then `Y` should be 1.\n- Otherwise, `Y` should be 0.\n\n", "output": "module sky130_fd_sc_hdll__o32ai (\n    input A1, A2, A3, B1, B2, VPWR, VGND, VPB, VNB,\n    output reg Y\n);\n\nalways @(*)\nbegin\n    if (A1 == 1'b0 && A2 == 1'b0 && A3 == 1'b0 && B1 == 1'b1 && B2 == 1'b1)\n        Y <= 1'b1;\n    else\n        Y <= 1'b0;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that implements a 4-bit comparator. The module should take in two 4-bit inputs, A and B, and output two 1-bit values indicating whether A is greater than B and whether A is less than B. The module should use a combinational circuit to perform the comparison. The output values should be active-high.", "output": "module comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output greater,\n    output less\n);\n\nassign greater = (A > B);\nassign less = (A < B);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a circuit with no inputs and two outputs. The first output should always drive 0 (or logic low), and the second output should always drive 1 (or logic high). Implement this module using behavioral modeling in Verilog.", "output": "module zero_one (\n  output reg out1,\n  output reg out2\n);\n\n  // Implementing the circuit with no inputs and two outputs\n  always @* begin\n    out1 = 1'b0;\n    out2 = 1'b1;\n  end\n\nendmodule\n"}
{"instruction": "\n\nWrite a Verilog module that takes in two 8-bit inputs, `a` and `b`, and outputs a 16-bit signal `sum`. The module should have a synchronous reset input `rst` which resets the `sum` to 0. The module should also have a control input `ctrl` which is active-high. When `ctrl` is high, the module should add `a` and `b` and store the result in `sum`. When `ctrl` is low, the module should hold the value of `sum` without any changes.\n\n", "output": "module adder(\n    input clk, rst, ctrl,\n    input [7:0] a, b,\n    output reg [15:0] sum\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sum <= 0;\n    end else if (ctrl) begin\n        sum <= a + b;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a RAM module in Verilog that can read and write data asynchronously. The module should have the following inputs and outputs:\n\nInputs:\n- `data`: a 16-bit input data signal\n- `rdaddress`: a 22-bit input address signal for read operations\n- `rdclken`: a clock enable signal for read operations\n- `wraddress`: a 22-bit input address signal for write operations\n- `wrclock`: a clock signal for write operations\n- `wren`: a write enable signal\n\nOutputs:\n- `q`: a 16-bit output data signal\n\nThe RAM module should use a 16-bit memory array with 4,194,304 (2^22) memory locations. The module should be able to read data asynchronously, meaning that the output `q` should update immediately after the `rdaddress` input changes. The module should also be able to write data synchronously, meaning that the write operation should occur on the rising edge of the `wrclock` input.\n\nYour task is to write the Verilog code for this RAM module. Your code should be contained within a single module and should be no more than 200 lines long.\n\n", "output": "module ram_module (\n  // inputs:\n  input [15:0] data,\n  input [21:0] rdaddress,\n  input rdclken,\n  input [21:0] wraddress,\n  input wrclock,\n  input wren,\n\n  // outputs:\n  output [15:0] q\n);\n\n  reg [15:0] mem_array [0:4194303];\n  reg [21:0] read_address;\n\n  assign q = mem_array[read_address];\n\n  always @(posedge wrclock) begin\n    if (wren) begin\n      mem_array[wraddress] <= data;\n    end\n  end\n\n  always @(rdaddress) begin\n    read_address <= rdaddress;\n  end\n\n  initial begin\n    $readmemh(\"sdram_0.dat\", mem_array);\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a clock gating circuit for a register adder that operates on 13-bit binary numbers. The circuit should have the following inputs and outputs:\n\n- `CLK` : a clock signal\n- `EN` : an enable signal\n- `TE` : a transparent enable signal\n- `ENCLK` : an output signal representing the gated clock\n\nYou are given the following Verilog code snippet as a starting point:\n\n```\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W13 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\ninitial $sdf_annotate(\"FPU_PIPELINED_FPADDSUB_ASIC_fpu_syn_constraints_clk10.tcl_GATED_syn.sdf\"); \n endmodule\n```\n\nYour task is to complete the design of the clock gating circuit by writing Verilog code that implements the following behavior:\n\n- When `EN` is low, `ENCLK` should be low, regardless of the state of `CLK`.\n- When `EN` is high and `TE` is low, `ENCLK` should be the same as `CLK`.\n- When `EN` and `TE` are both high, `ENCLK` should be high, regardless of the state of `CLK`.\n\nYour solution should be a Verilog module that implements the clock gating circuit and satisfies the above requirements. Your module should be no more than 200 lines of Verilog code.\n\n", "output": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W13 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg gated_clk;\n\n  always @ (posedge CLK or negedge EN) begin\n    if (!EN) begin\n      gated_clk <= 1'b0;\n    end else if (!TE) begin\n      gated_clk <= CLK;\n    end else begin\n      gated_clk <= 1'b1;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a D flip-flop with asynchronous reset and synchronous set using Verilog. You have been given a code snippet for a module that implements a D flip-flop with preset and clear capabilities, but you need to modify it to meet the new requirements.\n\nThe module takes three inputs and one output:\n- D: the data input\n- C: the clock input\n- Q: the output\n\nThe module should have the following behavior:\n- When C is high, the flip-flop should capture the value of D and hold it until the next rising edge of C.\n- When the asynchronous reset input, labeled R, is high, the output Q should be forced to 0, regardless of the value of D or C.\n- When the synchronous set input, labeled S, is high, the output Q should be forced to 1, regardless of the value of D or C.\n\nYou should modify the given code snippet to implement the new requirements. Your solution should be a single module that is self-contained and does not require any additional modules.\n\n", "output": "module DFF_RST_SET (input D, C, R, S, output reg Q);\n    always @(posedge C or posedge R or posedge S) begin\n        if (R) begin\n            Q <= 1'b0;\n        end else if (S) begin\n            Q <= 1'b1;\n        end else begin\n            Q <= D;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a full adder. The module should have three inputs, A, B, and Cin, and two outputs, Sum and Cout. The Sum output should be the result of adding A, B, and Cin, while the Cout output should be the carry bit generated by the addition. \n\nThe module should be named \"full_adder\" and should be implemented using only basic logic gates (AND, OR, NOT, etc.). You are not allowed to use any pre-defined modules or operators (such as + or &).\n\nYou should also include the following ports in your module:\n\n- input A: the first input bit\n- input B: the second input bit\n- input Cin: the carry-in bit\n- output Sum: the sum of the three input bits\n- output Cout: the carry-out bit\n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input Cin,\n    output Sum,\n    output Cout\n);\n\n    wire w1, w2, w3;\n\n    // First stage\n    xor x1(Sum, A, B);\n    and a1(w1, A, B);\n    and a2(w2, A, Cin);\n    and a3(w3, B, Cin);\n    or o1(Cout, w1, w2, w3);\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that implements a D flip-flop using the sky130_fd_sc_lp__dlrbn_1 module. The D flip-flop should have a synchronous reset and active-low enable gate. The input D should be able to change its value only on the rising edge of the clock signal. The module should have the following inputs and outputs:\n\n- input D: the data input\n- input CLK: the clock signal\n- input RESET: the synchronous reset signal (active-low)\n- input GATE: the enable gate (active-low)\n- output Q: the output of the D flip-flop\n- output Q_N: the complement of the output Q\n\nYour task is to implement the module that satisfies the above requirements.\n\n", "output": "module d_ff (\n    input D,\n    input CLK,\n    input RESET,\n    input GATE,\n    output Q,\n    output Q_N\n);\n\n    wire GATE_N;\n    assign GATE_N = ~GATE;\n\n    sky130_fd_sc_lp__dlrbn_1 ff (\n        .Q(Q),\n        .Q_N(Q_N),\n        .RESET_B(RESET),\n        .D(D),\n        .GATE_N(GATE_N)\n    );\n\n    always @(posedge CLK) begin\n        if (GATE == 1'b0) begin\n            ff.D <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that performs a simple operation on two 4-bit inputs. The operation is as follows:\n- If the first input is greater than the second input, output the sum of the two inputs.\n- If the second input is greater than or equal to the first input, output the difference between the two inputs.\n\nYour module should have the following inputs and outputs:\n- Two 4-bit inputs, `A` and `B`\n- One 4-bit output, `Y`\n\nYou should also include a testbench to verify the functionality of your module.\n\n", "output": "module compare_op (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Y\n);\n\n    always @(*) begin\n        if (A > B)\n            Y = A + B;\n        else\n            Y = A - B;\n    end\n\nendmodule\n\nmodule compare_op_tb;\n\n    reg [3:0] A;\n    reg [3:0] B;\n    wire [3:0] Y;\n\n    compare_op uut (\n        .A(A),\n        .B(B),\n        .Y(Y)\n    );\n\n    initial begin\n        $monitor(\"A=%d, B=%d, Y=%d\", A, B, Y);\n        A = 5; B = 2; #10;\n        A = 2; B = 5; #10;\n        A = 3; B = 3; #10;\n        $finish;\n    end\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that implements a 3-bit counter with the following specifications:\n- The counter should increment on every positive edge of the clock signal.\n- The initial value of the counter should be 0.\n- When the counter reaches the maximum value (7), it should wrap around to 0.\n- The current value of the counter should be output on a 3-bit wire called \"count\".\n\nUse the code snippet below as a template for your module definition. You may add additional inputs, outputs, or internal signals as needed.\n\n```\nmodule counter (\n    input clk,\n    output reg [2:0] count\n);\n\n// Your code here\n\nendmodule\n```\n\n", "output": "module counter (\n    input clk,\n    output reg [2:0] count\n);\n\nalways @(posedge clk)\nbegin\n    if (count == 3'b111)\n        count <= 3'b000;\n    else\n        count <= count + 1;\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 32-bit adder with a carry-in input. The module should have two 32-bit inputs (A and B), one 1-bit input (cin), and one 32-bit output (sum). The module should output the sum of A, B, and cin.", "output": "module adder (\n    input [31:0] A,\n    input [31:0] B,\n    input cin,\n    output [31:0] sum\n);\n\n    assign sum = A + B + cin;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a VGA split controller that takes in two RGB signals and outputs a single RGB signal. The module should also take in a clock signal and a horizontal sync signal. The input RGB signals are 16 bits wide and the output RGB signal should also be 16 bits wide. The module should split the input RGB signals and display them on the left and right halves of the VGA display.\n\nDesign the Verilog module for the VGA split controller and ensure that it is self-contained within 200 lines of code. The module should be named \"vga_split_controller\" and should have the following ports:\n\n- `rgb_0`: the input RGB signal for the left half of the VGA display.\n- `rgb_1`: the input RGB signal for the right half of the VGA display.\n- `clock`: the input clock signal.\n- `hsync`: the input horizontal sync signal.\n- `rgb`: the output RGB signal for the VGA display.\n\nEnsure that the module is fully functional and can handle different clock frequencies and resolutions.\n\n", "output": "module vga_split_controller (\n    input [15:0] rgb_0,\n    input [15:0] rgb_1,\n    input clock,\n    input hsync,\n    output [15:0] rgb\n);\n\nwire [15:0] rgb_left;\nwire [15:0] rgb_right;\n\n// Split the input RGB signals into left and right halves\nassign rgb_left = rgb_0;\nassign rgb_right = rgb_1;\n\n// Combine the left and right halves into a single RGB signal\nalways @ (posedge clock) begin\n    if (hsync) begin\n        rgb <= {rgb_left[15:8], rgb_left[7:0], rgb_right[15:8], rgb_right[7:0]};\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that can perform a specific function. The module should be named \"adder_subtractor\" and should have the following ports:\n\n- `input [7:0] A`: an 8-bit input bus representing the first operand\n- `input [7:0] B`: an 8-bit input bus representing the second operand\n- `input mode`: a single bit input representing the mode of operation. If `mode` is 0, the module should perform addition. If `mode` is 1, the module should perform subtraction.\n- `output [7:0] result`: an 8-bit output bus representing the result of the operation.\n\nThe module should perform the specified operation and output the result on the `result` bus. The module should be designed to be synthesizable and should be contained within 200 lines of verilog code.\n\n", "output": "module adder_subtractor(\n    input [7:0] A,\n    input [7:0] B,\n    input mode,\n    output [7:0] result\n);\n\n    wire [7:0] twos_comp_B;\n    wire [7:0] sum;\n\n    assign twos_comp_B = ~B + 1;\n\n    assign sum = A + (mode ? twos_comp_B : B);\n\n    assign result = sum;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 8-bit inputs, A and B, and outputs the sum of the two inputs. The module should also have an input signal, EN, that enables the addition operation when high. If EN is low, the output should remain constant at the previous value. The module should also have a 1-bit output, OVF, that indicates whether the addition operation resulted in an overflow.\n\nAssume that the inputs A and B are in two's complement format and that the output is also in two's complement format. The module should be named \"adder\" and should have the following ports:\n\nInputs:\n- A: 8-bit input\n- B: 8-bit input\n- EN: 1-bit input\n\nOutputs:\n- SUM: 8-bit output\n- OVF: 1-bit output\n\n", "output": "module adder (\n  input [7:0] A,\n  input [7:0] B,\n  input EN,\n  output [7:0] SUM,\n  output OVF\n);\n\n  reg [8:0] temp_sum;\n  reg [7:0] prev_A;\n  reg [7:0] prev_B;\n  reg prev_EN;\n\n  always @(*) begin\n    if (EN == 1'b1) begin\n      temp_sum = A + B;\n      if ((A[7] == B[7]) && (A[7] != temp_sum[7]))\n        OVF = 1'b1;\n      else\n        OVF = 1'b0;\n    end\n    else begin\n      temp_sum = {prev_A, prev_B} + prev_EN;\n    end\n  end\n\n  always @(posedge EN) begin\n    if (EN == 1'b1) begin\n      prev_A = A;\n      prev_B = B;\n      prev_EN = EN;\n    end\n  end\n\n  assign SUM = temp_sum[7:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module to implement a 4-bit counter that can count up or down based on a control signal. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock input\n- `rst`: a reset input\n- `up_down`: a control input that determines whether the counter should count up or down\n- `enable`: an enable input that controls whether the counter should be counting or not\n\nOutputs:\n- `count`: a 4-bit output that represents the current count value\n\nThe counter should start at 0 and count up or down by 1 on each rising edge of the clock, depending on the value of the `up_down` input. If `up_down` is high, the counter should count up. If `up_down` is low, the counter should count down. The counter should be enabled only when the `enable` input is high. When the `rst` input is high, the counter should be reset to 0.\n\nWrite a Verilog module that implements this counter.\n\n", "output": "module counter(clk, rst, up_down, enable, count);\n\n    input clk;\n    input rst;\n    input up_down;\n    input enable;\n    output reg [3:0] count;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0;\n        end\n        else if (enable) begin\n            if (up_down) begin\n                count <= count + 1;\n            end\n            else begin\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a simple memory-mapped ROM. The module should have a clock input `clka`, a 14-bit address input `addra`, and an 8-bit data output `douta`. The ROM should be capable of storing 2^14 = 16,384 bytes of data, and the `addra` input should be used to select which byte of data to output.\n\nYou should implement the ROM using a single Verilog module that is no longer than 200 lines of code. Your module should be synthesizable and should not use any non-synthesizable constructs or features. You can assume that the ROM will be initialized with valid data before it is used.\n\nYour module should be named `DIGDUG_ROM` and should be defined in a Verilog source file named `DIGDUG_ROM.v`. Your module should be defined using the `module` keyword and should have the following ports:\n\n- `clka` (input): The clock input for the module.\n- `addra` (input, 14 bits): The address input for the module.\n- `douta` (output, 8 bits): The data output for the module.\n\nYour module should synthesize to a single black-box module with the `black_box_pad_pin` attribute set to `\"clka,addra[13:0],douta[7:0]\"`.\n\n", "output": "module DIGDUG_ROM(clka, addra, douta);\n  input clka;\n  input [13:0] addra;\n  output [7:0] douta;\n  \n  reg [7:0] mem [0:16383];\n  \n  // Initialize memory with valid data\n  initial begin\n    $readmemh(\"rom_data.hex\", mem);\n  end\n  \n  always @ (posedge clka) begin\n    douta <= mem[addra];\n  end\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 16-bit adder with carry-in and carry-out signals. The module should have three inputs: `a` and `b`, which are 16-bit unsigned integers to be added, and `cin`, which is a single-bit carry-in signal. The module should have two outputs: `sum`, which is the 16-bit unsigned sum of `a` and `b`, and `cout`, which is the single-bit carry-out signal.\n\nThe Verilog module should be named `add16` and should be implemented within 200 lines of code. You may use any Verilog primitives or modules that are available in the standard Verilog library.\n\nYour implementation should handle overflow cases correctly, meaning that if the sum of `a` and `b` exceeds the maximum representable 16-bit unsigned integer, the carry-out signal `cout` should be set to 1.\n\n", "output": "module add16(\n  input [15:0] a,\n  input [15:0] b,\n  input cin,\n  output [15:0] sum,\n  output cout\n);\n\n  wire [15:0] sum_temp;\n  wire [16:0] sum_extended;\n\n  assign sum_extended = {1'b0, a} + {1'b0, b, cin};\n  assign sum_temp = sum_extended[15:0];\n  assign cout = sum_extended[16];\n\n  assign sum = sum_temp;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a Shift Register that shifts input data by 1 bit to the left on every clock cycle. Your module should have the following inputs and outputs:\n\nInputs:\n- `Clock`: a clock signal\n- `Data`: a 32-bit input data\n- `Enable`: a signal that enables the shift operation\n\nOutputs:\n- `Shifted_Data`: a 32-bit output data that is shifted by 1 bit to the left on every clock cycle\n\nImplement the module `Shift_Register_Left` using the provided code snippet as a starting point. Your module should meet the following requirements:\n- The module should use an initial block to initialize a `newClock` signal to 0.\n- The module should use an always block to toggle the `newClock` signal every 125 time units.\n- The module should use an always block triggered by the rising edge of the `newClock` signal.\n- If `Enable` is high, the module should shift `Data` by 1 bit to the left on every rising edge of `newClock` and assign the result to `Shifted_Data`.\n- If `Enable` is low, the module should assign `Data` to `Shifted_Data`.\n\n", "output": "module Shift_Register_Left\n(   input wire Clock,\n    input wire [31:0] Data,\n    input wire Enable,\n    output reg [31:0] Shifted_Data\n);\n    reg newClock;\n\n    initial begin \n        newClock = 0;\n    end\n\n    always begin\n        #125 newClock = ~newClock;\n    end\n\n    always @(posedge newClock) begin\n        if (Enable) begin\n            Shifted_Data = {Data[30:0], 1'b0};\n        end else begin\n            Shifted_Data = Data;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module called `lab4dpath` which has three 10-bit input registers `x1`, `x2`, and `x3`, and one 10-bit output wire `y`. The module also has a clock input `clk`. You are to write a Verilog module called `adder` which has the same inputs and outputs as `lab4dpath`, but instead of performing the operations that `lab4dpath` performs, it must simply add the three inputs together and output the result on `y`. You should not modify the `lab4dpath` module, but instead instantiate it in your `adder` module and use it to verify the correctness of your implementation.\n\nYour `adder` module should be implemented using a single always block, and should make use of Verilog's `+` operator to perform the addition. You should also ensure that your implementation is synthesizable.\n\n", "output": "module adder(\n    input [9:0] x1,\n    input [9:0] x2,\n    input [9:0] x3,\n    output [9:0] y\n);\n\n    lab4dpath uut (\n        .x1(x1),\n        .x2(x2),\n        .x3(x3),\n        .clk(1'b0),\n        .y(y)\n    );\n\n    always @(*) begin\n        y = x1 + x2 + x3;\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a round and saturation block. \nThis module should have the following inputs and outputs:\n\nInputs: a signed 16-bit number (in)\nOutputs: a signed 16-bit number (out)\n\nYour module should implement the following functionality:\n\n1. Round: Round the input number to the nearest integer. If the input number is exactly halfway between two integers, round it to the nearest even integer. For example, if the input number is 2.5, round it to 2. If the input number is 3.5, round it to 4.\n2. Saturation: If the input number is greater than the maximum allowed value (32767), set the output to the maximum value. If the input number is less than the minimum allowed value (-32768), set the output to the minimum value.\n\nTo implement the round and saturation block, you should use Verilog code to perform the following steps:\n\n1. Add 0.5 to the input number.\n2. Convert the input number to an integer.\n3. Subtract 0.5 from the integer.\n4. Check if the integer is greater than the maximum allowed value or less than the minimum allowed value. If so, set the output to the corresponding saturation value.\n5. Otherwise, set the output to the integer value.\n\nYou should use Verilog code to define the maximum and minimum allowed values as constants, and use them to perform the saturation check.", "output": "module round_saturate (\n  input signed [15:0] in,\n  output signed [15:0] out\n);\n\n  localparam MIN_VAL = -32768;\n  localparam MAX_VAL = 32767;\n\n  reg signed [15:0] temp;\n  reg signed [15:0] rounded;\n\n  always @(*) begin\n    temp = in + 0.5;\n    rounded = $floor(temp);\n    rounded = rounded - 0.5;\n    if (rounded > MAX_VAL) begin\n      out = MAX_VAL;\n    end else if (rounded < MIN_VAL) begin\n      out = MIN_VAL;\n    end else begin\n      out = rounded;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nConsider a module that has two inputs, `a` and `b` and two outputs, `out1` and `out2`. Implement a combinational circuit that performs the following operation:\n\n- If `a` is 1, `out1` should be the complement of `b` and `out2` should be `b`.\n- If `a` is 0, `out1` should be `b` and `out2` should be the complement of `b`.\n\nWrite a Verilog module that implements the above combinational circuit. You are not allowed to use any operators other than `!` (not), `&` (and), `|` (or), and `^` (xor).\n\n", "output": "module comb_circuit (\n  input a, b,\n  output out1, out2\n);\n\n  assign out1 = a ? ~b : b;\n  assign out2 = a ? b : ~b;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Develop a module that accepts a 4-bit binary input and produces a 4-bit binary output, where the output represents the one's complement of the input. The module should be implemented using only XOR gates. The input and output ports should be named \"in\" and \"out\", respectively.", "output": "module ones_complement(input [3:0] in, output [3:0] out);\n    assign out = in ^ 4'b1111;\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module to implement a 4-bit binary adder. The module should have two 4-bit inputs (A and B) and one 4-bit output (S) representing the sum of A and B. Additionally, the module should have one output (C) representing the carry bit, which is 1 if the sum of the two inputs exceeds 15 (i.e., if there is a carry out of the most significant bit).\n\nYour module should be named `four_bit_adder` and should be contained within 200 lines of Verilog code. You may use any Verilog constructs or operators you see fit, but the module must be self-contained and not rely on any external modules or libraries.\n\n", "output": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C\n);\n\n    wire [3:0] sum;\n    assign sum = A + B;\n\n    assign S = sum;\n    assign C = (sum[4] == 1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder with carry-in and carry-out. The module should have the following inputs and outputs:\n\nInputs:\n- `a`: a 4-bit input signal\n- `b`: a 4-bit input signal\n- `cin`: a single-bit carry-in signal\n\nOutputs:\n- `sum`: a 4-bit output signal representing the sum of `a` and `b`\n- `cout`: a single-bit carry-out signal\n\nYour module should be named `adder4`. You may use any verilog operators or constructs that you deem necessary for the implementation. Your module should be synthesizable and should not use any non-synthesizable constructs.\n\n", "output": "module adder4 (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] temp_sum;\n    wire [3:0] temp_carry;\n    \n    assign temp_sum = a + b + cin;\n    assign temp_carry = {a[0], b[0], cin} + {a[1], b[1], temp_sum[0]} + {a[2], b[2], temp_sum[1]} + {a[3], b[3], temp_sum[2]};\n    \n    assign sum = temp_sum;\n    assign cout = temp_carry[4];\n    \nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit magnitude comparator. The module should have two 4-bit inputs: A and B. The module should have three outputs: A_greater_than_B, A_less_than_B, and A_equal_to_B. These outputs should be high when the corresponding condition is met and low otherwise.", "output": "module magnitude_comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output A_greater_than_B,\n    output A_less_than_B,\n    output A_equal_to_B\n);\n\n    assign A_greater_than_B = (A > B);\n    assign A_less_than_B = (A < B);\n    assign A_equal_to_B = (A == B);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 2-to-1 multiplexer. The module should have two input signals, `A` and `B`, and one select signal, `S`. If `S` is high, the output should be equal to `A`, and if `S` is low, the output should be equal to `B`. You are not allowed to use the ternary operator in your solution.\n\nDesign your module to include the following:\n- Declare the module name as `mux_2to1`\n- Declare the input and output signals as `input A, B, S` and `output Y` respectively\n- Use the `always` block to implement the functionality of the module\n- Use `if-else` statements to determine the output based on the value of `S`\n- Use `assign` statements to set the value of `Y` based on the output determined in the `always` block\n\n", "output": "module mux_2to1(\n    input A, B, S,\n    output Y\n);\n\n    reg Y;\n\n    always @ (A, B, S)\n    begin\n        if (S == 1'b1)\n            Y = A;\n        else\n            Y = B;\n    end\n\n    assign Y = Y;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a verilog module that implements a 4-bit adder. The module should have four inputs, `A`, `B`, `Cin`, and `Clk`, and two outputs, `Sum` and `Cout`. The `A` and `B` inputs are the two 4-bit numbers to be added, `Cin` is the carry-in bit, and `Clk` is the clock signal. The `Sum` output is the 4-bit sum of the two input numbers, and `Cout` is the carry-out bit.\n\nYou must ensure that the module is synchronous and that the output is updated only on the rising edge of the clock signal. You should also ensure that the module is designed using behavioral Verilog.\n\nWrite the Verilog code for the 4-bit adder module.\n\n", "output": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input Clk,\n    output [3:0] Sum,\n    output Cout\n);\n\n    reg [3:0] Sum_reg;\n    reg Cout_reg;\n\n    always @(posedge Clk) begin\n        {Cout_reg, Sum_reg} <= A + B + Cin;\n    end\n\n    assign Sum = Sum_reg;\n    assign Cout = Cout_reg;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module in Verilog that takes in 5 input signals and produces 1 output signal. The input signals are A1, A2, A3, B1, and B2, and the output signal is X. Additionally, the module should have 4 power signals: VPB, VPWR, VGND, and VNB. \n\nThe module should be named \"my_module\" and should be designed to perform the following operation: \n- If A1 is high, X should be equal to the sum of B1 and B2. \n- If A1 is low, X should be equal to the sum of A2 and A3. \n\nThe module should be designed to consume as little power as possible while still meeting the above requirements. The module should be self-contained and should not rely on any external modules or libraries.\n\n", "output": "module my_module (\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    reg X_reg;\n    wire sum1, sum2;\n\n    assign sum1 = B1 + B2;\n    assign sum2 = A2 + A3;\n\n    always @ (A1 or A2 or A3 or B1 or B2) begin\n        if (A1 == 1) begin\n            X_reg <= sum1;\n        end else begin\n            X_reg <= sum2;\n        end\n    end\n\n    assign X = X_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in 3 input signals A1, A2, and B1, and outputs a single signal Y. Additionally, the module should have 4 input power signals: VPB, VPWR, VGND, and VNB.\n\nThe module should be named \"my_module\" and should be written in no more than 200 lines of Verilog code.\n\nThe output signal Y should be calculated as follows:\n- If A1 is high and A2 is low, Y should be high\n- If A1 is low and A2 is high, Y should be high\n- If B1 is high, Y should be high\n- If none of the above conditions are met, Y should be low\n\nThe power signals should be used as follows:\n- VPB is the power supply voltage for the module\n- VPWR is the power supply voltage for the output signal Y\n- VGND is the ground voltage for the module\n- VNB is the negative power supply voltage for the module\n\nEnsure that your module is self-contained and can be simulated without any additional code.\n\n", "output": "module my_module (\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    output Y   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    assign Y = (A1 && !A2) || (!A1 && A2) || B1;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a bitwise AND operation on two input bits and outputs the result. The module should be named \"bitwise_and\" and should have the following inputs and outputs:\n\nInputs:\n- `a` (1-bit): the first input bit\n- `b` (1-bit): the second input bit\n\nOutputs:\n- `out` (1-bit): the result of the bitwise AND operation\n\nYour module should be able to handle both rising and falling edge clock signals. Additionally, the module should have a reset input named `reset` that sets the output to 0 when asserted.\n\nWrite a Verilog module named \"bitwise_and\" that meets these requirements. Your solution should be contained within 200 lines of Verilog code.\n\n", "output": "module bitwise_and (\n    input a,\n    input b,\n    input reset,\n    input clk,\n    output reg out\n);\n\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        out <= 1'b0;\n    end else begin\n        out <= a & b;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that takes in two 4-bit inputs A and B and outputs a 5-bit signal C. The output C is determined by the value of A and B. If A is less than B, C will be equal to the sum of A and B. If A is greater than B, C will be equal to the difference between A and B. If A is equal to B, C will be equal to A bitwise OR B. Implement this module using a conditional operator.", "output": "module compare_and_operate (\n  input [3:0] A,\n  input [3:0] B,\n  output reg [4:0] C\n);\n\n  always @(*) begin\n    C = (A < B) ? (A + B) : ((A > B) ? (A - B) : (A | B));\n  end\n  \nendmodule\n"}
{"instruction": "\nYou have been tasked with designing a Verilog module for a full-adder circuit. The module should have three inputs (A, B, and CIN) and two outputs (SUM and COUT). The circuit should perform the following operation: \n\nSUM = A XOR B XOR CIN\nCOUT = (A AND B) OR (B AND CIN) OR (A AND CIN)\n\nYou should design the module using no more than 200 lines of Verilog code. \n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\n    // local signals\n    wire xor1_out, xor2_out, and1_out, and2_out, and3_out, or1_out, or2_out;\n\n    // XOR gates\n    xor xor1 (xor1_out, A, B);\n    xor xor2 (xor2_out, xor1_out, CIN);\n\n    // AND gates\n    and and1 (and1_out, A, B);\n    and and2 (and2_out, B, CIN);\n    and and3 (and3_out, A, CIN);\n\n    // OR gates\n    or or1 (or1_out, and1_out, and2_out);\n    or or2 (or2_out, or1_out, and3_out);\n\n    // assign outputs\n    assign SUM = xor2_out;\n    assign COUT = or2_out;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 12-to-1 multiplexer using Verilog. The multiplexer should have 12 input ports and 1 output port. Your task is to create a module that implements this multiplexer.\n\nYour module should be named \"Span12Mux_s7_h\" and should take in a single input and output port. The input port should be named \"I\" and the output port should be named \"O\". The module should be implemented in Verilog and should be no longer than 200 lines of code.\n\nYou may assume that the input ports will be 1 bit in width, and that the output port will also be 1 bit in width. The output of the multiplexer should be the value of the input port that is selected by the multiplexer's control signals.\n\nYour module should be able to handle all possible combinations of the input port values and the control signals.\n\n", "output": "module Span12Mux_s7_h(I, O);\n  input [11:0] I;\n  input [3:0] sel;\n  output O;\n  \n  assign O = sel[0] ? I[0] : sel[1] ? I[1] : sel[2] ? I[2] : sel[3] ? I[3] : sel[4] ? I[4] : sel[5] ? I[5] : sel[6] ? I[6] : sel[7] ? I[7] : sel[8] ? I[8] : sel[9] ? I[9] : sel[10] ? I[10] : I[11];\n  \nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit binary input and outputs the 2's complement of the input. The module should have four inputs: A, B, C, and D. The output should be a 4-bit 2's complement representation of the input. Hint: Use a conditional statement to check the sign bit and invert the remaining bits if necessary.", "output": "module twos_complement (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        if (A) begin\n            out <= ~(B-1) & ~(C-1) & ~(D-1);\n        end else begin\n            out <= {A, B, C, D};\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are working on a project that involves designing a clock gating circuit for a register add module. The clock gating circuit should be able to control the clock signal to the register add module based on the input signals. You have been provided with a code snippet that includes a module named \"SNPS_CLOCK_GATE_HIGH_RegisterAdd_W13\" which includes input and output ports. \n\nYour task is to design the clock gating circuit for this module. The circuit should be able to generate an output signal \"ENCLK\" based on the input signals \"CLK\", \"EN\", and \"TE\". The \"EN\" signal is the enable signal for the clock gating circuit and \"TE\" is the set enable signal for the latch. The output signal \"ENCLK\" should be high only when the \"EN\" and \"TE\" signals are high and the \"CLK\" signal is low. \n\nWrite a Verilog code for the clock gating circuit that will be used in the \"SNPS_CLOCK_GATE_HIGH_RegisterAdd_W13\" module.\n\n", "output": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W13 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK;\n\n  always @ (posedge CLK) begin\n    if(EN && TE) begin\n      ENCLK <= 1'b0;\n    end\n    else begin\n      ENCLK <= 1'b1;\n    end\n  end\n\nendmodule"}
{"instruction": "Develop a module that can perform the same functionality as an XNOR gate, but using only NAND gates. The module should take two input values and produce a single output value that represents the result of the XNOR operation.", "output": "module xnor_nand( \n    input a, \n    input b, \n    output out );\n    \n    wire nand1, nand2, nand3, nand4;\n    \n    assign nand1 = ~(a & b);\n    assign nand2 = ~(a & nand1);\n    assign nand3 = ~(b & nand1);\n    assign nand4 = ~(nand2 & nand3);\n    \n    assign out = nand4;\n    \nendmodule"}
{"instruction": "\nYou are tasked with designing a D flip-flop with synchronous active-low reset functionality. The D flip-flop should have two inputs: a clock input (`C`) and a data input (`D`). It should also have one output: the stored value of the data input (`Q`). When the clock input transitions from high to low, the value of the data input should be stored in the flip-flop and output on `Q`.\n\nIn addition to the clock and data inputs, the flip-flop should also have an active-low reset input (`R`). When the reset input is asserted (i.e. goes low), the output value of the flip-flop should be set to 0.\n\nYou should implement the flip-flop using Verilog. Your implementation should be able to run on an iCE40 FPGA and should include timing specifications for the iCE40 HX, LP, and UP5K FPGA families.\n\n", "output": "module DFF_RST (\n    input C,\n    input D,\n    input R,\n    output reg Q\n);\n\n    always @(negedge C) begin\n        if (R == 0) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 2-to-1 multiplexer. The module should have two data inputs (D0 and D1), one select input (S), and one output (Y). When S is high, the output Y should be equal to D1, and when S is low, the output Y should be equal to D0. The module should be named \"mux_2to1\" and should be completely self-contained, meaning that all necessary inputs and outputs should be defined within the module.\n\nIn addition, the module should be able to handle asynchronous inputs and should have a synchronous reset input (RST). When the reset input is high, the output Y should be set to 0, regardless of the values of D0, D1, and S. The module should also have a clock input (CLK) and should only update its output on the rising edge of the clock.\n\nYour task is to write the Verilog code for the \"mux_2to1\" module that satisfies the above requirements. The code should be no longer than 200 lines.\n\n", "output": "module mux_2to1 (\n    input wire D0, \n    input wire D1,\n    input wire S,\n    input wire RST,\n    input wire CLK,\n    output reg Y\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Y <= 0;\n        end else begin\n            if (S) begin\n                Y <= D1;\n            end else begin\n                Y <= D0;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a 4:1 multiplexer (MUX). \nA MUX is a type of digital circuit that selects one of four inputs and passes it to the output based on the value of two select lines. \nYour module should have the following inputs and outputs:\n\nInputs: four input signals (in0, in1, in2, in3), two select signals (sel0, sel1)\nOutputs: one output signal (out)\n\nYour module should implement the following functionality:\n\nWhen sel0 and sel1 are both equal to 0, the output signal should be equal to in0.\nWhen sel0 is equal to 0 and sel1 is equal to 1, the output signal should be equal to in1.\nWhen sel0 is equal to 1 and sel1 is equal to 0, the output signal should be equal to in2.\nWhen sel0 and sel1 are both equal to 1, the output signal should be equal to in3.\n\nTo implement the MUX, you should use Verilog code to create a case statement that determines the output signal based on the values of sel0 and sel1. \nYou should then use this case statement to connect the inputs to the output signal.", "output": "module MUX (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel0,\n  input sel1,\n  output out\n);\n\n  // Implement the 4:1 MUX using a case statement\n  always @(*) begin\n    case ({sel1, sel0})\n      2'b00: out = in0;\n      2'b01: out = in1;\n      2'b10: out = in2;\n      2'b11: out = in3;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that performs a bitwise XOR operation on two input signals and outputs the result. The module should be named \"my_xor\" and should have the following ports:\n\n- `out`: Output signal that holds the result of the XOR operation.\n- `in1`: First input signal.\n- `in2`: Second input signal.\n\nYour module should be designed to work with 1-bit signals only, and should be able to handle any combination of input values (0 or 1).\n\nWrite a verilog module \"my_xor\" that implements the above functionality. Your module should be self-contained and should not rely on any external modules or libraries. Additionally, your module should be no longer than 200 lines of verilog code.\n\n", "output": "module my_xor(\n    out,\n    in1,\n    in2\n);\n\n    output out;\n    input in1, in2;\n\n    wire w1, w2, w3, w4;\n\n    assign w1 = ~in1;\n    assign w2 = ~in2;\n    assign w3 = in1 & w2;\n    assign w4 = w1 & in2;\n    assign out = w3 | w4;\n\nendmodule"}
{"instruction": "\n\nIn digital circuits, a multiplexer is a device that selects one of several input signals and forwards the selected input to a single output line. The selection of the input signal is controlled by a set of input lines called the select lines. The output of the multiplexer is the selected input signal.\n\nIn this problem, you are required to implement a 2:1 multiplexer using Verilog. The module should have three inputs: `D0`, `D1`, and `ctrl`, and one output `S`. The `ctrl` input is a single bit that selects which input to pass to the output. If `ctrl` is 0, the `D0` input should be passed to `S`, and if `ctrl` is 1, the `D1` input should be passed to `S`.\n\nYou should write a Verilog module that implements the 2:1 multiplexer, using the provided code snippet as a starting point. Your implementation should be contained within the module `Multiplexer_AC__parameterized65`. The module should have the following ports:\n\n- `ctrl` : input, single bit\n- `D0` : input, single bit\n- `D1` : input, single bit\n- `S` : output, single bit\n\nYour module should be self-contained, meaning that it should not rely on any other modules or external libraries. The implementation should be within 200 lines of Verilog code.\n\n", "output": "module Multiplexer_AC__parameterized65\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  wire [0:0]S;\n\n  assign S = ctrl ? D1 : D0;\nendmodule"}
{"instruction": "\nYou have been tasked with designing a verilog module that performs a full adder operation. The module should have the following input and output ports:\n\nInputs:\n- A (1-bit)\n- B (1-bit)\n- CI (1-bit)\n\nOutputs:\n- SUM (1-bit)\n- COUT (1-bit)\n\nThe module should implement the following logic:\n\n- The SUM output should be the sum of A, B, and CI.\n- The COUT output should be the carry-out bit of the addition operation.\n\nYou should write a verilog module that implements this logic. Your module should be self-contained and should not rely on any external modules or libraries. The module should be no more than 200 lines of verilog code.\n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input CI,\n    output reg SUM,\n    output reg COUT\n);\n\n    always @ (A or B or CI) begin\n        SUM = A ^ B ^ CI;\n        COUT = (A & B) | (B & CI) | (CI & A);\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that will perform a specific set of operations on input signals. The module should be named `Bitwise_Or` and should have the following inputs and outputs:\n\n- `in0`, `in1`: two 32-bit input signals\n- `enable`: a single-bit input signal that indicates whether the module should perform the bitwise OR operation on the input signals\n- `out`: a 32-bit output signal that contains the result of the bitwise OR operation\n\nThe `Bitwise_Or` module should perform the bitwise OR operation on the `in0` and `in1` signals when the `enable` signal is high. When the `enable` signal is low, the `out` signal should be set to all zeros.\n\nYou should ensure that the module is designed to be synthesizable and meets the following requirements:\n\n- The module should be designed using only combinational logic\n- The module should not use any sequential logic\n- The module should not use any other modules or external libraries\n\n", "output": "module Bitwise_Or (\n  input [31:0] in0,\n  input [31:0] in1,\n  input enable,\n  output reg [31:0] out\n);\n  always @(*) begin\n    if (enable) begin\n      out = in0 | in1;\n    end else begin\n      out = 32'b0;\n    end\n  end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a module that designs a 4-bit synchronous counter with a parallel load option. The module should have three inputs: a clock input, a reset input, and a parallel load input. The module should have a 4-bit output representing the current count. If the parallel load input is high, the counter should load the value of a 4-bit input (load_input) into the counter. If the parallel load input is low, the counter should increment on every rising edge of the clock input. If the reset input is high, the counter should reset to zero. The module should be named \"sync_counter_4bit\" and have the following IO definition:", "output": "module sync_counter_4bit (\n  input clk,\n  input reset,\n  input parallel_load,\n  input [3:0] load_input,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0;\n    end else if (parallel_load) begin\n      count <= load_input;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "As a professional Verilog designer, you need to implement a 4-bit shift register module that can shift bits to the left or right direction based on the shift direction input (0 for left, 1 for right) and clock input. Use a pipelined structure to implement the module instead of a sequential always block.", "output": "module shift_register (\n    input [3:0] in,\n    input shift_dir,\n    input clk,\n    output reg [3:0] out\n);\n\nreg [3:0] pipeline [0:1];\n\nalways @(posedge clk) begin\n    pipeline[0] <= in;\n    if (shift_dir == 0) begin\n        pipeline[1] <= pipeline[0] << 1;\n    end else begin\n        pipeline[1] <= pipeline[0] >> 1;\n    end\nend\n\nassign out = pipeline[1];\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 4-input AND gate with an enable input. The module should have the following ports:\n- `in1`, `in2`, `in3`, `in4`: 4-bit input signals\n- `en`: enable input signal\n- `out`: 1-bit output signal\n\nThe module should output the logical AND of all four input signals only when the enable input is high. When the enable input is low, the output should be zero.\n\nWrite a Verilog module that implements this functionality. Your module should only use combinational logic and should be no longer than 200 lines of code.\n\n", "output": "module and_gate_with_enable (\n    in1,\n    in2,\n    in3,\n    in4,\n    en,\n    out\n);\n\n  input [3:0] in1, in2, in3, in4;\n  input en;\n  output reg out;\n\n  always @ (*) begin\n    if (en) begin\n      out = (in1 & in2 & in3 & in4);\n    end else begin\n      out = 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a combinational logic circuit. The circuit has five input ports and one output port. The input ports are named A1_N, A2_N, B1, B2, and the output port is named Y. The module should be named \"logic_circuit\". \n\nThe circuit should take the four input signals A1_N, A2_N, B1, and B2 and output Y according to the following truth table:\n\n| A1_N | A2_N | B1 | B2 | Y |\n|------|------|----|----|---|\n| 0    | 0    | 0  | 0  | 1 |\n| 0    | 0    | 0  | 1  | 0 |\n| 0    | 0    | 1  | 0  | 0 |\n| 0    | 0    | 1  | 1  | 1 |\n| 0    | 1    | 0  | 0  | 0 |\n| 0    | 1    | 0  | 1  | 1 |\n| 0    | 1    | 1  | 0  | 1 |\n| 0    | 1    | 1  | 1  | 0 |\n| 1    | 0    | 0  | 0  | 0 |\n| 1    | 0    | 0  | 1  | 1 |\n| 1    | 0    | 1  | 0  | 1 |\n| 1    | 0    | 1  | 1  | 0 |\n| 1    | 1    | 0  | 0  | 1 |\n| 1    | 1    | 0  | 1  | 0 |\n| 1    | 1    | 1  | 0  | 0 |\n| 1    | 1    | 1  | 1  | 1 |\n\nYou should make sure that the module only contains combinational logic - no sequential logic or state machines are allowed. The module should be contained within 200 lines of Verilog code.\n\n", "output": "module logic_circuit (\n    output Y   ,\n    input  A1_N,\n    input  A2_N,\n    input  B1  ,\n    input  B2  \n);\n\n    assign Y = (!A1_N & !A2_N & !B1 & !B2) | (!A1_N & !A2_N & !B1 & B2) | (!A1_N & !A2_N & B1 & !B2) | (!A1_N & !A2_N & B1 & B2) | (!A1_N & A2_N & !B1 & B2) | (!A1_N & A2_N & B1 & !B2) | (!A1_N & A2_N & B1 & B2) | (A1_N & !A2_N & B1 & !B2) | (A1_N & !A2_N & B1 & B2) | (A1_N & A2_N & !B1 & !B2) | (A1_N & A2_N & !B1 & B2) | (A1_N & A2_N & B1 & !B2) | (A1_N & A2_N & B1 & B2);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in two inputs, a 4-bit binary number A and a 4-bit binary number B, and outputs a 4-bit binary number C. The output C should be the result of adding A and B, but if the sum exceeds 9, the output should instead be the result of subtracting 6 from the sum. \n\nDesign the verilog module to solve this problem. \n\n", "output": "module binary_add_subtract(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] C\n);\n\n    wire [4:0] sum;\n\n    assign sum = A + B;\n\n    always @(*) begin\n        if (sum > 9) begin\n            C = sum - 6;\n        end else begin\n            C = sum;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 3-bit up-down counter. The counter should increment or decrement by 1 based on the state of the up_down input. If up_down is high, the counter should increment by 1. If up_down is low, the counter should decrement by 1. If the counter reaches its maximum value (7), it should wrap around to 0 and continue counting. If the counter reaches its minimum value (0), it should wrap around to 7 and continue counting.", "output": "module up_down_counter (\n  input clk,\n  input reset,\n  input up_down,\n  output reg [2:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    count <= 0;\n  end else begin\n    if (up_down) begin\n      if (count == 7) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end else begin\n      if (count == 0) begin\n        count <= 7;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 4 inputs `A1_N`, `A2_N`, `B1`, `B2` and outputs a single bit `X`. The module should implement the following logic function:\n\n```\nX = (NOT A1_N AND NOT A2_N) AND (B1 OR B2)\n```\n\nYou need to design a module that implements this logic function using only one module within 200 lines of verilog code. \n\nAssume the inputs are valid and do not require any additional error checking. The output should be a single bit that is either 0 or 1.\n\n", "output": "module my_module (\n    input A1_N,\n    input A2_N,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire nand_out;\n    wire or_out;\n    wire and_out;\n\n    nand nand_gate (\n        .a(A1_N),\n        .b(A2_N),\n        .o(nand_out)\n    );\n\n    or or_gate (\n        .a(B1),\n        .b(B2),\n        .o(or_out)\n    );\n\n    and and_gate (\n        .a(nand_out),\n        .b(or_out),\n        .o(and_out)\n    );\n\n    assign X = and_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a computer system's video in subsystem edge detection. The module should be able to detect the edges in the input video signal and output the detected edges.\n\nThe module should have the following inputs:\n- `in_data`: a 10-bit input signal representing the video data\n- `clk`: the clock signal\n- `rst`: the reset signal\n\nThe module should have the following outputs:\n- `out_data`: a 10-bit output signal representing the detected edges in the input video\n\nThe edge detection algorithm should work as follows:\n- The module should compare the current input value with the previous input value\n- If the difference between the current and previous input value is greater than a certain threshold, the module should output a 1 to indicate an edge has been detected. Otherwise, the module should output a 0.\n\nThe threshold value should be configurable and should be set by a 4-bit input signal `threshold`. The threshold value should be in the range of 0 to 1023.\n\nDesign a Verilog module that implements the above edge detection algorithm.\n\n", "output": "module edge_detection(\n  input wire clk,\n  input wire rst,\n  input wire [9:0] in_data,\n  input wire [3:0] threshold,\n  output reg [9:0] out_data\n);\n\n  reg [9:0] prev_data;\n  reg [9:0] diff;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      prev_data <= 0;\n      out_data <= 0;\n    end else begin\n      diff <= in_data - prev_data;\n      prev_data <= in_data;\n      if (diff > threshold) begin\n        out_data <= 10'h3FF;\n      end else begin\n        out_data <= 0;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are given a verilog module `counter` that counts from 0 to a given value `N` and then resets back to 0. The module has the following inputs and outputs:\n- `clk`: a clock signal\n- `rst`: a synchronous reset signal\n- `N`: the maximum count value\n- `enable`: an enable signal that starts the counter when high\n- `count`: the current count value, represented as an output\n\nImplement the `counter` module using the following guidelines:\n- Use a synchronous reset that sets the count value to 0 when `rst` is high\n- When `enable` is high, increment the count value on every rising edge of `clk`\n- When the count value reaches `N`, reset it back to 0 on the next rising edge of `clk`\n- The count value should be represented using the minimum number of bits required to represent all values from 0 to `N`\n\n", "output": "module counter(\n    input clk,\n    input rst,\n    input [31:0] N,\n    input enable,\n    output reg [31:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n        end else if (enable) begin\n            if (count == N) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module named `main` with a parameter `v771499` and three signals `vclk`, `v36f80c`, and `w5`. The module also instantiates three other modules named `v6809d2`, `vda0861`, and `vd63ed7`. Your task is to implement the `v1b8919` module that takes `w3` and `w2` as inputs and produces `v36f80c` as output.\n\nThe `v6809d2` module has an input `v6dda25` that is connected to `w5`, an output `w1` that is connected to the input of the `vda0861` module, and an output `vc4e0ba` that is connected to the input of the `vd63ed7` module. The `vda0861` module has an input `vffb58f` that is connected to the output of the `v6809d2` module. The `vd63ed7` module has an input `vcc8c7c` that is connected to the output of the `v6809d2` module and an output `v1045ee` that is connected to the input of the `v1b8919` module.\n\nThe `v1b8919` module should implement the following logic:\n- If `w3` is equal to 0, `v36f80c` should be equal to 0.\n- If `w3` is equal to 1, `v36f80c` should be equal to the 2nd bit of `w2`.\n- If `w3` is equal to 2, `v36f80c` should be equal to the 1st bit of `w2`.\n- If `w3` is equal to 3, `v36f80c` should be equal to the 0th bit of `w2`.\n- If `w3` is equal to 4, `v36f80c` should be equal to the 7th bit of `w4`.\n- If `w3` is equal to 5, `v36f80c` should be equal to the 6th bit of `w4`.\n- If `w3` is equal to 6, `v36f80c` should be equal to the 5th bit of `w4`.\n- If `w3` is equal to 7, `v36f80c` should be equal to the 4th bit of `w4`.\n\nYou are not allowed to modify any of the existing modules or signals, only implement the `v1b8919` module.\n\nWrite the code for the `v1b8919` module within 200 lines of Verilog code.\n\n", "output": "module v1b8919 (\n  input [2:0] w3,\n  input [2:0] w2,\n  output reg [2:0] v36f80c\n);\n\n  always @(*) begin\n    case (w3)\n      0: v36f80c = 3'b000;\n      1: v36f80c = {1'b0, w2[2], 1'b0};\n      2: v36f80c = {1'b0, w2[1], w2[0]};\n      3: v36f80c = {1'b0, w2[0], 1'b0};\n      4: v36f80c = {1'b0, 1'b0, 1'b0} & w4;\n      5: v36f80c = {1'b0, 1'b0, w4[6]};\n      6: v36f80c = {1'b0, 1'b0, w4[5]};\n      7: v36f80c = {1'b0, 1'b0, w4[4]};\n      default: v36f80c = 3'b000;\n    endcase\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-to-1 multiplexer with an enable input. The module should have four 8-bit data inputs and one 8-bit output. When the enable input is high, the output should be equal to the selected input based on the 2-bit select input. When the enable input is low, the output should be set to 0.", "output": "module mux (\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    input [1:0] sel,\n    input en,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = en ? in0 : 8'b0;\n        2'b01: out = en ? in1 : 8'b0;\n        2'b10: out = en ? in2 : 8'b0;\n        2'b11: out = en ? in3 : 8'b0;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements an asynchronous reset release circuit. \nAn asynchronous reset release circuit is a digital circuit that releases the reset signal asynchronously, which means that the reset signal can be released at any time, regardless of the clock signal.\nYour module should have the following inputs and outputs:\n\nInputs: \n- rst: asynchronous reset signal\n- clk: clock signal\nOutputs: \n- out: output signal\n\nYour module should implement the following functionality:\n- When the reset signal is asserted, the output signal should be set to 0.\n- When the reset signal is released, the output signal should be set to 1, and it should remain at 1 until the next reset signal is asserted.\n- The circuit should be sensitive to the clock signal. The output signal should only change on the rising edge of the clock signal.\n\nTo implement the asynchronous reset release circuit, you should use Verilog code to define the behavior of the output signal based on the input signals. \nYou should use an edge detector to detect the rising edge of the clock signal and synchronize the output signal with the clock signal. \nYou should also use a latch to hold the output signal at 1 after the reset signal is released.", "output": "module async_reset_release (\n  input rst,\n  input clk,\n  output reg out\n);\n\n  reg rst_sync;\n  reg out_latch;\n\n  always @(posedge clk) begin\n    rst_sync <= rst;\n    if (rst_sync) begin\n      out <= 0;\n      out_latch <= 0;\n    end else begin\n      out_latch <= 1;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (!rst_sync) begin\n      out <= out_latch;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit adder/subtractor. The module should have three inputs: A, B, and sub (1 for subtraction, 0 for addition). The module should have two outputs: sum (the result of the addition/subtraction) and overflow (1 if the result overflows the 4-bit range, 0 otherwise).", "output": "module add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] sum,\n    output overflow\n);\n\n    reg [4:0] temp_sum;\n    reg [3:0] temp_A;\n    reg [3:0] temp_B;\n    reg temp_sub;\n\n    assign overflow = temp_sum[4];\n\n    always @(*) begin\n        temp_A = A;\n        temp_B = B;\n        temp_sub = sub;\n\n        if (temp_sub == 1'b0) begin\n            temp_sum = temp_A + temp_B;\n        end\n        else begin\n            temp_sum = temp_A - temp_B;\n        end\n    end\n\n    assign sum = temp_sum[3:0];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a pipeline register. \nA pipeline register is a type of digital circuit that is used to synchronize data between different stages of a pipeline. \nThe inputs to the circuit are connected to the output of the previous stage, and the outputs are connected to the input of the next stage. \nThe pipeline register is used to hold the data for one clock cycle, to ensure that the next stage has a stable input.\n\nYour module should have the following inputs and outputs:\n\nInputs: a data signal (data_in) and a clock signal (clk)\nOutputs: a data signal (data_out)\n\nYour module should implement the following functionality:\n\nThe circuit should have a pipeline register that synchronizes the data_in signal with the clock signal.\nThe data_in signal should be latched on the rising edge of the clock signal.\nThe data_out signal should be the same as the data_in signal, delayed by one clock cycle.\nTo implement the pipeline register, you should use Verilog code to define the flip-flop that latches the data_in signal on the rising edge of the clock signal. \nYou should also use the flip-flop to delay the data_in signal by one clock cycle, to produce the data_out signal.", "output": "module pipeline_register (\n  input data_in,\n  input clk,\n  output data_out\n);\n\n  reg [31:0] data_reg; // register to hold the data\n  always @(posedge clk) begin\n    data_reg <= data_in; // latch the data_in signal on the rising edge of the clock\n  end\n  \n  reg [31:0] data_delayed; // register to hold the delayed data\n  always @(posedge clk) begin\n    data_delayed <= data_reg; // delay the data_in signal by one clock cycle\n  end\n  \n  assign data_out = data_delayed; // assign the delayed data to the output\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a single-port RAM module in Verilog. The module should have the following ports and parameters:\n\n- `addr`: an input port that specifies the memory address to read from or write to.\n- `data`: an input port that specifies the data to write to memory.\n- `we`: an input port that specifies whether to write to memory (`we = 1`) or read from memory (`we = 0`).\n- `out`: an output port that provides the data read from memory.\n- `clock`: an input port that provides the clock signal.\n\nThe module should have the following parameters:\n\n- `addr_width`: the number of bits required to represent the memory address.\n- `data_width`: the number of bits required to represent the data.\n- `mem_depth`: the depth of the memory, calculated as `2^addr_width`.\n\nThe module should use a single clock edge to perform both read and write operations. The memory should be initialized to all zeros.\n\nWrite a Verilog module that implements the single-port RAM with the above requirements.\n\n", "output": "module single_port_ram(\n  input clock,\n  input [addr_width-1:0] addr,\n  input [data_width-1:0] data,\n  input we,\n  output reg [data_width-1:0] out\n);\n\n  parameter addr_width = 8;\n  parameter data_width = 8;\n  parameter mem_depth = 2**addr_width;\n\n  reg [data_width-1:0] Mem [0:mem_depth-1];\n\n  always @(posedge clock) begin\n    if (we) begin\n      Mem[addr] <= data;\n    end\n    out <= Mem[addr];\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a D flip-flop using the sky130_fd_sc_ls__sedfxtp_1 library. The module should have one output, Q, and three inputs: CLK, D, and DE. The D input should be the data input, CLK should be the clock input, and DE should be the data enable input. When DE is high, the D input should be transferred to the output Q on the rising edge of CLK. When DE is low, the output Q should remain unchanged. The module should be named \"dff_sky130_fd_sc_ls\".\n\n", "output": "module dff_sky130_fd_sc_ls (\n    output Q,\n    input CLK,\n    input D,\n    input DE\n);\n\n    reg Q_reg;\n\n    always @(posedge CLK) begin\n        if (DE) begin\n            Q_reg <= D;\n        end\n    end\n\n    assign Q = Q_reg;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit counter with asynchronous reset. The module should have a 4-bit output (Q) that counts from 0 to 15. The counter should increment on the positive edge of the clock signal (clk). The counter should reset to 0 when the asynchronous reset signal (reset) is asserted.", "output": "module counter_4bit (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            Q <= 4'b0000;\n        end\n        else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Design a module that implements a 2-input XOR gate using only NAND gates. The module should have two input signals, a and b, and one output signal, out.", "output": "module xor_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire w1, w2, w3, w4;\n\nnand n1(w1, a, b);\nnand n2(w2, a, w1);\nnand n3(w3, b, w1);\nnand n4(out, w2, w3);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in three inputs A1, A2, A3, and two inputs B1, C1. The module should output a signal Y, which is determined by the following rules:\n- If A1 is greater than or equal to A2, and A1 is greater than or equal to A3, then Y should be equal to B1.\n- If A2 is greater than or equal to A1, and A2 is greater than or equal to A3, then Y should be equal to C1.\n- If A3 is greater than or equal to A1, and A3 is greater than or equal to A2, then Y should be equal to B1 XOR C1.\n\nAdditionally, the module should have four power inputs: VPB, VPWR, VGND, and VNB.\n\nDesign this module in verilog and name it `signal_selector`.\n\n", "output": "module signal_selector (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input C1,\n    output Y,\n    input VPB,\n    input VPWR,\n    input VGND,\n    input VNB\n);\n\n    wire sel1, sel2;\n\n    assign sel1 = (A1 >= A2) && (A1 >= A3);\n    assign sel2 = (A2 >= A1) && (A2 >= A3);\n\n    always @(*) begin\n        if (sel1) begin\n            Y = B1;\n        end else if (sel2) begin\n            Y = C1;\n        end else begin\n            Y = B1 ^ C1;\n        end\n    end\n\nendmodule"}
{"instruction": "Design a system that combines a 3-bit shift register and a D flip-flop in Verilog. The shift register should have one input and one output port, both 1-bit wide, with the output being the value of the input after it has been shifted through the register. The D flip-flop should have one input and one output port, both 1-bit wide, with the output being the value of the input after the negative edge of the clock. The system should include a control logic module that selects between the output of the shift register and the output of the D flip-flop, based on a select input. The output of the selected module should be the output of the system.", "output": "module top_module ( input clk, input d, input select, output q );\n  \n  reg [2:0] shift_reg;\n  reg d_ff;\n\n  always @(posedge clk) begin\n    shift_reg <= {shift_reg[1:0], d};\n    d_ff <= d;\n  end\n\n  assign q = select ? d_ff : shift_reg[0];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that performs multiplication of two unsigned integers. The module should take in two inputs, `a` and `b`, both unsigned integers, and output their product `p`. The module should also have an input `ce` that enables the module to perform the multiplication only when it is high. The module should be clocked by a positive edge-triggered clock signal `clk`.\n\nYou are given a code snippet for a module `nfa_accept_samples_generic_hw_mul_8ns_6ns_14_2_MAC2S_1` that partially implements the required functionality. The `a` and `b` inputs are 8 and 6 bits wide respectively, and the output `p` is 14 bits wide. The module also instantiates a wire `tmp_product` that stores the result of the multiplication of `a` and `b`. \n\nYour task is to complete the implementation of the `nfa_accept_samples_generic_hw_mul_8ns_6ns_14_2_MAC2S_1` module such that it meets the requirements mentioned above. You may assume that the input values will always be within the range of the defined bit widths.\n\nWrite verilog code for the `nfa_accept_samples_generic_hw_mul_8ns_6ns_14_2_MAC2S_1` module that performs multiplication of the two inputs and outputs their product only when the `ce` input is high.\n\n", "output": "module nfa_accept_samples_generic_hw_mul_8ns_6ns_14_2_MAC2S_1(clk, ce, a, b, p);\n    input clk;\n    input ce;\n    input [8-1:0] a;\n    input [6-1:0] b;\n    output [14-1:0] p;\n    reg [14-1:0] p;\n    wire [14-1:0] tmp_product;\n\n    assign tmp_product = a * b;\n\n    always @(posedge clk) begin\n        if (ce) begin\n            p <= tmp_product;\n        end\n    end\nendmodule"}
{"instruction": "\n\nIn digital circuit design, a NAND gate is a logic gate that produces a low output (logic 0) only if all its inputs are high (logic 1). Otherwise, it produces a high output (logic 1). In this problem, you are required to design a Verilog module for a 4-input NAND gate.\n\nYou should create a module named `nand4` with the following interface:\n\n```\nmodule nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n```\n\nThe inputs A, B, C, and D are single-bit binary signals, and the output Y is a single-bit binary signal. The module should implement the logic of a 4-input NAND gate, as described above.\n\nYou are not allowed to use any built-in Verilog operators or functions to implement the NAND gate. You should only use basic logic gates such as AND, OR, NOT, and XOR to implement the NAND gate.\n\nYour Verilog module should be self-contained, meaning that it should not require any external modules or libraries. Your module should be solvable within 200 lines of Verilog code.\n\n", "output": "module nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\nwire AB, CD, ABCD;\nnot (AB, A & B);\nnot (CD, C & D);\nnot (ABCD, AB & CD);\nnot (Y, ABCD);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 32-bit input signal `data_in` and outputs a 16-bit signal `data_out`. The output signal should be the lower 16 bits of the input signal multiplied by a constant value of 3. The module should also have a clock input `clk` and a reset input `rst`. On the rising edge of the clock, the module should sample the input data and update the output accordingly. On the falling edge of the reset signal, the output should be set to 0.\n\nDesign a verilog module that meets these specifications.\n\n\n", "output": "module multiplier_module (\n  input        clk,\n  input        rst,\n  input  [31:0] data_in,\n  output [15:0] data_out\n);\n\n  reg     [31:0] data_reg;\n  reg     [15:0] data_out_reg;\n  parameter      multiplier = 3;\n\n  always @(posedge clk) begin\n    if (rst == 1'b0) begin\n      data_out_reg <= 16'b0;\n    end else begin\n      data_reg <= data_in;\n      data_out_reg <= multiplier * data_reg[15:0];\n    end\n  end\n\n  assign data_out = data_out_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit binary counter with a synchronous reset. The module has three ports, a clock input, a synchronous reset input, and a 4-bit output signal. The clock input is used to synchronize the module's operations. The synchronous reset input is used to reset the counter to zero. The 4-bit output signal is used to indicate the current count value. The module contains a register, count_reg, which is used to store the current count value. The module is always triggered on the rising edge of the clock signal. When triggered, the module increments the count_reg by one. If the synchronous reset is high, the count_reg is reset to zero. The 4-bit output signal is assigned the current value of the count_reg.", "output": "module binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  reg [3:0] count_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_reg <= 4'b0000;\n    end\n    else begin\n      count_reg <= count_reg + 1;\n    end\n  end\n\n  assign count = count_reg;\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module for a digital circuit that implements a D flip-flop with asynchronous reset. The module should have the following input and output ports:\n\n- `D`: input port for the data signal\n- `R`: input port for the reset signal (active low)\n- `CLK`: input port for the clock signal\n- `Q`: output port for the output signal\n\nThe module should implement the following behavior:\n\n- When the reset signal `R` is asserted (low), the output `Q` should be set to 0, regardless of the value of the data input `D`.\n- When the reset signal `R` is de-asserted (high), the output `Q` should follow the input `D` on the rising edge of the clock signal `CLK`.\n\nYou should implement this module using only basic logic gates (AND, OR, NOT, etc.) and no pre-built flip-flop components. Assume that the input signals are glitch-free and that the clock signal is a periodic square wave with a 50% duty cycle.\n\n", "output": "module d_ff_async_reset (\n    input D,\n    input R,\n    input CLK,\n    output Q\n);\n\n    reg q;\n\n    always @(posedge CLK) begin\n        if (!R) begin\n            q <= 0;\n        end else begin\n            q <= D;\n        end\n    end\n\n    assign Q = q;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit counter with a synchronous reset and enable signal. The counter should increment on the rising edge of the clock signal, and the enable signal should be used to enable or disable the counting operation. The module should have three ports, a clock input, a reset input, an enable input, and a 4-bit output signal. When the reset input is high, the output signal should be set to 0. When the enable input is high, the counter should increment on each rising edge of the clock signal. When the enable input is low, the counter should hold its current value.", "output": "module counter_4bit (\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 4'b0000;\n  end else if (enable) begin\n    count <= count + 4'b0001;\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 2-input NOR gate with an enable signal. The module has the following inputs and outputs:\n\n- `in1` (input): a single bit input signal\n- `in2` (input): a single bit input signal\n- `en` (input): a single bit enable signal\n- `out` (output): a single bit output signal\n\nThe module should implement the following behavior:\n\n- If `en` is 0, `out` should be 0 regardless of the values of `in1` and `in2`.\n- If `en` is 1, `out` should be the NOR of `in1` and `in2`.\n\nYou should implement the module in Verilog, making sure that it can be synthesized and simulated correctly. Your implementation should be contained within a single module, and should not exceed 200 lines of code.\n\n", "output": "module nor_gate_with_enable (\n    input in1,\n    input in2,\n    input en,\n    output out\n);\n\nreg out_reg;\n\nalways @(*) begin\n    if (en == 1'b0) begin\n        out_reg = 1'b0;\n    end else begin\n        out_reg = ~(in1 | in2);\n    end\nend\n\nassign out = out_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a D flip-flop with asynchronous clear and clock enable. The module should be named \"dff_ce_clr\" and should have the following inputs and outputs:\n\n- Input \"clk\": the clock signal, which is a single bit.\n- Input \"clr\": the asynchronous clear signal, which is a single bit. When this signal is high, the output of the flip-flop should be forced to 0, regardless of the value of the data input.\n- Input \"ce\": the clock enable signal, which is a single bit. When this signal is low, the output of the flip-flop should be held constant, regardless of the value of the data input.\n- Input \"d\": the data input, which is a single bit. This is the value that should be stored in the flip-flop when the clock edge arrives.\n- Output \"q\": the data output, which is a single bit. This is the value stored in the flip-flop.\n\nThe module should be implemented using only gates, registers, and other basic verilog constructs. You may not use any built-in flip-flop primitives or other pre-built modules.\n\nYour module should behave according to the following truth table:\n\n```\n  clk | clr | ce |  d  ||  q\n------+-----+----+----++----\n  0   |  0  | 1  |  x ||  q\n  1   |  0  | 1  |  d ||  d\n  1   |  1  | 1  |  x ||  0\n  1   |  0  | 0  |  x ||  q\n```\n\nIn other words:\n- When the clock enable signal is low, the output of the flip-flop should be held constant at its previous value, regardless of the value of the data input.\n- When the clock enable signal is high, the output of the flip-flop should be updated on the rising edge of the clock, based on the value of the data input.\n- When the asynchronous clear signal is high, the output of the flip-flop should be forced to 0, regardless of the value of the data input.\n\n", "output": "module dff_ce_clr(clk, clr, ce, d, q);\n\n  input clk, clr, ce, d;\n  output q;\n  reg q;\n\n  always @(posedge clk)\n    if (clr)\n      q <= 1'b0;\n    else if (ce)\n      q <= d;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two 8-bit inputs and produces their sum. The module should also output a carry bit. The design should be optimized for minimum hardware usage.\n\nWrite a Verilog module that implements the following circuit:\n\n```\n         +--------+\n  A[7:0] |        |\n  B[7:0] |  ADDER |\n  C[7:0] |        |\n  CARRY  |        |\n         +--------+\n```\n\nThe module should have the following inputs and outputs:\n- `A`: an 8-bit input\n- `B`: an 8-bit input\n- `C`: an 8-bit output representing the sum of `A` and `B`\n- `CARRY`: a single bit output representing the carry bit\n\nAssume that the inputs are valid and that overflow will not occur.\n\n", "output": "module adder (\n    input  [7:0] A,\n    input  [7:0] B,\n    output [7:0] C,\n    output       CARRY\n);\n\n  wire [7:0] sum;\n  wire       carry;\n\n  assign {carry, sum} = A + B;\n\n  assign CARRY = carry;\n  assign C    = sum;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that generates a PWM signal with a variable duty cycle. The module should have two inputs: a clock signal and a duty cycle value. The duty cycle value is a 8-bit unsigned integer and represents the percentage of time the output signal should be high. The module should have one output: the PWM signal.\n\nDesign the module and write the verilog code for it. Assume that the clock signal is a 50 MHz clock.\n\n", "output": "module pwm_generator (\n  input clk,\n  input [7:0] duty_cycle,\n  output reg pwm\n);\n\nreg [31:0] counter = 0;\n\nalways @(posedge clk) begin\n  if (counter < 200) begin\n    pwm <= 1'b1;\n  end else begin\n    pwm <= 1'b0;\n  end\n  \n  if (counter == 255) begin\n    counter <= 0;\n  end else begin\n    counter <= counter + 1;\n  end\nend\n\nalways @(*) begin\n  counter = (duty_cycle * 256) / 100;\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 32-bit signed number and outputs its absolute value. Use behavioral modeling to implement the module.", "output": "module absolute_value (\n    input signed [31:0] in,\n    output reg signed [31:0] out\n);\n\n    always @(*) begin\n        if (in < 0) begin\n            out = -in;\n        end else begin\n            out = in;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a clock gate using Verilog. The module should take in two input signals, `clk` and `enable`, and one additional input signal, `scan_enable`, which is active only during scan shifting. The module should output a single signal, `gclk`, which is a gated version of the `clk` signal.\n\nThe `enable` signal should be latched and ANDed with the `clk` signal to produce the `gclk` signal. During scan shifting, the clock gate should remain enabled regardless of the value of the `enable` input signal.\n\nWrite a Verilog module, named `omsp_clock_gate`, that implements this clock gating functionality. Your module should be self-contained and should not rely on any other modules. Your solution should be within 200 lines of Verilog code.\n\n", "output": "module omsp_clock_gate (\n  input clk,           // Clock\n  input enable,        // Clock enable\n  input scan_enable,   // Scan enable (active during scan shifting)\n  output gclk          // Gated clock\n);\n\n  wire enable_in = (enable | scan_enable);\n\n  reg enable_latch;\n\n  always @(posedge clk or posedge enable_in) begin\n    if(enable_in) begin\n      enable_latch <= enable;\n    end\n  end\n\n  assign gclk = enable_latch & clk;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a module in Verilog that emulates a register file with 32 registers. The module should have the following inputs:\n\n- `clk`: a clock signal\n- `wen`: a write enable signal\n- `waddr`: a 6-bit write address\n- `raddr1`: a 6-bit read address for the first output\n- `raddr2`: a 6-bit read address for the second output\n- `wdata`: a 32-bit write data\n\nThe module should have the following outputs:\n\n- `rdata1`: a 32-bit output corresponding to the value stored in the register specified by `raddr1`\n- `rdata2`: a 32-bit output corresponding to the value stored in the register specified by `raddr2`\n\nThe module should store the 32 registers in an array of 32 32-bit registers called `regs`. The module should update the value of the register specified by `waddr` with the value of `wdata` on the positive edge of the clock if `wen` is high. The module should output the value of the register specified by `raddr1` on `rdata1` and the value of the register specified by `raddr2` on `rdata2` at all times.\n\nYou should implement this module in Verilog within 200 lines of code.\n\n", "output": "module register_file (\n    input clk, wen,\n    input [5:0] waddr,\n    input [5:0] raddr1,\n    input [5:0] raddr2,\n    input [31:0] wdata,\n    output reg [31:0] rdata1,\n    output reg [31:0] rdata2\n);\n\n    reg [31:0] regs [0:31];\n\n    always @(posedge clk) begin\n        if (wen) begin\n            regs[waddr] <= wdata;\n        end\n    end\n\n    assign rdata1 = regs[raddr1];\n    assign rdata2 = regs[raddr2];\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that takes in two 8-bit inputs, A and B, and outputs the sum of the two inputs. The module should also include a 1-bit output, C, which should be set to 1 if the sum of A and B results in an overflow. An overflow occurs when the sum of two signed numbers exceeds the maximum value that can be represented by the number of bits used to represent them. Assume that the inputs are signed two's complement numbers, and that the output sum and overflow bit are also signed two's complement numbers.\n\nDesign a verilog module that meets the above specifications. \n\n", "output": "module adder (input signed [7:0] A, input signed [7:0] B, output signed [7:0] sum, output reg C);\n\n    always @(*) begin\n        sum = A + B;\n        if (sum > 127 || sum < -128)\n            C = 1;\n        else\n            C = 0;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in a 4-bit binary input and outputs its two's complement. The module should be able to handle both positive and negative numbers. \n\nThe two's complement of a binary number is obtained by inverting all the bits (changing 0s to 1s and 1s to 0s) and adding 1 to the result. For example, the two's complement of 0101 is 1011.\n\nYour module should have the following inputs and outputs:\n\nInputs:\n- `in` (4-bit binary number)\n\nOutputs:\n- `out` (4-bit two's complement binary number)\n\nYour module should be named `twos_complement`.\n\n", "output": "module twos_complement(\n    input [3:0] in,\n    output [3:0] out\n);\n\nwire [3:0] inv;\nwire [3:0] add_one;\n\n// invert all bits of input\nassign inv = ~in;\n\n// add 1 to inverted input\nassign add_one = inv + 4'b0001;\n\n// assign result to output\nassign out = add_one;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a module that takes in a 4-bit input and outputs a 2-bit vector and a 2-bit scalar. The 2-bit vector output should be the two most significant bits of the input, and the 2-bit scalar output should be the two least significant bits of the input. Name the module \"vec_scal_converter\" and define the inputs and outputs as follows:", "output": "module vec_scal_converter (\n  input [3:0] vec,\n  output reg [1:0] outv,\n  output reg [1:0] outs\n);\n\n  always @(*) begin\n    outv = vec[3:2];\n    outs = vec[1:0];\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou have been hired to design a simple verilog module that implements a 4-bit counter. The counter should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `reset`: an active-high signal that resets the counter to 0\n- `enable`: an active-high signal that enables the counter to count\n\nOutputs:\n- `count`: a 4-bit output signal that represents the current count value\n\nThe counter should increment by 1 on each rising edge of the `clk` signal, as long as the `enable` signal is high. When the `reset` signal is high, the counter should be reset to 0.\n\nImplement the counter module in verilog and verify its functionality using a testbench.\n\n", "output": "module counter(clk, reset, enable, count);\n\n\tinput clk, reset, enable;\n\toutput reg [3:0] count;\n\n\talways@(posedge clk) begin\n\t\tif(reset == 1'b1) begin\n\t\t\tcount <= 4'b0000;\n\t\tend\n\t\telse if(enable == 1'b1) begin\n\t\t\tcount <= count + 1;\n\t\tend\n\tend\n\nendmodule\n\nmodule counter_tb();\n\n\treg clk, reset, enable;\n\twire [3:0] count;\n\n\tcounter dut(.clk(clk), .reset(reset), .enable(enable), .count(count));\n\n\tinitial begin\n\t\tclk = 0;\n\t\treset = 0;\n\t\tenable = 0;\n\t\t#10 reset = 1;\n\t\t#10 reset = 0;\n\t\t#10 enable = 1;\n\tend\n\n\talways #5 clk = ~clk;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that receives data from a UART (Universal Asynchronous Receiver-Transmitter) and sends it to another module. The UART module has six inputs and four outputs:\n\nInputs:\n- `baud_divisor`: A 16-bit input that determines the baud rate of the UART.\n- `clk`: A clock input.\n- `clk_en`: A clock enable input.\n- `reset_n`: A reset input.\n- `rx_char_ready`: A signal that indicates when a character is available to be read from the UART.\n- `rxd`: The data received from the UART.\n\nOutputs:\n- `source_rxd`: The data received from the UART, passed on to another module.\n\nThe module you design should be able to receive data from the UART and pass it on to another module. The module should have only one output, `source_rxd`, which is the same as the UART's `rxd` input.\n\nWrite a Verilog module that meets these requirements. Your module should be self-contained and not rely on any other modules. \n\n", "output": "module uart_receiver (\n  input [15:0] baud_divisor,\n  input clk,\n  input clk_en,\n  input reset_n,\n  input rx_char_ready,\n  input rxd,\n  output source_rxd\n);\n\n  reg [7:0] received_data;\n\n  always @(posedge clk) begin\n    if (reset_n == 0) begin\n      received_data <= 8'b0;\n    end else if (rx_char_ready == 1) begin\n      received_data <= rxd;\n    end\n  end\n\n  assign source_rxd = received_data;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a clock signal, an input signal `din`, and a reset signal `reset_n`. The module should have an output signal `dout`. The `din` signal should be passed through a D flip-flop and then assigned to `dout`. The module should be named `dffpipe`.\n\nWrite the verilog code for the `dffpipe` module.\n\n", "output": "module dffpipe (\n    input clk,\n    input din,\n    output dout,\n    input reset_n\n);\n\n    wire [0:0] wire_dffpipe_q;\n\n    niosII_system_altpll_0_dffpipe_l2c dffpipe (\n        .clock(clk),\n        .clrn(reset_n),\n        .d(din),\n        .q(wire_dffpipe_q)\n    );\n\n    assign dout = wire_dffpipe_q;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in four inputs and produces one output. The module should be named `four_to_one` and should have the following input and output ports:\n\n- `input [3:0] in`: a 4-bit input\n- `output out`: a single bit output\n\nThe module should implement the following logic:\n\n- If the input is equal to 0b0000 or 0b1111, the output should be 1.\n- If the input is equal to 0b0101 or 0b1010, the output should be 1.\n- Otherwise, the output should be 0.\n\nYou may use any verilog operators, modules, or constructs necessary to implement this logic.\n\n", "output": "module four_to_one(\n    input [3:0] in,\n    output out\n);\n\n    wire is_zero_or_fifteen = (in == 4'b0000) || (in == 4'b1111);\n    wire is_five_or_ten = (in == 4'b0101) || (in == 4'b1010);\n\n    assign out = is_zero_or_fifteen || is_five_or_ten;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a bus hold block.\nA bus hold block is a type of digital circuit that is used to avoid glitches in a bus signal caused by the changing state of the signal's inputs.\nYour module should have the following inputs and outputs:\n\nInputs: a bus signal (bus_in), a clock signal (clk), a reset signal (reset)\nOutputs: a bus signal (bus_out)\nThe module should also have the following parameters:\n\nn: the number of bits in the bus signal\nYour module should implement the following functionality:\n\nThe circuit should hold the value of the bus signal when the clock signal is low.\nWhen the clock signal goes high, the circuit should latch the value of the bus signal and hold it until the clock signal goes low again.\nThe circuit should also have a reset input that sets the output bus signal to 0 when it is active.\nTo implement the bus hold block, you should use Verilog code to define a D flip-flop that is triggered by the rising edge of the clock signal.\nThe input to the flip-flop should be the bus signal, and the output should be the output bus signal.\nYou should also use a multiplexer to select between the input bus signal and the output bus signal based on the value of the reset signal.\nFinally, you should use an always block to implement the bus hold functionality, which should hold the output bus signal when the clock signal is low and latch the input bus signal when the clock signal is high.", "output": "module bus_hold (\n  input [n-1:0] bus_in,\n  input clk,\n  input reset,\n  output [n-1:0] bus_out\n);\n\nparameter n = 8; // number of bits in the bus signal\n\nreg [n-1:0] bus_hold_reg; // register to hold the bus signal\n\nalways @(posedge clk) begin\n  if (reset) begin\n    bus_hold_reg <= 0;\n  end else begin\n    bus_hold_reg <= bus_in;\n  end\nend\n\nassign bus_out = reset ? 0 : bus_hold_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a module in Verilog that implements a 4-bit adder with carry. The module should have the following inputs and outputs:\n\nInputs:\n- `a`: a 4-bit binary number\n- `b`: a 4-bit binary number\n- `cin`: a single bit representing the carry-in value\n\nOutputs:\n- `sum`: a 4-bit binary number representing the sum of `a` and `b`\n- `cout`: a single bit representing the carry-out value\n\nYou should name your module `adder_4bit_carry`.\n\nYour module should use only combinational logic (no clocked logic allowed). The module should also be designed to minimize the number of gates used.\n\n", "output": "module adder_4bit_carry (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n  assign sum = a + b + cin; // 4-bit binary addition\n  assign cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin); // carry-out calculation\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that will implement a 4-bit comparator. The module should have two 4-bit inputs, A and B, and three outputs: EQ, GT and LT. EQ should be high if A is equal to B, GT should be high if A is greater than B, and LT should be high if A is less than B. \n\nImplement the module in such a way that the comparison is done using combinational logic only. The module should be named \"four_bit_comparator\" and should have the following interface:\n\nInputs:\n\n- A (4-bit input)\n- B (4-bit input)\n\nOutputs:\n\n- EQ (1-bit output)\n- GT (1-bit output)\n- LT (1-bit output)\n\n", "output": "module four_bit_comparator(\n  input [3:0] A,\n  input [3:0] B,\n  output EQ,\n  output GT,\n  output LT\n);\n\n  assign EQ = (A == B);\n  assign GT = (A > B);\n  assign LT = (A < B);\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in three inputs, A, B, and C, and outputs Y. The module should implement a NAND3 gate with the following functionality:\n\n- If A, B, and C are all low, Y should be high.\n- If any one of A, B, or C is high, Y should be low.\n\nThe module should also include voltage supply signals VPWR, VGND, VPB, and VNB. You may assume that these signals are already defined and do not need to be declared within the module.\n\nYour task is to write the Verilog code for this module, which should be no more than 200 lines long. You should name the module \"nand3_custom\", and it should be defined with the following inputs and outputs:\n\nInputs:\n- A (1-bit)\n- B (1-bit)\n- C (1-bit)\n\nOutputs:\n- Y (1-bit)\n\nYour implementation should be as efficient as possible, using the fewest possible number of gates and minimizing the propagation delay.\n\n", "output": "module nand3_custom (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    // Define internal signals\n    wire nand1_out;\n    wire nand2_out;\n\n    // Define voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Implement NAND3 gate with minimum number of gates\n    sky130_fd_sc_hd__nand2 nand1 (\n        .A(A),\n        .B(B),\n        .Y(nand1_out)\n    );\n\n    sky130_fd_sc_hd__nand2 nand2 (\n        .A(nand1_out),\n        .B(C),\n        .Y(nand2_out)\n    );\n\n    sky130_fd_sc_hd__not not1 (\n        .A(nand2_out),\n        .Y(Y)\n    );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder with carry-in and carry-out functionality. The module should take two 4-bit inputs, A and B, and a single bit carry-in input, Cin. The output should be a 4-bit sum, S, and a single bit carry-out, Cout. \n\nTo implement this functionality, you should create a new module named \"four_bit_adder\" that instantiates four instances of a \"full_adder\" module. The \"full_adder\" module should take two bits, A and B, and a single bit carry-in input, Cin, and produce a single bit sum, S, and a single bit carry-out, Cout. \n\nThe \"four_bit_adder\" module should connect the inputs and outputs of the four \"full_adder\" modules in a way that correctly implements the 4-bit adder with carry-in and carry-out functionality. The module should use only combinational logic, and should not use any behavioral constructs such as \"always\" or \"assign\". \n\nWrite the verilog code for the \"four_bit_adder\" module, as well as the \"full_adder\" module.\n\n", "output": "module full_adder(\n    input A, B, Cin,\n    output S, Cout\n);\n\nassign S = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n\nmodule four_bit_adder(\n    input [3:0] A, B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire c1, c2, c3;\nfull_adder fa1(.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(c1));\nfull_adder fa2(.A(A[1]), .B(B[1]), .Cin(c1), .S(S[1]), .Cout(c2));\nfull_adder fa3(.A(A[2]), .B(B[2]), .Cin(c2), .S(S[2]), .Cout(c3));\nfull_adder fa4(.A(A[3]), .B(B[3]), .Cin(c3), .S(S[3]), .Cout(Cout));\n\nendmodule"}
{"instruction": "As a Verilog designer, implement a module that behaves like an XOR gate using only NAND gates. \nThe module should have two inputs and one output.", "output": "module xor_gate( input a, input b, output y );\n  wire w1, w2, w3, w4;\n  \n  nand n1(w1, a, b);\n  nand n2(w2, a, w1);\n  nand n3(w3, b, w1);\n  nand n4(y, w2, w3);\n  \nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder-subtractor circuit with overflow detection. The module should have two 4-bit inputs, A and B, and two control inputs, Add and Sub. When Add is high, the module should add A and B and output the result on a 4-bit output bus, O. When Sub is high, the module should subtract B from A and output the result on O. The module should also have an output, V, which should be high if the result of the operation overflows beyond 4 bits.", "output": "module add_sub_overflow (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  input Add,\n  input Sub,\n  output [3:0] O,\n  output V\n);\n\nreg [4:0] temp;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    temp <= 0;\n    V <= 0;\n  end else begin\n    if (Add) begin\n      temp <= A + B;\n      V <= (temp > 15);\n    end else if (Sub) begin\n      temp <= A - B;\n      V <= (temp < 0);\n    end\n  end\nend\n\nassign O = temp[3:0];\n\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit binary counter with a synchronous reset and a load input. The module should have a 4-bit output (Q) that increments by one on each positive edge of the clock (CLK). When the load input is high, the counter should load the value from the 4-bit input (LOAD) instead of incrementing. The synchronous reset input (RESET) should reset the counter to zero on the next positive edge of the clock after being asserted.", "output": "module counter (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] LOAD_VAL,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= LOAD_VAL;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a 3-input NOR gate. The module should have three input ports, `i0`, `i1`, and `i2`, and one output port, `o`. The module should output a logic 1 if all three inputs are logic 0, and a logic 0 otherwise.\n\nDesign a Verilog module that implements a 3-input NOR gate. The module should be named `nor3` and should be self-contained, meaning it should not rely on any other modules to function properly. Your design should be synthesizable and meet the following requirements:\n\n- The module should have three input ports, `i0`, `i1`, and `i2`, and one output port, `o`.\n- The module should output a logic 1 if all three inputs are logic 0, and a logic 0 otherwise.\n- The module should be designed using only primitive logic gates (e.g., `and`, `or`, `not`, `nand`, `nor`, `xor`, `xnor`).\n\nWrite a Verilog module that meets these requirements.\n\n", "output": "module nor3 (output o, input i0, i1, i2);\n    wire w1, w2, w3, w4;\n    \n    not n1 (w1, i0);\n    not n2 (w2, i1);\n    not n3 (w3, i2);\n    nor n4 (o, w1, w2, w3);\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a flip-flop circuit. The module should have the following inputs and outputs:\n- Input D: a single bit of data to be stored in the flip-flop\n- Input CLK: a clock signal used to trigger the flip-flop\n- Input SCD: a synchronous clear signal that resets the flip-flop to 0\n- Input SCE: a synchronous set signal that sets the flip-flop to 1\n- Output Q: the output of the flip-flop\n- Output Q_N: the complement of the output Q\n\nYou must create a module that implements this flip-flop circuit using no more than 200 lines of Verilog code. The module should have the following characteristics:\n- The flip-flop should be edge-triggered on the rising edge of the clock signal\n- The flip-flop should be synchronous, meaning that the output should change only on a clock edge\n- The flip-flop should be able to be reset to 0 or set to 1 synchronously using the SCD and SCE signals, respectively\n- The module should be designed to work with the sky130_fd_sc_ls__sdfxbp base module, which is provided in the code snippet above\n- The module should include voltage supply signals for VPWR, VGND, VPB, and VNB\n\nCreate a Verilog module that meets these specifications and implements the flip-flop circuit.\n\n", "output": "module flip_flop (\n    Q,\n    Q_N,\n    CLK,\n    D,\n    SCD,\n    SCE\n);\n\n    output Q;\n    output Q_N;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    reg Q;\n    assign Q_N = ~Q;\n\n    always @(posedge CLK) begin\n        if (SCD) begin\n            Q <= 0;\n        end else if (SCE) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in five inputs and produces one output. The inputs are A1, A2, A3, A4, and B1. The output is Y. The module should be named \"five_to_one\".\n\nYou are given the following specifications:\n- If B1 is high, the output Y should be the logical AND of all the inputs (A1 AND A2 AND A3 AND A4).\n- If B1 is low, the output Y should be the logical OR of all the inputs (A1 OR A2 OR A3 OR A4).\n\nYou are also given the following constraints:\n- All inputs and output are single-bit signals.\n- The design should be implemented using only basic logic gates (AND, OR, NOT).\n- The design should minimize the number of gates used.\n\nImplement the \"five_to_one\" module and provide its Verilog code.\n\n", "output": "module five_to_one (\n    input A1,\n    input A2,\n    input A3,\n    input A4,\n    input B1,\n    output Y\n);\n\n    wire b_and = A1 & A2 & A3 & A4; // logical AND of all inputs\n    wire b_or = A1 | A2 | A3 | A4; // logical OR of all inputs\n\n    assign Y = B1 ? b_and : b_or; // if B1 is high, output b_and. Otherwise, output b_or.\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a priority encoder. The module should have an input port, \"in\", which is a 4-bit wide vector and an output port, \"out\", which is a 2-bit wide vector. The module should output the highest priority bit set in the input vector. If multiple bits are set in the input vector, the module should output the highest priority bit. If no bits are set in the input vector, the module should output 2'b00. You can use any method to implement the priority encoder.", "output": "module priority_encoder (\n  input [3:0] in,\n  output [1:0] out\n);\n\n  assign out = 2'b00;\n  always @ (in) begin\n    if (in[3] == 1) begin\n      out = 2'b11;\n    end else if (in[2] == 1) begin\n      out = 2'b10;\n    end else if (in[1] == 1) begin\n      out = 2'b01;\n    end else if (in[0] == 1) begin\n      out = 2'b00;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a 4-bit adder with carry input. The module should have five inputs: two 4-bit binary numbers (A and B), a carry input (CIN), and two power supply voltages (VDD and VSS). The module should have two outputs: a 4-bit binary sum (SUM) and a carry output (COUT).\n\nThe module should implement the following logic:\n\n- The SUM output should be the binary sum of A and B, plus the carry input (CIN).\n- The COUT output should be 1 if the binary sum of A, B, and CIN is greater than 15 (i.e., if the sum requires a 5th bit).\n\nAssume that the input binary numbers (A and B) and the carry input (CIN) are valid binary numbers between 0 and 15 (inclusive). You can assume that the power supply voltages (VDD and VSS) are constant and equal to 5 volts and 0 volts, respectively.\n\nYour Verilog module should be able to handle these inputs and produce the correct outputs for all valid inputs.\n\n", "output": "module four_bit_adder_with_carry_input (\n  input [3:0] A,\n  input [3:0] B,\n  input CIN,\n  output [3:0] SUM,\n  output COUT,\n  input VDD,\n  input VSS\n);\n\n  wire [3:0] sum;\n  wire cout;\n\n  assign sum = A + B + CIN;\n  assign COUT = (sum > 4'b1111);\n\n  sky130_fd_sc_hd__mux_2 mux0 (\n    .A(sum),\n    .B(4'b0000),\n    .S(COUT),\n    .Y(SUM)\n  );\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a combinational circuit for 4-bit binary to gray code conversion. The module should take a 4-bit binary input and output the corresponding 4-bit gray code. The module should have the following IO definition:", "output": "module binary_to_gray (\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0];\n  assign gray[1] = binary[0] ^ binary[1];\n  assign gray[2] = binary[1] ^ binary[2];\n  assign gray[3] = binary[2] ^ binary[3];\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit ripple carry adder with a carry-in input and a carry-out output. The module should have the following inputs and outputs:\n\nInputs:\n- `a`: a 4-bit input signal\n- `b`: a 4-bit input signal\n- `cin`: a single-bit input signal representing the carry-in\n\nOutputs:\n- `sum`: a 4-bit output signal representing the sum of `a` and `b`\n- `cout`: a single-bit output signal representing the carry-out\n\nYou should use only combinational logic to implement the ripple carry adder.\n\n", "output": "module ripple_carry_adder (\n  input [3:0] a, b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] c;\n  \n  assign c[0] = cin;\n  assign c[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n  assign c[2] = (a[1] & b[1]) | (a[1] & c[1]) | (b[1] & c[1]);\n  assign c[3] = (a[2] & b[2]) | (a[2] & c[2]) | (b[2] & c[2]);\n  \n  assign sum = a + b + cin;\n  assign cout = c[3];\n  \nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes four input signals and produces one output signal. The input signals are A1, A2, B1, and C1, and the output signal is X. Additionally, the module must have four power input signals: VPB, VPWR, VGND, and VNB. \n\nThe module should be named \"logic_gate\" and should implement the following logic: if A1 is high and A2 is low, or if B1 is high and C1 is high, then X should be high. Otherwise, X should be low. \n\nYour task is to write the Verilog code for this module. Assume that all input and output signals are 1-bit signals.\n\n", "output": "module logic_gate (\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  C1  ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    assign X = (A1 & !A2) | (B1 & C1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a register with a specific address and data width. The module should be able to handle write operations and reset operations.\n\nYour module should have the following inputs and outputs:\n\n- `in_data` (8 bits): input data to be written to the register\n- `wenb` (1 bit): write enable signal\n- `reset` (1 bit): reset signal\n- `clk` (1 bit): clock signal\n- `reg_0x23` (8 bits): output register with address 0x23\n\nThe module should work as follows:\n\n- When `reset` is asserted, the output register should be set to 0x00.\n- When `wenb` is asserted, the input data should be written to the output register.\n- When `wenb` is not asserted, the output register should retain its previous value.\n\nYour task is to implement the Verilog module that meets these requirements. You should name your module `r_COMMAND`.\n\n", "output": "module r_COMMAND(output reg [7:0] reg_0x23, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==0) begin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x23<=in_data;\n\t\t\telse\n\t\t\t\treg_0x23<=reg_0x23;\n\t\tend\n\t\telse\n\t\t\treg_0x23<=8'h00;\n\tend\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a D flip-flop with asynchronous reset. The module should have three inputs: `CLK`, `D`, and `RST`. The `CLK` input is the clock signal, `D` is the data input, and `RST` is the asynchronous reset signal. The module should have one output, `Q`, which is the output of the flip-flop.\n\nThe flip-flop should operate on the rising edge of the clock signal. When the reset signal is asserted (i.e., goes low), the output of the flip-flop should be set to 0 regardless of the value of the data input. When the reset signal is deasserted (i.e., goes high), the flip-flop should operate normally.\n\nYou should implement this module within 200 lines of Verilog code. Your module should be named `dff_ar` and should be defined in a file named `dff_ar.v`.\n\n", "output": "module dff_ar (\n    Q,\n    CLK,\n    D,\n    RST\n);\n\n    output Q;\n    input CLK, D, RST;\n\n    reg Q;\n\n    always @(posedge CLK or negedge RST) begin\n        if (!RST) begin\n            Q <= 1'b0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in four input signals, A1_N, A2_N, B1, and B2, and outputs a single signal, Y. The module should be named \"logic_gate\" and should be written in Verilog. The input signals are binary and can have a value of either 0 or 1. The output signal should also be binary and should be determined based on the following logic:\n- If A1_N is 1 and A2_N is 1, then Y should be 0.\n- If B1 is 0 and B2 is 0, then Y should be 0.\n- If A1_N is 0 and A2_N is 0, and B1 is 1 or B2 is 1, then Y should be 1.\n- In all other cases, Y should be 0.\n\nYour task is to implement this logic in the \"logic_gate\" module using Verilog.\n\n", "output": "module logic_gate (\n    input A1_N,\n    input A2_N,\n    input B1,\n    input B2,\n    output Y\n);\n\n    assign Y = ((A1_N & A2_N) | ((~B1) & (~B2) & ((~A1_N) & (~A2_N)))) ? 0 : 1;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 16-bit adder that takes two inputs (A and B) and produces a sum output (S). The module should also have an output (C) that indicates if there is a carry out of the most significant bit. \n\nThe module should have the following inputs and outputs:\n- input [15:0] A, B;\n- output [15:0] S;\n- output C;\n\nYour module should be named \"adder_16bit\" and should use only combinational logic. \n\nWrite the verilog code for the adder_16bit module.\n\n", "output": "module adder_16bit(\n    input [15:0] A, B,\n    output [15:0] S,\n    output C\n    );\n\n    wire [15:0] temp;\n    wire [16:0] sum;\n    \n    assign temp = A ^ B;\n    assign sum = {1'b0, A} + {1'b0, B};\n    assign S = sum[15:0];\n    assign C = sum[16];\n\nendmodule"}
{"instruction": "\nYou are designing a system that includes a clock module called `my_clock`. This module should take in an input clock signal `clk_in` and an input reset signal `reset`. The module should output two signals: `clk_out` and `reset_out`. The `clk_out` signal should be a version of the `clk_in` signal that has been divided by a factor of 2. The `reset_out` signal should be a version of the `reset` signal that has been delayed by 5 clock cycles.\n\nDesign a Verilog module called `my_clock` that implements the above functionality. The module should have the following input and output ports:\n\n- `clk_in`: input clock signal (1 bit)\n- `reset`: input reset signal (1 bit)\n- `clk_out`: output clock signal (1 bit)\n- `reset_out`: output reset signal (1 bit)\n\nAssume that the input clock signal has a frequency of 50 MHz.\n\n", "output": "module my_clock (\n    input clk_in,\n    input reset,\n    output reg clk_out,\n    output reg reset_out\n);\n\nreg [3:0] reset_delay; // delay counter for reset signal\n\nalways @(posedge clk_in) begin\n    // divide clock by 2\n    clk_out <= ~clk_out;\n    \n    // delay reset signal by 5 clock cycles\n    if (reset_delay == 4) begin\n        reset_out <= reset;\n    end else begin\n        reset_out <= 1'b0;\n        reset_delay <= reset_delay + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module for a flip-flop circuit that can be used in a larger digital system. The module should have the following inputs and outputs:\n\n- `CLK`: a clock signal\n- `D`: a data input signal\n- `SCD`: a synchronous clear input signal\n- `SCE`: a synchronous set input signal\n- `SET_B`: an asynchronous set input signal\n- `Q`: a data output signal\n- `Q_N`: the complement of the data output signal\n\nThe module should implement the following behavior:\n\n- When `SET_B` is high, `Q` should be set to high and `Q_N` should be set to low, regardless of the values of `D`, `SCD`, and `SCE`.\n- When `SCD` is high, `Q` should be set to low and `Q_N` should be set to high, regardless of the values of `D`, `SET_B`, and `SCE`.\n- When `SCE` is high, `Q` should be set to high and `Q_N` should be set to low, regardless of the values of `D`, `SET_B`, and `SCD`.\n- Otherwise, the flip-flop should operate normally: on each rising edge of `CLK`, the value of `D` should be captured and stored in `Q` and the complement of `Q` should be stored in `Q_N`.\n\nDesign a Verilog module that implements this behavior. Your module should be self-contained and no more than 200 lines of Verilog code.\n\n", "output": "module flip_flop (\n    output Q,\n    output Q_N,\n    input CLK,\n    input D,\n    input SCD,\n    input SCE,\n    input SET_B\n);\n\n    reg Q_reg, Q_N_reg;\n\n    always @(posedge CLK) begin\n        if (SET_B) begin\n            Q_reg <= 1'b1;\n            Q_N_reg <= 1'b0;\n        end else if (SCD) begin\n            Q_reg <= 1'b0;\n            Q_N_reg <= 1'b1;\n        end else if (SCE) begin\n            Q_reg <= 1'b1;\n            Q_N_reg <= 1'b0;\n        end else begin\n            Q_reg <= D;\n            Q_N_reg <= ~D;\n        end\n    end\n\n    assign Q = Q_reg;\n    assign Q_N = Q_N_reg;\n\nendmodule"}
{"instruction": "\n\nDesign a 4-bit multiplexer module using Verilog. The module should have 4 input ports, 2 select lines, and 1 output port. The select lines should be used to select which input port should be connected to the output port. The select lines should be active high. If the select lines are both low, the output port should be 0. If the select lines are both high, the output port should be 0 as well. All other combinations of select lines should select the corresponding input port and connect it to the output port.\n\nYou should name your module \"mux4\" and the input ports should be named \"in0\", \"in1\", \"in2\", and \"in3\". The select lines should be named \"sel0\" and \"sel1\". The output port should be named \"out\".\n\n", "output": "module mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input sel0,\n    input sel1,\n    output [3:0] out\n    );\n    \n    assign out = sel1 & sel0 ? in3 : sel1 & ~sel0 ? in2 : ~sel1 & sel0 ? in1 : in0;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit binary counter that counts up every rising edge of the input clock. The module should have an asynchronous reset input that resets the counter to 0 when asserted. The module should also have an output that is high when the counter reaches the maximum value (15) and low otherwise. The module should be named \"binary_counter\" and should have the following inputs and outputs:\n\nInputs:\n- clk (1-bit input): the clock signal\n- rst (1-bit input): the asynchronous reset signal\n\nOutputs:\n- count (4-bit output): the current count value\n- max_reached (1-bit output): high when the counter reaches the maximum value (15), low otherwise\n\nYou can assume that the input clock signal has a 50% duty cycle and a frequency of 50 MHz.\n\nWrite the Verilog code for the \"binary_counter\" module.\n\n\n", "output": "module binary_counter (\n  input clk,\n  input rst,\n  output reg [3:0] count,\n  output reg max_reached\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 4'b0;\n      max_reached <= 1'b0;\n    end\n    else if (count == 4'b1111) begin\n      count <= 4'b0;\n      max_reached <= 1'b1;\n    end\n    else begin\n      count <= count + 1;\n      max_reached <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a verilog module that performs a specific operation on a 4-bit input signal. The module should take in a 4-bit input signal `in`, a clock signal `clk`, and output a 2-bit signal `out`. The module should perform the following operation on the input signal:\n- On every rising edge of the clock signal, the module should output the last two bits of the input signal in reverse order.\n\nWrite a verilog module that performs this operation and test it using a testbench.\n\n", "output": "module reverse_last_two_bits (\n   input clk,\n   input [3:0] in,\n   output reg [1:0] out\n);\n\n   always @(posedge clk) begin\n      out <= {in[1:0], in[3:2]};\n   end\n\nendmodule"}
{"instruction": "\n\nWrite a Verilog module that implements a 2-to-1 multiplexer. The module should have two input ports, `a` and `b`, and one output port, `y`. The module should also have a control input port, `sel`, which selects which input to pass to the output. If `sel` is 0, `a` should be passed to `y`, and if `sel` is 1, `b` should be passed to `y`.\n\nAssume that all input and output ports are 1-bit wide.\n\n", "output": "module mux_2to1(\n    input a,\n    input b,\n    input sel,\n    output y\n    );\n    \n    assign y = (!sel & a) | (sel & b);\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in two 8-bit inputs, `a` and `b`, and outputs the logical AND of the two inputs. Additionally, the module should output a signal `out_valid` that is high for one clock cycle when the output is valid.\n\nThe module should have the following interface:\n```\nmodule And_Module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg out_valid\n);\n```\n\nYou may assume that the inputs `a` and `b` are stable for at least one clock cycle before the output is valid. You may also assume that the clock signal is provided as an input to the module.\n\nYour task is to implement the `And_Module` module in verilog.\n\n", "output": "module And_Module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg out_valid\n);\n    \n    always @(posedge clk) begin\n        out <= a & b;\n        out_valid <= 1'b1;\n    end\n    \nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a digital circuit that will implement a D flip-flop with reset and asynchronous set functionality. The circuit should be implemented in Verilog and should be contained within a single module of no more than 200 lines of code.\n\nThe module should have the following inputs and outputs:\n\n- `CLK`: a clock signal\n- `D`: the data input\n- `RESET_B`: an active-low reset input\n- `SET_B`: an active-low set input\n- `Q`: the output of the flip-flop\n- `Q_N`: the complement output of the flip-flop\n\nThe flip-flop should operate according to the following rules:\n- When `RESET_B` is low, both `Q` and `Q_N` should be set to 0.\n- When `SET_B` is low, both `Q` and `Q_N` should be set to 1.\n- At every positive edge of `CLK`, the output `Q` should reflect the input `D`.\n- At every negative edge of `CLK`, the output `Q_N` should reflect the input `D`.\n\nWrite a Verilog module that implements this flip-flop.\n\n", "output": "module d_flip_flop_reset_set (\n    input CLK,\n    input D,\n    input RESET_B,\n    input SET_B,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK, negedge RESET_B, negedge SET_B) begin\n        if (!RESET_B) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (!SET_B) begin\n            Q <= 1;\n            Q_N <= 0;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that performs a bitwise AND operation between two 8-bit input vectors, `A` and `B`, and outputs the result as an 8-bit output vector, `C`. If any of the input vectors have more than 8 bits, the extra bits should be ignored. If any of the input vectors have less than 8 bits, the missing bits should be considered as 0. \n\nDesign the verilog module with the following specifications:\n- The module should be named `bitwise_and`.\n- The module should have three 8-bit ports: `A`, `B`, and `C`.\n- The module should perform a bitwise AND operation between `A` and `B` and output the result as `C`.\n- The module should be synthesizable and should work correctly for all possible input combinations.\n\n", "output": "module bitwise_and(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] C\n);\n\nassign C = A & B;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a simple 4-bit adder. The module should have two 4-bit input ports, `a` and `b`, and a 4-bit output port, `sum`. The module should also have a single input port, `carry_in`, which is a single bit.\n\nThe module should implement the following logic:\n\n- The 4-bit output `sum` should be the sum of the two 4-bit inputs `a` and `b`, plus the value of `carry_in`.\n- If the sum of any two corresponding bits in `a`, `b`, and `carry_in` is greater than or equal to 2, then the corresponding bit in `sum` should be 1. Otherwise, it should be 0.\n- The module should also have a single output port, `carry_out`, which is a single bit. `carry_out` should be 1 if the sum of the most significant bits of `a`, `b`, and `carry_in` is greater than or equal to 2. Otherwise, it should be 0.\n\nYour module should be named `adder_4bit` and should be implemented in a single Verilog module no longer than 200 lines.\n\n", "output": "module adder_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    input carry_in,\n    output [3:0] sum,\n    output carry_out\n);\n\nreg [3:0] sum_reg;\nreg carry_out_reg;\n\nalways @(*) begin\n    sum_reg[0] = a[0] ^ b[0] ^ carry_in;\n    sum_reg[1] = a[1] ^ b[1] ^ sum_reg[0];\n    sum_reg[2] = a[2] ^ b[2] ^ sum_reg[1];\n    sum_reg[3] = a[3] ^ b[3] ^ sum_reg[2];\n    \n    carry_out_reg = (a[3] & b[3]) | (a[3] & carry_in) | (b[3] & carry_in);\nend\n\nassign sum = sum_reg;\nassign carry_out = carry_out_reg;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 2-to-1 multiplexer with an enable signal. It has 3 input ports: 2 8-bit input ports (a, b) and a 1-bit enable port (en). It also has one 8-bit output port (out). It routes the value of one of the two inputs to the output port (out) based on the value of the enable port (en). The default value of the output is '0'. If en is 0, the output is assigned to '0'. If en is 1, the output is assigned to the input a if a is not '0', otherwise the output is assigned to the input b.", "output": "module mux_2to1_enable (\n  input clk,\n  input reset,\n  input [7:0] a,\n  input [7:0] b,\n  input en,\n  output reg [7:0] out\n);\n\nalways @(posedge clk, negedge reset) begin\n  if (!reset) begin\n    out <= 8'b0;\n  end else begin\n    if (en) begin\n      if (a != 8'b0) begin\n        out <= a;\n      end else begin\n        out <= b;\n      end\n    end else begin\n      out <= 8'b0;\n    end\n  end\nend\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that counts the number of times a signal goes high in a given period. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `signal`: the signal to be counted\n- `period`: the period for which the signal should be counted\n\nOutputs:\n- `count`: the number of times the signal went high in the given period\n\nAssume that the `signal` input is synchronous with the `clk` input and that it goes high for one clock cycle and then goes low for one clock cycle. The `period` input is given in clock cycles.\n\nWrite a Verilog module `count_signal` that implements this functionality. You can assume that the `period` input is a multiple of 2.\n\n", "output": "module count_signal (\n   // Inputs\n   input clk,\n   input signal,\n   input [31:0] period,\n   // Outputs\n   output reg [31:0] count\n   );\n\n   reg signal_prev = 0;\n   reg [31:0] counter = 0;\n\n   always @(posedge clk) begin\n      if (period == 0) begin\n         count <= 0;\n         counter <= 0;\n      end else if (counter == period-1) begin\n         count <= counter;\n         counter <= 0;\n      end else begin\n         counter <= counter + 1;\n         if (signal == 1 && signal_prev == 0) begin\n            counter <= 0;\n         end\n      end\n      signal_prev <= signal;\n   end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit up/down counter with a synchronous reset. The module should have two inputs (Up and Down) to control the counting direction, one input (Clk) for the clock signal, and one input (Reset) for the synchronous reset signal. The module should have one output (Count) representing the current count value. When Up=1, the counter should count up. When Down=1, the counter should count down. When Reset=1, the counter should reset to zero.", "output": "module up_down_counter_4bit (\n    input Up,\n    input Down,\n    input Clk,\n    input Reset,\n    output reg [3:0] Count\n);\n\n    always @(posedge Clk) begin\n        if (Reset) begin\n            Count <= 4'b0;\n        end else if (Up) begin\n            Count <= Count + 1;\n        end else if (Down) begin\n            Count <= Count - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Create a module that implements a full-adder circuit using two half-adder circuits. The full-adder circuit should have three inputs (A, B, and C_in) and two outputs (Sum and C_out).", "output": "module full_adder (\n  input A,\n  input B,\n  input C_in,\n  output Sum,\n  output C_out\n);\n\n  wire HA1_Sum, HA1_C_out, HA2_C_out;\n\n  // Instantiate two half-adders\n  half_adder HA1(.A(A), .B(B), .Sum(HA1_Sum), .C_out(HA1_C_out));\n  half_adder HA2(.A(HA1_Sum), .B(C_in), .Sum(Sum), .C_out(HA2_C_out));\n\n  // Calculate the final carry-out\n  assign C_out = HA1_C_out | HA2_C_out;\n\nendmodule\n\n// Half-adder module\nmodule half_adder (\n  input A,\n  input B,\n  output Sum,\n  output C_out\n);\n\n  assign Sum = A ^ B;\n  assign C_out = A & B;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that performs a bitwise AND operation on two input vectors and produces an output vector. The module should have the following inputs and outputs:\n\nInputs:\n- `input [7:0] A`: an 8-bit input vector\n- `input [7:0] B`: an 8-bit input vector\n\nOutputs:\n- `output [7:0] C`: an 8-bit output vector representing the result of the bitwise AND operation between A and B.\n\nYou should implement the module using only AND gates.\n\n", "output": "module bitwise_and (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] C\n);\n\n    wire [7:0] and_result;\n\n    // AND gates for each bit\n    and and0(and_result[0], A[0], B[0]);\n    and and1(and_result[1], A[1], B[1]);\n    and and2(and_result[2], A[2], B[2]);\n    and and3(and_result[3], A[3], B[3]);\n    and and4(and_result[4], A[4], B[4]);\n    and and5(and_result[5], A[5], B[5]);\n    and and6(and_result[6], A[6], B[6]);\n    and and7(and_result[7], A[7], B[7]);\n\n    assign C = and_result;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in five inputs and provides one output. The module should be named `logic_gate` and should implement the following logic:\n- If `A1` and `A2` are both high, and `B1` and `B2` are both low, then `X` should be high.\n- If `C1` is high, then `X` should be low.\n- In all other cases, `X` should be low.\n\nYou may use any verilog primitives or gates available to you. Ensure that your module has the correct input and output ports, and that all necessary supply voltage signals are included.\n\n", "output": "module logic_gate (\n    X,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input B1;\n    input B2;\n    input C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    wire AB_high = (A1 & A2) & (!B1 & !B2);\n\n    assign X = (AB_high | C1) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 5 input signals, A1, A2, A3, B1, and B2, and outputs a single signal Y. The module should be named \"five_input_module\". The input signals are all single-bit signals, and the output signal is also a single-bit signal.\n\nThe module should implement the following logic:\n\n- If A1 and A2 are both high, Y should be high.\n- If A1 and A3 are both high, Y should be high.\n- If B1 and B2 are both high, Y should be high.\n- If none of the above conditions are met, Y should be low.\n\nYou should assume that the input signals are stable and will not change during the execution of the module.\n\n", "output": "module five_input_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  B1,\n    input  B2,\n    output Y\n);\n\n    // Use an intermediate signal to simplify the logic\n    wire intermediate_signal;\n\n    // Implement the logic\n    assign intermediate_signal = (A1 & A2) | (A1 & A3) | (B1 & B2);\n    assign Y = intermediate_signal;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a simple logic gate. The module should have three inputs: `A`, `SLEEP`, and `KAPWR`, and one output: `X`. The output `X` should be high only when `A` is high and `SLEEP` is low. The module should also have four supplies: `KAPWR`, `VGND`, `VPB`, and `VNB`. \n\nYour task is to implement the module according to the given code snippet and ensure that it meets the requirements specified above. \n\nWrite a Verilog module that implements the logic gate as described above. Your module should be named `sky130_fd_sc_lp__iso0p` and should have the specified inputs, output, and supplies. \n\n", "output": "module sky130_fd_sc_lp__iso0p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    // Module ports\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    // Module supplies\n    supply1 KAPWR;\n    supply0 VGND ;\n    supply1 VPB  ;\n    supply0 VNB  ;\n\n    // Local signals\n    wire sleepn;\n\n    //  Name  Output  Other arguments\n    not not0 (sleepn, SLEEP          );\n    and and0 (X     , A, sleepn      );\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that implements a logic function using the sky130_fd_sc_ms__a222o module as a template. Your module should have six inputs and one output, and it should be able to perform the following logic function:\n\n```\nX = (A1 and A2) or (B1 and B2) or (C1 and C2)\n```\n\nYour module must be implemented using Verilog and should be no more than 200 lines long. You may use any standard Verilog libraries that you need. You are to assume that all inputs and outputs are 1-bit wide.\n\nYour task is to implement the module and ensure that it behaves correctly according to the given logic function.\n\n", "output": "module logic_function (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    input C2,\n    output reg X\n);\n\n    always @(*) begin\n        X = (A1 & A2) | (B1 & B2) | (C1 & C2);\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 4-bit adder using Verilog. The adder should have two 4-bit inputs, A and B, and a 4-bit output, S. The adder should also have a carry-out output, Cout, which should be high (1) if the addition of A and B results in a carry-out. You should implement the adder using only one module without including other modules.\n\nYour module should be named `four_bit_adder` and should have the following inputs and outputs:\n\nInputs:\n- `A`: a 4-bit input\n- `B`: a 4-bit input\n\nOutputs:\n- `S`: a 4-bit output representing the sum of A and B\n- `Cout`: a 1-bit output representing the carry-out of the addition\n\nYou will need to use the `wire` keyword to declare internal signals for your module.\n\n", "output": "module four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] C;\n\n  assign S = A + B;\n  assign C = {A[3], B[3], S[3]};\n\n  assign Cout = (C[2] & ~C[1]) | (~C[2] & C[0]);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 2-input, 1-output multiplexer with an additional input that controls whether the output is inverted or not. The module should have two inputs, A and B, and one control input, C. When C is low, the output should be equal to A. When C is high, the output should be equal to B. If the additional input is high, the output should be inverted.", "output": "module mux (\n    input A,\n    input B,\n    input C,\n    input invert,\n    output reg out\n);\n\n    always @ (A, B, C, invert) begin\n        if (C == 1'b0) begin\n            out <= A;\n        end\n        else begin\n            out <= B;\n        end\n        \n        if (invert == 1'b1) begin\n            out <= ~out;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 16-bit barrel shifter with a single input (IN), a single output (OUT), and two control inputs (SHIFT and DIR). When SHIFT is high, the module should shift the input left or right depending on the value of DIR. When DIR is low, the module should shift the input right (towards the least significant bit). When DIR is high, the module should shift the input left (towards the most significant bit). When SHIFT is low, the module should pass the input directly to the output without shifting.", "output": "module barrel_shifter (\n    input [15:0] IN,\n    input SHIFT, DIR,\n    output [15:0] OUT\n);\n\n    assign OUT = (SHIFT) ? ((DIR) ? {IN[14:0], 1'b0} : {1'b0, IN[15:1]}) : IN;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a control register block. A control register block is a type of digital circuit that is used to control the behavior of other circuits. It can be configured to set various control signals and enable or disable certain circuits.\n\nYour module should have the following inputs and outputs:\n\nInputs: a set of n control signals (ctrl1, ctrl2, ..., ctrln)\nOutputs: a set of m enable signals (en1, en2, ..., enm)\n\nThe module should also have the following parameters:\n\nn: the number of control signals\nm: the number of enable signals\n\nYour module should implement the following functionality:\n\nThe circuit should have n control signals, each of which can be set to a value of 0 or 1.\nThe circuit should have m enable signals, each of which is controlled by a combination of the control signals.\nThe output signals should be a set of m enable signals that are determined by the value of the control signals.\n\nTo implement the control register block, you should use Verilog code to define the Boolean functions that determine the value of each enable signal based on the value of the control signals. You should then use these functions to connect the control signals to the enable signals.", "output": "module control_reg_block (\n  input [n-1:0] ctrl,\n  output [m-1:0] en\n);\n\n  parameter n = 4; // number of control signals\n  parameter m = 2; // number of enable signals\n\n  // Define Boolean functions to determine enable signals\n  assign en[0] = ctrl[0] & ctrl[1];\n  assign en[1] = ctrl[2] | ctrl[3];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a current source and a current sink. \nA current source is a type of circuit that generates a constant current, while a current sink is a circuit that can absorb a constant current. \nIn this task, you will create a module that can act as both a current source and a current sink.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- enable: a signal that enables the current source/sink\n- i_set: a signal that sets the value of the constant current\n- i_in: a signal that provides the input current (for the current sink)\nOutputs: \n- i_out: a signal that provides the output current (for the current source)\n- i_sunk: a signal that provides the amount of current sunk (for the current sink)\n\nYour module should implement the following functionality:\n\n- If the enable signal is low, the module should not generate any current.\n- If the enable signal is high, the module should generate a constant current equal to the value of i_set.\n- If the value of i_in is less than the value of i_set, the module should act as a current sink and absorb the difference between i_set and i_in. The amount of current sunk should be provided on the i_sunk output.\n- If the value of i_in is greater than the value of i_set, the module should act as a current source and provide a current equal to the difference between i_in and i_set. The amount of current sourced should be provided on the i_out output.\n\nTo implement the current source and sink, you should use Verilog code to define the behavior of the module based on the input signals. \nYou should use conditional statements and assign statements to calculate the output currents based on the input currents and the enable signal. \nFinally, you should use the output currents to drive the output signals.", "output": "module curr_source_sink (\n  input enable,\n  input [31:0] i_set,\n  input [31:0] i_in,\n  output [31:0] i_out,\n  output [31:0] i_sunk\n);\n\n  reg [31:0] i_out_reg;\n  reg [31:0] i_sunk_reg;\n\n  always @(*) begin\n    if(enable == 1'b0) begin\n      i_out_reg = 32'h0;\n      i_sunk_reg = 32'h0;\n    end else if(i_in < i_set) begin\n      i_out_reg = 32'h0;\n      i_sunk_reg = i_set - i_in;\n    end else begin\n      i_out_reg = i_in - i_set;\n      i_sunk_reg = 32'h0;\n    end\n  end\n\n  assign i_out = i_out_reg;\n  assign i_sunk = i_sunk_reg;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit comparator. The module should have two 4-bit inputs (A and B) and three outputs (EQ, GT, and LT). If A=B, EQ should be 1; otherwise, EQ should be 0. If A>B, GT should be 1; otherwise, GT should be 0. If A<B, LT should be 1; otherwise, LT should be 0.", "output": "module comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output EQ,\n    output GT,\n    output LT\n);\n\n    assign EQ = (A == B) ? 1 : 0;\n    assign GT = (A > B) ? 1 : 0;\n    assign LT = (A < B) ? 1 : 0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder with carry-in and carry-out signals. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a reset signal\n- `a`: a 4-bit input signal\n- `b`: a 4-bit input signal\n- `cin`: a carry-in signal\n\nOutputs:\n- `sum`: a 4-bit output signal representing the sum of `a`, `b`, and `cin`\n- `cout`: a carry-out signal\n\nThe module should be designed such that it can be easily instantiated and integrated into larger designs. Your module should also be synthesizable and meet timing requirements.\n\n", "output": "module adder_4bit_carry (\n  input clk,\n  input rst,\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  reg [3:0] sum_reg;\n  reg cout_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      sum_reg <= 4'b0;\n      cout_reg <= 1'b0;\n    end else begin\n      {cout_reg, sum_reg} <= a + b + cin;\n    end\n  end\n\n  assign sum = sum_reg;\n  assign cout = cout_reg;\n\nendmodule"}
{"instruction": "\n\nDesign a verilog module for a 4-input NOR gate with an inverted output. The module should have the following interface:\n- Inputs: A, B, C, D\n- Output: Y\n- The module should be named \"four_nor_inv\"\n\n", "output": "module four_nor_inv(\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg Y\n);\n\n    always @(*) begin\n        Y = ~(A | B | C | D);\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit synchronous counter with a parallel load input. The module should have the following inputs and outputs:\n\n- `clk`: input wire representing the clock signal\n- `rst`: input wire representing the active high reset signal\n- `load`: input wire representing the active high parallel load signal\n- `data`: input wire representing the 4-bit data input for the parallel load\n- `count`: output reg representing the current count value of the counter\n\nThe counter should increment on the rising edge of the clock signal, and reset to 0 when the reset signal is active high. When the parallel load signal is active high, the counter should load the 4-bit input data into the count register on the next rising clock edge.\n\nWrite a verilog module that implements this 4-bit synchronous counter with a parallel load input.\n\n", "output": "module sync_counter(clk, rst, load, data, count);\n    input wire clk, rst, load;\n    input wire [3:0] data;\n    output reg [3:0] count;\n\n    always @(posedge clk or posedge rst)\n    begin\n        if (rst) begin\n            count <= 0;\n        end\n        else if (load) begin\n            count <= data;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a square root calculator. \nThe module should have the following inputs and outputs:\n\nInputs: a 32-bit binary number to take the square root of (num_in)\nOutputs: a 16-bit binary number that is the integer part of the square root (sqrt_out)\nThe module should implement the following functionality:\n\nThe module should calculate the integer part of the square root of the input number using the binary search algorithm.\nThe algorithm should start with the most significant bit of the input number and work its way down to the least significant bit.\nFor each bit, the module should set the bit in a temporary variable (temp) and calculate the square of the temporary variable.\nIf the square is greater than the input number, the bit should be cleared in the temporary variable.\nThe module should repeat this process for all 32 bits of the input number.\nThe module should output the 16 most significant bits of the temporary variable as the integer part of the square root.\nTo implement the square root calculator, you should use Verilog code to define the temporary variable and implement the binary search algorithm. \nYou should then use this algorithm to calculate the integer part of the square root and output the result.", "output": "module sqrt_calculator(\n  input [31:0] num_in,\n  output reg [15:0] sqrt_out\n);\n\n  reg [31:0] temp;\n  reg [15:0] sqrt_temp;\n  reg [4:0] i;\n\n  always @(*) begin\n    temp = {16'b0, num_in};\n    sqrt_temp = 16'b0;\n\n    for (i = 15; i >= 0; i = i - 1) begin\n      temp[i+16] = sqrt_temp;\n      sqrt_temp = sqrt_temp << 1;\n      sqrt_temp[i] = 1'b1;\n\n      if (temp >= sqrt_temp*sqrt_temp) begin\n        sqrt_out[i] = 1'b1;\n      end else begin\n        sqrt_out[i] = 1'b0;\n        sqrt_temp = sqrt_temp - (1 << i);\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 8-bit barrel shifter. The module should have three inputs (DATA, SHIFT_AMOUNT, SHIFT_DIRECTION) and one output (SHIFTED_DATA). SHIFT_AMOUNT is a 3-bit input that specifies how many bits to shift. SHIFT_DIRECTION is a 1-bit input that specifies the direction of the shift (0 for left, 1 for right). The module should perform the shift operation on DATA and output the SHIFTED_DATA.", "output": "module barrel_shifter (\n    input [7:0] DATA,\n    input [2:0] SHIFT_AMOUNT,\n    input SHIFT_DIRECTION,\n    output [7:0] SHIFTED_DATA\n);\n\n    reg [7:0] shifted_data;\n\n    always @(*) begin\n        if (SHIFT_DIRECTION == 0) begin\n            shifted_data = DATA << SHIFT_AMOUNT;\n        end else begin\n            shifted_data = DATA >> SHIFT_AMOUNT;\n        end\n    end\n\n    assign SHIFTED_DATA = shifted_data;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a Wi-Fi transmitter and receiver blocks. \nThe Wi-Fi transmitter and receiver blocks are the key components of a wireless communication system that allow devices to communicate with each other over a wireless network. \nYour module should have the following inputs and outputs:\n\nInputs: \n- data_in: the input data to be transmitted\n- clk_in: the input clock signal\n- start_in: the input start signal that initiates the transmission\n- reset_in: the input reset signal that resets the transmitter and receiver\n\nOutputs:\n- data_out: the output data received by the receiver\n- clk_out: the output clock signal\n- done_out: the output done signal that indicates when the transmission is complete\n\nYour module should implement the following functionality:\n\nTransmitter:\n- The transmitter should take the input data and convert it into a digital signal that can be transmitted wirelessly.\n- The transmitter should use modulation techniques such as amplitude shift keying (ASK) or frequency shift keying (FSK) to modulate the digital signal.\n- The transmitter should output the modulated signal to an antenna for transmission.\n\nReceiver:\n- The receiver should receive the modulated signal from the antenna and demodulate it to recover the original data.\n- The receiver should use techniques such as matched filtering or correlation to recover the original data from the received signal.\n- The receiver should output the recovered data to the output port.\n\nTo implement the Wi-Fi transmitter and receiver blocks, you should use Verilog code to simulate the modulation and demodulation techniques. \nYou should then use these techniques to connect the inputs to the transmitter and receiver blocks and generate the output signals.\nFinally, you should use the output signals to indicate when the transmission is complete.", "output": "module wifi_transceiver (\n  input data_in,\n  input clk_in,\n  input start_in,\n  input reset_in,\n  output data_out,\n  output clk_out,\n  output done_out\n);\n\n  // Transmitter code\n  // ...\n\n  // Receiver code\n  // ...\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in four inputs, A1, A2, A3, and B1, and outputs X. The module should be named \"my_module\".\n\nThe inputs A1, A2, A3, and B1 are all single-bit signals. The output X is also a single-bit signal.\n\nThe module should implement the following logic:\n\n- If all of the inputs A1, A2, A3, and B1 are 0, then X should be 0.\n- If any of the inputs A1, A2, or A3 are 1, and B1 is 0, then X should be 1.\n- If all of the inputs A1, A2, and A3 are 0, and B1 is 1, then X should be 1.\n- In all other cases, X should be 0.\n\nYou should implement this logic using only one module, and the module should be no more than 200 lines of verilog code.\n\n", "output": "module my_module (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    output X\n);\n\n    wire a_or = A1 | A2 | A3;\n    wire a_and = A1 & A2 & A3;\n\n    assign X = ((~a_or & ~B1) | a_and | B1) & ~(a_or & B1);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that contains three registers: `A`, `B`, and `C`. The module should have an `initial` block that sets the initial values of `A`, `B`, and `C` to `0`. Additionally, the module should have an `always` block that executes a `fork...join` statement. The `fork` block should contain two `always` blocks, each of which should execute concurrently. The first `always` block should increment `A` by 1 every 2 time units, while the second `always` block should decrement `B` by 1 every 3 time units. The `join` statement should wait for both `always` blocks to complete before executing. Finally, the module should have an `always` block that executes whenever `C` changes value. This always block should calculate the sum of `A` and `B` and store the result in `C`.\n\nWrite the verilog code for the module, ensuring that it meets the above requirements.\n\n", "output": "module register_module (\n  input clk,\n  output reg [3:0] A,\n  output reg [3:0] B,\n  output reg [3:0] C\n);\n\n  initial begin\n    A = 0;\n    B = 0;\n    C = 0;\n  end\n\n  always @(posedge clk) begin\n    fork\n      begin : increment_A\n        forever #2 A = A + 1;\n      end\n      begin : decrement_B\n        forever #3 B = B - 1;\n      end\n    join\n  end\n\n  always @(A or B) begin\n    C = A + B;\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a D flip-flop with asynchronous preset functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `C`: clock signal\n- `D`: data input\n- `PRE`: asynchronous preset input\n\nOutputs:\n- `Q`: output data\n\nThe flip-flop should operate as follows:\n- When `PRE` is high, the output `Q` should be set to high, regardless of the value of `D`.\n- When `PRE` is low, the output `Q` should follow the input `D` on the rising edge of the clock signal `C`.\n\nThe module should have a parameter `INIT` that determines the initial value of `Q` when the simulation starts. The module should also have a local parameter `FLOP_DELAY` that determines the delay of the flip-flop.\n\nWrite a Verilog module that implements the above D flip-flop with asynchronous preset functionality. Your module should be self-contained and should not rely on any external modules or testbenches. Your module should be within 200 lines of Verilog code.\n\n", "output": "module dff_async_preset (\n    input wire C,\n    input wire D,\n    input wire PRE,\n    output reg Q\n);\n\n    parameter INIT = 0;\n    localparam FLOP_DELAY = 100;\n\n    initial Q = INIT;\n\n    always @(posedge C) begin\n        if (PRE) begin\n            Q <= 1'b1;\n        end else begin\n            #FLOP_DELAY Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 4-bit binary ripple counter with synchronous reset functionality. The counter should have an input clock signal (iCLK) and a synchronous reset input (iRST). When iRST is asserted, the counter should reset to 0000. Otherwise, on each rising edge of iCLK, the counter should increment by 1 in binary (e.g. 0000 -> 0001 -> 0010 -> 0011 -> ... -> 1111 -> 0000). The module should have a 4-bit output (oCOUNT) that represents the current value of the counter.\n\nYou should implement this module within 200 lines of Verilog code, using only basic Verilog constructs such as always blocks, if/else statements, and logical operators. You may not use any pre-built Verilog modules or constructs that are not standard Verilog.\n\nYour module should be named \"binary_counter\" and should have the following interface:\n\n```\nmodule binary_counter(\n    input iCLK,\n    input iRST,\n    output reg [3:0] oCOUNT\n);\n```\n\n", "output": "module binary_counter(\n    input iCLK,\n    input iRST,\n    output reg [3:0] oCOUNT\n);\n\n    always @(posedge iCLK) begin\n        if (iRST) begin\n            oCOUNT <= 4'b0000;\n        end else begin\n            oCOUNT <= oCOUNT + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a combinational logic circuit that takes in 6 inputs and produces one output. The circuit is described by the following module:\n\n```\nmodule sky130_fd_sc_lp__a221oi_lp (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_lp__a221oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .B2(B2),\n        .C1(C1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n```\n\nThe inputs and output are as follows:\n- `A1`, `A2`, `B1`, `B2`, and `C1` are all single-bit inputs.\n- `VPWR`, `VGND`, `VPB`, and `VNB` are all power and ground inputs.\n- `Y` is a single-bit output.\n\nYour task is to implement the logic that satisfies the following truth table:\n\n```\nA1 A2 B1 B2 C1 | Y\n--------------|--\n0  0  0  0  0  | 0\n0  0  0  0  1  | 1\n0  0  0  1  0  | 0\n0  0  0  1  1  | 0\n0  0  1  0  0  | 1\n0  0  1  0  1  | 0\n0  0  1  1  0  | 1\n0  0  1  1  1  | 0\n0  1  0  0  0  | 1\n0  1  0  0  1  | 0\n0  1  0  1  0  | 1\n0  1  0  1  1  | 0\n0  1  1  0  0  | 1\n0  1  1  0  1  | 0\n0  1  1  1  0  | 1\n0  1  1  1  1  | 0\n1  0  0  0  0  | 1\n1  0  0  0  1  | 0\n1  0  0  1  0  | 1\n1  0  0  1  1  | 0\n1  0  1  0  0  | 0\n1  0  1  0  1  | 1\n1  0  1  1  0  | 0\n1  0  1  1  1  | 1\n1  1  0  0  0  | 0\n1  1  0  0  1  | 1\n1  1  0  1  0  | 0\n1  1  0  1  1  | 1\n1  1  1  0  0  | 0\n1  1  1  0  1  | 1\n1  1  1  1  0  | 0\n1  1  1  1  1  | 0\n```\n\n", "output": "module combinational_logic (\n    Y,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y;\n    input A1, A2, B1, B2, C1;\n\n    assign Y = (~A1 & B1 & C1) | (~A1 & ~B2 & ~C1) | (A1 & ~B1 & ~C1) | (A2 & ~B1 & ~C1) | (A2 & B2 & C1);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit multiplier circuit. The module should take two 4-bit inputs (x and y) and produce an 8-bit output (product). The module should use combinational logic to calculate the product of the two inputs. You can use any method to implement the multiplication operation. The port connections of the module are as follows: x is the 4-bit input, y is the 4-bit input, and product is the 8-bit output.", "output": "module four_bit_multiplier (\n  input [3:0] x,\n  input [3:0] y,\n  output [7:0] product\n);\n\nwire [7:0] temp; // temporary 8-bit variable for intermediate calculations\n\nassign temp[0] = x[0] & y; // calculate the first bit of the product\nassign temp[1] = x[1] & y;\nassign temp[2] = x[2] & y;\nassign temp[3] = x[3] & y;\n\nassign temp[4] = {4'b0, x} & {4'b0, y}; // calculate the second byte of the product\nassign temp[5] = {3'b0, x} & {5'b0, y};\nassign temp[6] = {2'b0, x} & {6'b0, y};\nassign temp[7] = {1'b0, x} & {7'b0, y};\n\nassign product = temp; // assign the final product to the output\n\nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in a 4-bit input `data_in` and outputs a 2-bit signal `data_out`. The output signal should be the result of dividing the input by 3, rounded down to the nearest integer. For example, if the input is 6, the output should be 2 (6/3=2), and if the input is 7, the output should be 2 as well (7/3=2.333 rounded down to 2).\n\nDesign the verilog module `divider` that implements this functionality. \n\n", "output": "module divider(\n  input [3:0] data_in,\n  output reg [1:0] data_out\n);\n\n  always @(*) begin\n    case (data_in)\n      0: data_out = 2'b00;\n      1: data_out = 2'b00;\n      2: data_out = 2'b00;\n      3: data_out = 2'b01;\n      4: data_out = 2'b01;\n      5: data_out = 2'b01;\n      6: data_out = 2'b10;\n      7: data_out = 2'b10;\n      8: data_out = 2'b10;\n      9: data_out = 2'b11;\n      10: data_out = 2'b11;\n      11: data_out = 2'b11;\n      default: data_out = 2'b00; // handles unexpected inputs\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two inputs, `data` and `enable`, and produces an output `out` according to the following specifications:\n- When `enable` is low, `out` should be 0.\n- When `enable` transitions from low to high, `out` should take on the value of `data` at that moment and hold that value until `enable` goes low again.\n- When `enable` is high, `out` should hold its previous value.\n\nDesign a module that implements this behavior within 200 lines of Verilog code.\n\n", "output": "module enable_dff (\n    input data,\n    input enable,\n    output reg out\n);\n\n    always @(posedge enable or negedge enable)\n    if (!enable) begin\n        out <= 0;\n    end else begin\n        out <= data;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary counter. The module should have the following inputs and outputs:\n- `clk` (input): a clock signal with a frequency of 50 MHz\n- `reset` (input): a synchronous reset signal (active high)\n- `count` (output): a 4-bit binary output representing the current count value\n- `overflow` (output): a single-bit output indicating if the counter has overflowed (i.e., if the count value has reached 15)\n\nThe counter should start at 0 and increment by 1 on each rising edge of the `clk` signal. If the `reset` signal is high, the counter should be reset to 0. If the count value reaches 15, the `overflow` signal should be set high.\n\nWrite the verilog code for this module.\n\n", "output": "module binary_counter(clk, reset, count, overflow);\n  input clk, reset;\n  output reg [3:0] count;\n  output reg overflow;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n      overflow <= 1'b0;\n    end\n    else if (count == 4'b1111) begin\n      count <= 4'b0000;\n      overflow <= 1'b1;\n    end\n    else begin\n      count <= count + 1;\n      overflow <= 1'b0;\n    end\n  end\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that combines two XOR gates and a 2-to-1 multiplexer to implement a simple encryption algorithm. The module should take in three inputs (plaintext, key, and enable) and produce a single output (ciphertext). The two XOR gates should take in plaintext and key as inputs and output the XOR of the inputs. The 2-to-1 multiplexer should take in the outputs of the XOR gates and enable as inputs, and output the selected input based on the enable input. The output should be updated every rising edge of the clk input.\n\nTo implement the encryption algorithm, the plaintext and key inputs will be XORed together to generate the ciphertext output. The enable input will be used to select whether to use the plaintext or the key input for the XOR operation. If enable is high, the plaintext input will be used, otherwise the key input will be used.", "output": "module encryption_module (\n  input clk,\n  input reset,\n  input plaintext,\n  input key,\n  input enable,\n  output reg ciphertext\n);\n\n  reg xor1_out;\n  reg xor2_out;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      xor1_out <= 1'b0;\n      xor2_out <= 1'b0;\n      ciphertext <= 1'b0;\n    end else begin\n      xor1_out <= plaintext ^ key;\n      xor2_out <= plaintext ^ key;\n      ciphertext <= enable ? xor1_out : xor2_out;\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a simple 8-bit counter. The counter should have a synchronous reset input and an enable input. Whenever the enable input is high, the counter should increment by 1 on the rising edge of the clock. Whenever the reset input is high, the counter should reset to 0 on the next rising edge of the clock. The counter output should be available on a 8-bit output port. \n\nCreate a Verilog module that implements this counter with the following port definitions:\n- `input aclk`: the clock input\n- `input reset`: the synchronous reset input\n- `input enable`: the enable input\n- `output reg [7:0] counter_out`: the 8-bit counter output\n\nAssume a positive-edge triggered clock.\n\n", "output": "module counter\n    (aclk, reset, enable, counter_out);\n\n    input aclk;\n    input reset;\n    input enable;\n    output reg [7:0] counter_out;\n\n    always @(posedge aclk) begin\n        if (reset) begin\n            counter_out <= 8'b0;\n        end else if (enable) begin\n            counter_out <= counter_out + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit comparator. The module should compare two 4-bit inputs (A and B) and output a 2-bit value (EQ, LT, GT) indicating whether A is equal to, less than, or greater than B. You can use any method to implement the comparator, but the module should be designed to minimize the hardware resources.", "output": "module comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  output reg [1:0] EQ_LT_GT\n);\n\n  always @* begin\n    if (A == B) begin\n      EQ_LT_GT = 2'b01; // A is equal to B\n    end else if (A < B) begin\n      EQ_LT_GT = 2'b10; // A is less than B\n    end else begin\n      EQ_LT_GT = 2'b00; // A is greater than B\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that implements a MAC (Multiply and Accumulate) operation. The module should have the following inputs and outputs:\n\nInputs:\n- clk: a clock signal\n- reset: a reset signal\n- ce: an enable signal\n- din0: a 32-bit input signal\n- din1: a 32-bit input signal\n\nOutputs:\n- dout: a 32-bit output signal\n\nThe module should implement the following operation:\n- Multiply din0 and din1\n- Add the result to the current value of dout\n- Output the result on dout\n\nYour module should be named \"my_mac\" and should be no more than 200 lines of Verilog code.\n\n", "output": "module my_mac(\n    input clk,\n    input reset,\n    input ce,\n    input [31:0] din0,\n    input [31:0] din1,\n    output reg [31:0] dout\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        dout <= 0;\n    end else if (ce) begin\n        dout <= dout + din0 * din1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module to implement a 4-bit binary counter with parallel load functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: the clock signal\n- `reset`: asynchronous reset signal\n- `load`: load signal to load a new value into the counter\n- `data`: 4-bit input data to be loaded into the counter when `load` is asserted\n\nOutputs:\n- `count`: 4-bit output representing the current count value of the counter\n\nThe counter should increment on every rising edge of the `clk` signal, and should reset to 0 when the `reset` signal is asserted. When the `load` signal is asserted, the counter should immediately load the value of `data` into the counter and start counting from that value.\n\nYour task is to implement the verilog module for the 4-bit binary counter with parallel load functionality.\n\n", "output": "module counter(input clk, reset, load, input [3:0] data, output reg [3:0] count);\n\n    always @(posedge clk, negedge reset) begin\n        if (~reset) begin\n            count <= 4'b0000;\n        end else if (load) begin\n            count <= data;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a clock gate for a D flip-flop with an enable signal. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: the clock signal\n- `EN`: the enable signal for the flip-flop\n- `TE`: the transparent enable signal\n\nOutputs:\n- `ENCLK`: the gated clock signal\n\nThe module should implement the following functionality:\n- When `EN` is high, the output `ENCLK` should be equal to the input `CLK`\n- When `EN` is low, the output `ENCLK` should be low\n- When `TE` is high, the output `ENCLK` should be high regardless of the value of `EN`\n\nYour module should be designed to work with a 64-bit wide bus, and should be named `SNPS_CLOCK_GATE_HIGH_d_ff_en_W64_0_32`. Your solution should be contained within 200 lines of Verilog code.\n\n", "output": "module SNPS_CLOCK_GATE_HIGH_d_ff_en_W64_0_32 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  // Implement a D flip-flop with enable\n  reg D, Q;\n  always @(posedge CLK) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\n  // Implement a transparent latch\n  reg TL;\n  always @(posedge CLK) begin\n    if (TE) begin\n      TL <= Q;\n    end\n  end\n\n  // Implement the clock gate\n  always @(posedge CLK) begin\n    if (TE) begin\n      ENCLK <= 1'b1;\n    end else if (EN) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit synchronous counter. The counter should have a reset input, a clock input, and an output that represents the current count value. The counter should be able to count up from 0 to 15 and then wrap around to 0 again. The design should be optimized for speed and area.\n\n", "output": "module sync_counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that takes in one input and outputs one output. The module should be named `sky130_fd_sc_hd__full_adder`. The input and output ports should be named `A`, `B`, and `Cout` respectively. The module should implement a full adder logic, which means that it should take in two binary inputs `A` and `B` and a carry-in input `Cin`. The module should output the sum `S` and the carry-out `Cout`. The output `S` should be the binary sum of `A`, `B`, and `Cin`. The output `Cout` should be the carry-out bit of the addition. \n\nThe module should be implemented using only combinational logic. You should not use any sequential logic elements, such as flip-flops or latches. You should also not use any pre-defined full adder modules.\n\nYou should write your module within 200 lines of Verilog code.\n\n", "output": "module sky130_fd_sc_hd__full_adder (\n    A,\n    B,\n    Cin,\n    Cout,\n    S\n);\n\n    // Module ports\n    input A, B, Cin;\n    output Cout, S;\n\n    // Internal signals\n    wire X1, X2, X3;\n    wire Y1, Y2;\n\n    //  Name  Output  Other arguments\n    xor  xor0 (X1, A, B);\n    xor  xor1 (X2, X1, Cin);\n    and  and0 (X3, X1, Cin);\n    and  and1 (Y1, A, B);\n    and  and2 (Y2, X1, Cin);\n    or   or0  (Cout, X3, Y1, Y2);\n    assign S = X2;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a full adder using Verilog. The module should have three inputs: A, B, and CI, and two outputs: SUM and COUT. A and B are single bit inputs, CI is the carry in bit, SUM is the sum of the three bits, and COUT is the carry out bit. \n\nCreate a Verilog module that implements a full adder using the following interface:\n\n```\nmodule full_adder (\n    input A,\n    input B,\n    input CI,\n    output SUM,\n    output COUT\n);\n```\n\nYou may use any gates or other modules available in Verilog to implement the full adder. Your module should be able to handle any combination of inputs and produce the correct output.\n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input CI,\n    output SUM,\n    output COUT\n);\n\n    wire xor1_out;\n    wire xor2_out;\n    wire and1_out;\n    wire and2_out;\n    wire or1_out;\n\n    xor xor1(xor1_out, A, B);\n    xor xor2(SUM, xor1_out, CI);\n    and and1(and1_out, A, B);\n    and and2(and2_out, xor1_out, CI);\n    or or1(or1_out, and1_out, and2_out);\n    assign COUT = or1_out;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a clock gating circuit. The module should take in three inputs: CLK, EN, and TE, and output a signal ENCLK. The circuit should gate the clock signal based on the state of the EN and TE inputs. When EN is high, the circuit should pass the clock signal through to ENCLK. When EN is low, the circuit should hold ENCLK low. When TE is high, the circuit should hold ENCLK high, regardless of the state of EN.\n\nYou are provided with a code snippet for inspiration, but you are free to design your own module. However, the module you design must be self-contained and solvable within 200 lines of verilog code.\n\nDesign a module that meets the requirements described above. Your module should be named \"clock_gate\" and should have the following interface:\n\n```\nmodule clock_gate(\n  input CLK, // clock signal\n  input EN, // enable signal\n  input TE, // test enable signal\n  output ENCLK // gated clock signal\n);\n```\n\nYour module should adhere to the following requirements:\n\n1. When EN is high, pass the CLK signal through to ENCLK.\n2. When EN is low, hold ENCLK low.\n3. When TE is high, hold ENCLK high, regardless of the state of EN.\n4. The module should be self-contained and solvable within 200 lines of verilog code.\n\n", "output": "module clock_gate(\n  input CLK, // clock signal\n  input EN, // enable signal\n  input TE, // test enable signal\n  output ENCLK // gated clock signal\n);\n\n  reg gated_clk;\n  \n  always @(*) begin\n    if (TE) begin\n      gated_clk = 1;\n    end else if (EN) begin\n      gated_clk = CLK;\n    end else begin\n      gated_clk = 0;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule"}
{"instruction": "\n\nYou have been given the task of designing a 4-bit adder that can perform addition of two 4-bit numbers. You are required to use the following Verilog module as a building block:\n\n```\nmodule sky130_fd_sc_lp__a311oi_lp (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_lp__a311oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1),\n        .C1(C1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n```\n\nYou are required to create a Verilog module named `four_bit_adder` that takes two 4-bit inputs `A` and `B` and produces a 5-bit output `Y`. The most significant bit of `Y` should be 0 and the remaining 4 bits should represent the sum of `A` and `B`. You are required to use the above module as a building block to implement the adder.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [4:0] Y\n);\n\n    wire co1, co2, co3;\n    sky130_fd_sc_lp__a311oi_lp a1(co1, A[0], B[0], 1'b0, 1'b0, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0);\n    sky130_fd_sc_lp__a311oi_lp a2(co2, A[1], B[1], co1, 1'b0, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0);\n    sky130_fd_sc_lp__a311oi_lp a3(co3, A[2], B[2], co2, 1'b0, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0);\n    sky130_fd_sc_lp__a311oi_lp a4(Y[4], A[3], B[3], co3, 1'b0, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0);\n\n    assign Y[3:0] = A[3:0] + B[3:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in three inputs, `A1`, `A2`, and `B1`, and outputs `X`. The output `X` should be the result of the logical operation `A1 AND A2 OR B1`. You should create a module called `logic_module` that implements this functionality using basic verilog logic gates.\n\n", "output": "module logic_module (\n    input A1,\n    input A2,\n    input B1,\n    output X\n);\n\n    // Local signals\n    wire and_out ;\n    wire or_out;\n\n    //  Name  Output     Other arguments\n    and and_gate (and_out , A1, A2);\n    or  or_gate  (or_out, and_out, B1);\n    assign X = or_out;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that will implement a 4-bit adder. The module should have two 4-bit input ports, A and B, and one 4-bit output port, S. The module should also have a single input port, Cin, which represents the carry-in bit. The module should implement the following logic:\n\n- The output port S should be the sum of the input ports A and B, plus the carry-in bit Cin.\n- If the sum of A, B, and Cin is greater than 15 (4 bits), the output port S should be truncated to the least significant 4 bits.\n\nYou should name your module \"four_bit_adder\".\n\n", "output": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n\n    assign S = temp_sum[3:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in 8-bit data and outputs the data in little-endian format. The module should have two inputs and one output:\n\n- `input [7:0] data_in`: 8-bit input data\n- `input clk`: clock input\n- `output reg [7:0] data_out`: 8-bit output data\n\nThe module should sample the input data on the rising edge of the clock and output the data in little-endian format. That is, the least significant bit of the input should be the most significant bit of the output, and vice versa.\n\nWrite the verilog code for the module that meets these requirements.\n\n", "output": "module little_endian (data_in, clk, data_out);\ninput [7:0] data_in;\ninput clk;\noutput reg [7:0] data_out;\n\nalways @(posedge clk) begin\n    data_out[0] = data_in[7];\n    data_out[1] = data_in[6];\n    data_out[2] = data_in[5];\n    data_out[3] = data_in[4];\n    data_out[4] = data_in[3];\n    data_out[5] = data_in[2];\n    data_out[6] = data_in[1];\n    data_out[7] = data_in[0];\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that checks whether the timeunit and timeprecision values are set to 1ns. The module should have a single input and a single output. The input is a 32-bit integer that represents the timeunit and timeprecision values. The output should be a single bit that is high if and only if both timeunit and timeprecision are set to 1ns.\n\nAssume that the input is a 32-bit integer with the following bit layout:\n- Bits 31-16 represent the timeunit value\n- Bits 15-0 represent the timeprecision value\n\nWrite a Verilog module that takes in the 32-bit integer and outputs a single bit indicating whether both timeunit and timeprecision are set to 1ns. The module should be named `check_1ns` and should be contained within a module definition.\n\nYour solution should be contained within 200 lines of Verilog code.\n\n", "output": "module check_1ns(\n    input [31:0] time_values,\n    output reg check\n);\n\n    // Extract timeunit and timeprecision values from input\n    reg [15:0] timeunit = time_values[31:16];\n    reg [15:0] timeprecision = time_values[15:0];\n\n    // Check if timeunit and timeprecision are both 1ns\n    always @* begin\n        if (timeunit == 1 && timeprecision == 1) begin\n            check = 1;\n        end else begin\n            check = 0;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, a flag register is a type of register that stores a single bit of information which can be used to indicate a certain condition or state. In this problem, you are required to design a flag register using Verilog HDL. The flag register should have the following inputs and outputs:\n\nInputs:\n- IN_FLAG: a single bit input that sets the value of the flag register\n- LD: a single bit input that loads the value of IN_FLAG into the flag register\n- SET: a single bit input that sets the value of the flag register to 1\n- CLR: a single bit input that clears the value of the flag register to 0\n- CLK: a single bit input that serves as the clock signal\n\nOutputs:\n- OUT_FLAG: a single bit output that represents the current value of the flag register\n\nYou are required to write a Verilog module named \"flag_register\" that implements the flag register described above.\n\n", "output": "module flag_register\n   (IN_FLAG,\n    LD,\n    SET,\n    CLR,\n    CLK,\n    OUT_FLAG);\n  input IN_FLAG;\n  input LD;\n  input SET;\n  input CLR;\n  input CLK;\n  output OUT_FLAG;\n\n  reg flag;\n\n  always @(posedge CLK) begin\n    if (LD) begin\n      flag <= IN_FLAG;\n    end else if (SET) begin\n      flag <= 1;\n    end else if (CLR) begin\n      flag <= 0;\n    end\n  end\n\n  assign OUT_FLAG = flag;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a digital circuit that will take in three inputs and produce two outputs. The module should be named \"my_module\" and should be written in Verilog. The inputs are named \"in1\", \"in2\", and \"in3\", and the outputs are named \"out1\" and \"out2\". The following constraints apply:\n\n1. The module should only be 200 lines or fewer.\n2. The output \"out1\" should be the result of an XOR gate between \"in1\" and \"in2\".\n3. The output \"out2\" should be the result of an AND gate between \"in2\" and \"in3\".\n4. The design should be synchronous, and the output should only be updated on the rising edge of the clock signal.\n5. The module should have a reset input named \"reset\", which, when asserted, should set both outputs to zero.\n\nWrite the \"my_module\" module that satisfies the above constraints.\n\n", "output": "module my_module (\n    input in1,\n    input in2,\n    input in3,\n    input clk,\n    input reset,\n    output out1,\n    output out2\n);\n\n    reg out1_reg;\n    reg out2_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out1_reg <= 1'b0;\n            out2_reg <= 1'b0;\n        end else begin\n            out1_reg <= in1 ^ in2;\n            out2_reg <= in2 & in3;\n        end\n    end\n\n    assign out1 = out1_reg;\n    assign out2 = out2_reg;\n\nendmodule"}
{"instruction": "Develop a module that implements a NOR gate using only NAND gates. A NOR gate is an OR gate with its output inverted. The module should have two input ports and one output port.", "output": "module nor_gate_using_nand( \n    input a, \n    input b, \n    output out );\n    \n    wire nand1_out, nand2_out, nand3_out;\n    \n    nand nand1( .a(a), .b(a), .out(nand1_out) );\n    nand nand2( .a(b), .b(b), .out(nand2_out) );\n    nand nand3( .a(nand1_out), .b(nand2_out), .out(nand3_out) );\n    \n    not not1( .a(nand3_out), .out(out) );\n    \nendmodule"}
{"instruction": "\n\nIn digital circuits, multiplexers are used to select one input from multiple inputs and output it. The given Verilog code implements a multiplexer using shift operations. The module takes C_NUM_INPUTS number of inputs of C_WIDTH bits each, and selects one of them based on the C_CLOG_NUM_INPUTS bit select signal MUX_SELECT. The selected input is then output as MUX_OUTPUT.\n\nYour task is to modify the given Verilog code to implement a 4:1 mux with an enable signal. The enable signal should be a single bit input, and when it is 0, the output should be 0 regardless of the input values. \n\nYou should write the modified Verilog code within a module named \"mux_4_1_enable\". Your module should have the following inputs and outputs:\n\nInputs:\n- input [3:0] MUX_INPUTS: 4 32-bit inputs to the multiplexer\n- input [1:0] MUX_SELECT: 2-bit select signal\n- input EN: 1-bit enable signal\n\nOutputs:\n- output [31:0] MUX_OUTPUT: 32-bit output of the multiplexer\n\nYou should use only the following Verilog constructs in your solution:\n- module\n- input/output declarations\n- wire declarations\n- assign statements\n- always blocks\n- if/else statements\n- case statements\n\n", "output": "module mux_4_1_enable(\n    input [3:0] MUX_INPUTS,\n    input [1:0] MUX_SELECT,\n    input EN,\n    output [31:0] MUX_OUTPUT\n);\n\n    wire [31:0] selected_input;\n\n    assign selected_input = MUX_SELECT[1] ? MUX_INPUTS[3] : MUX_INPUTS[2];\n\n    always @(*) begin\n        case (MUX_SELECT)\n            2'b00: MUX_OUTPUT = MUX_INPUTS[0];\n            2'b01: MUX_OUTPUT = MUX_INPUTS[1];\n            2'b10: MUX_OUTPUT = selected_input;\n            2'b11: MUX_OUTPUT = MUX_INPUTS[3];\n        endcase\n\n        if (!EN) begin\n            MUX_OUTPUT = 32'h00000000;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module to implement a 4-bit synchronous counter that counts from 0 to 9 and then resets to 0. The counter should have a clock input and a reset input. When the reset input is high, the counter should reset to 0. When the clock input transitions from low to high, the counter should increment by 1. The counter output should be displayed on a 4-bit output port.\n\nDesign a verilog module that meets these requirements. \n\n", "output": "module synchronous_counter(\n    input clk, // clock input\n    input reset, // reset input\n    output reg [3:0] count // 4-bit output port\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0000; // reset count to 0\n    end else begin\n        if (count == 4'b1001) begin\n            count <= 4'b0000; // reset count to 0 when it reaches 9\n        end else begin\n            count <= count + 1; // increment count by 1\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that will implement a 3-to-8 decoder. The decoder should have 3 input bits and 8 output bits. The output bits should be active high and correspond to the binary value of the input bits. For example, if the input bits are \"001\", then the output bit 1 should be high and all other output bits should be low.\n\nCreate a verilog module `decoder_3to8` with the following ports:\n- `input [2:0] in`: 3-bit input\n- `output [7:0] out`: 8-bit output\n\nYou can assume that the input will always be a valid 3-bit binary value.\n\n", "output": "module decoder_3to8 (\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out = 8'b00000001 << in;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-to-1 multiplexer with two select inputs. The module should have four 8-bit data inputs and one 8-bit output. The first select input should select between the first two data inputs, and the second select input should select between the last two data inputs.", "output": "module multiplexer_4to1 (\n    input [7:0] data_in0,\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    input [7:0] data_in3,\n    input [1:0] select,\n    output reg [7:0] data_out\n);\n\nalways @(*) begin\n    case (select)\n        2'b00: data_out = data_in0;\n        2'b01: data_out = data_in1;\n        2'b10: data_out = data_in2;\n        2'b11: data_out = data_in3;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements clock gating cells. \nClock gating is a technique used to reduce power consumption in digital circuits. \nIn clock gating, the clock signal to a circuit block is turned off when the block is not in use. \nThis reduces the amount of power consumed by the circuit, as well as reducing the amount of heat generated by the circuit.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n1. clock signal (clk)\n2. enable signal (en)\n\nOutputs: \n1. gated clock signal (gclk)\n\nYour module should implement the following functionality:\n\nWhen the enable signal is high, the gated clock signal should be the same as the clock signal.\nWhen the enable signal is low, the gated clock signal should be 0.\n\nTo implement the clock gating cells, you should use Verilog code to define the logic for the gated clock signal. \nYou should use an AND gate to combine the clock signal with the enable signal. \nThe output of the AND gate should be the gated clock signal. \nWhen the enable signal is low, the output of the AND gate will be 0, which will turn off the clock signal.", "output": "module clock_gating_cell (\n  input clk, // clock signal\n  input en, // enable signal\n  output gclk // gated clock signal\n);\n\n  assign gclk = clk & en;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that takes in a 4-bit binary input and outputs the 2's complement of the input. The module should have the following interface:\n\nInputs:\n- `in`: a 4-bit binary input\n\nOutputs:\n- `out`: a 4-bit binary output representing the 2's complement of the input\n\nYour module should follow the following rules:\n1. The 2's complement of a binary number is obtained by inverting all the bits of the number and adding 1 to the result.\n2. The module should be synthesizable and should not use any behavioral constructs.\n3. The module should be named `twos_comp` and should be defined in a verilog file named `twos_comp.v`.\n\n", "output": "module twos_comp (\n    input [3:0] in,\n    output [3:0] out\n);\n\n    assign out = ~in + 4'b1;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit barrel shifter. The circuit should have two inputs, A and B, representing a 4-bit binary value and a 2-bit shift amount, respectively. The circuit should have one output, Q, representing the shifted value of A. The circuit should shift A left or right by the amount specified by B, with the shifted-in bits filled with zeros.", "output": "module barrel_shifter (\n    input [3:0] A,\n    input [1:0] B,\n    output [3:0] Q\n);\n\n    assign Q = (B[1]) ? ({A[1:0], A[3:2]}) >> B : (B[0]) ? A << B : A;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a clock divider for a SPI interface. The module should take in a clock signal `BUS_CLK` and output a divided clock signal `DIV_CLK`. The module should also have an input `BUS_RST` that asynchronously resets the module and sets `DIV_CLK` to 0. The module should have a parameter `DIVISOR` that determines the division factor of the clock. The module should be able to handle clock frequencies up to 100 MHz.\n\nYou are provided with a code snippet that implements a clock divider for a SPI interface as a reference. However, the code snippet implements other modules as well, and you should only focus on implementing the clock divider.\n\nYour module should be named `clock_divider` and have the following inputs and outputs:\n- `input wire CLK`: the input clock signal\n- `input wire RESET`: the asynchronous reset signal\n- `input wire CE`: the clock enable signal\n- `output wire CLOCK`: the divided clock signal\n\nYour module should be self-contained, and any necessary parameters or variables should be explicitly defined within the module.\n\n", "output": "module clock_divider (\n    input wire CLK,\n    input wire RESET,\n    input wire CE,\n    output wire CLOCK\n);\n\n    parameter DIVISOR = 8;\n    reg [DIVISOR-1:0] counter;\n    \n    always @(posedge CLK or negedge RESET) begin\n        if (!RESET) begin\n            counter <= 0;\n            CLOCK <= 0;\n        end else if (CE) begin\n            counter <= counter + 1;\n            if (counter == DIVISOR-1) begin\n                counter <= 0;\n                CLOCK <= ~CLOCK;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with implementing a Binary Exponentiation module in Verilog. The module should take two inputs, `base` and `exponent`, and calculate the result of `base` raised to the power of `exponent`. The module should also have a `reset` input that sets the output to 0 and a `clk` input that is used to synchronize the module.\n\nThe module should output two signals, `result` and `isDone`. The `result` signal should be a 100-bit wide wire that holds the result of the calculation. The `isDone` signal should be a wire that is high when the calculation is complete.\n\nThe module should be instantiated using the following code:\n\n```\nBinaryExponentiation uut (\n    .clk(clk),\n    .base(base), \n    .exponent(exponent), \n    .reset(reset),\n    .result(result), \n    .isDone(isDone)\n);\n```\n\nYou should test your module using the following test cases:\n\n1. `base = 2`, `exponent = 25`\n2. `base = 3`, `exponent = 17`\n3. `base = 5`, `exponent = 30`\n4. `base = 11`, `exponent = 1`\n\nYour implementation should be contained within a single Verilog module that is no more than 200 lines long.\n\n", "output": "module BinaryExponentiation (\n    input clk,\n    input [8:0] base,\n    input [7:0] exponent,\n    input reset,\n    output reg [99:0] result,\n    output reg isDone\n);\n\n    reg [7:0] count;\n    reg [99:0] temp;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n            result <= 0;\n            isDone <= 0;\n        end\n        else if (count < exponent) begin\n            temp <= result;\n            result <= (count == 0) ? base : result * base;\n            count <= count + 1;\n        end\n        else begin\n            isDone <= 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module to implement a simple memory interface. The module should have the following inputs and outputs:\n\nInputs:\n- `clka`: a clock signal\n- `wea`: a write enable signal (1-bit)\n- `addra`: a 14-bit address signal\n- `dina`: a 12-bit data input signal\n\nOutputs:\n- `douta`: a 12-bit data output signal\n\nThe module should behave as follows:\n- On the rising edge of `clka`, if `wea` is high, the data at `dina` should be written to the memory location specified by `addra`.\n- On the rising edge of `clka`, if `wea` is low, the data at the memory location specified by `addra` should be output on `douta`.\n\nAssume that the memory is byte-addressable and that each memory location can hold one byte of data. The memory should be initialized to all zeros at the start of simulation.\n\nWrite a Verilog module that implements this memory interface. Your module should be no longer than 200 lines of code.\n\n", "output": "module memory_interface(clka, wea, addra, dina, douta);\n  parameter MEM_SIZE = 2**14; // 14-bit address gives 2^14 memory locations\n  parameter MEM_WIDTH = 8; // each memory location holds 1 byte of data\n  reg [MEM_WIDTH-1:0] mem [0:MEM_SIZE-1]; // declare memory array\n\n  input clka;\n  input [0:0] wea;\n  input [13:0] addra;\n  input [11:0] dina;\n  output [11:0] douta;\n\n  assign douta = (wea == 1'b1) ? 12'hzzz : mem[addra][11:0]; // output data on douta\n\n  always @(posedge clka) begin\n    if (wea == 1'b1) begin // write to memory\n      mem[addra][7:0] <= dina[7:0];\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with implementing a flip-flop module in Verilog. The module should have the following inputs and outputs:\n\n- Inputs:\n  - `clk`: a clock signal\n  - `reset`: a reset signal\n  - `d`: a 17-bit input signal\n- Outputs:\n  - `q`: a 17-bit output signal\n\nThe module should have the following behavior:\n\n- When `reset` is asserted, the output `q` should be set to 0.\n- On each positive edge of the clock signal `clk`, the output `q` should be set to the value of the input `d`.\n\nYou should also include the following in your implementation:\n\n- The `q` output should be implemented using a `reg` variable.\n- The `reset` input should be active-low.\n\nPlease write the Verilog code for this module.\n\n", "output": "module flip_flop (clk, reset, d, q);\n  input clk;\n  input reset;\n  input [16:0] d;\n  output [16:0] q;\n  reg [16:0] q;\n\n  always @(posedge clk) begin\n    if (!reset)\n      q <= 17'b0;\n    else\n      q <= d;\n  end\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit shift register with parallel load and serial input/output. The module should have four inputs (D0-D3), one output (Q3), and one control input (shift). When shift is low, the module should load the value of D0-D3 into the shift register. When shift is high, the module should shift the contents of the register to the right, with the value of Q3 being output and the value of D3 being shifted into D0.", "output": "module shift_register (\n    input clk,\n    input shift,\n    input [3:0] D,\n    output reg Q3\n);\n\nreg [3:0] reg_data;\n\nalways @(posedge clk) begin\n    if (shift == 1'b0) begin\n        reg_data <= D;\n    end else begin\n        reg_data <= {reg_data[2:0], D[3]};\n    end\nend\n\nassign Q3 = reg_data[3];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit input and outputs the two's complement representation of the input. The module should have one input, a 4-bit binary number (D[3:0]), and one output, a 4-bit binary number (C[3:0]). The module should output the two's complement representation of the input, which is calculated by negating the input and adding 1.", "output": "module twos_comp (\n    input [3:0] D,\n    output reg [3:0] C\n);\n\n    always @(*) begin\n        C = ~D + 1;\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that implements a D flip-flop with enable and reset capabilities. The module should have the following inputs and outputs:\n\nInputs:\n- D (1-bit): data input\n- C (1-bit): clock input\n- E (1-bit): enable input\n- R (1-bit): reset input\n\nOutputs:\n- Q (1-bit): output\n\nThe module should implement the following behavior:\n- When the clock is rising edge triggered (C=1), the output Q should reflect the value of D if the enable input E is asserted (E=1). If E is deasserted (E=0), the output should hold its previous value.\n- When the reset input R is asserted (R=0), the output Q should be set to 0 regardless of the value of D or E.\n\nYour task is to write a Verilog module that implements this behavior. The module should be self-contained and should not rely on any external modules or libraries. Your implementation should be no more than 200 lines of Verilog code.\n\n", "output": "module dff_en_rst (\n    input D, C, E, R,\n    output Q\n);\n\nreg Q_reg;\n\nalways @(posedge C) begin\n    if (R == 0) begin\n        Q_reg <= 0;\n    end else if (E == 1) begin\n        Q_reg <= D;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit binary adder. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` (1 bit) - clock signal\n- `rst` (1 bit) - asynchronous reset signal\n- `a` (4 bits) - first input to the adder\n- `b` (4 bits) - second input to the adder\n\nOutputs:\n- `sum` (4 bits) - the sum of the two inputs\n- `carry_out` (1 bit) - the carry out bit\n\nThe module should use behavioral modeling and should be synthesizable. The adder should be able to handle both unsigned and signed inputs.\n\n", "output": "module binary_adder (\n    input clk,\n    input rst,\n    input signed [3:0] a,\n    input signed [3:0] b,\n    output signed [3:0] sum,\n    output carry_out\n);\n\n    reg signed [3:0] temp_sum;\n    reg carry;\n\n    always @ (posedge clk or negedge rst) begin\n        if (~rst) begin\n            temp_sum <= 4'b0;\n            carry <= 1'b0;\n        end\n        else begin\n            temp_sum <= a + b + carry;\n            carry <= (temp_sum[4] == 1);\n        end\n    end\n\n    assign sum = temp_sum;\n    assign carry_out = carry;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit comparator. The module should have two inputs: two 4-bit operands. The module should have three outputs: a greater than flag (1 if the first operand is greater than the second, 0 otherwise), a less than flag (1 if the first operand is less than the second, 0 otherwise), and an equal flag (1 if the operands are equal, 0 otherwise).", "output": "module comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if(a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end\n        else if(a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end\n        else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit adder with carry. The module should have the following inputs and outputs:\n\nInputs:\n- `A`: a 4-bit binary number\n- `B`: a 4-bit binary number\n- `Cin`: a binary carry-in value (0 or 1)\n\nOutputs:\n- `Sum`: a 4-bit binary number representing the sum of `A` and `B`\n- `Cout`: a binary carry-out value (0 or 1)\n\nThe module should be named `four_bit_adder` and should be implemented in a single Verilog file with no more than 200 lines of code.\n\nAssume that the input values `A` and `B` are valid 4-bit binary numbers (i.e., they will never exceed the range of 0-15), and that the input value `Cin` is a valid binary number (either 0 or 1).\n\n", "output": "module four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [3:0] sum_wire;\n  wire carry_wire;\n\n  assign sum_wire = A + B + Cin;\n  assign Cout = sum_wire[4];\n  assign Sum = sum_wire[3:0];\n\nendmodule"}
{"instruction": "\n\nDesign a Verilog module that takes a 4-bit input `data_in` and outputs a 2-bit value `data_out`. The `data_out` value should be determined based on the following rules:\n- If the input value is less than or equal to 4, the output should be 00.\n- If the input value is between 5 and 8 (inclusive), the output should be 01.\n- If the input value is between 9 and 12 (inclusive), the output should be 10.\n- If the input value is greater than 12, the output should be 11.\n\nYour module should be named `data_converter` and should have the following interface:\n- `data_in`: a 4-bit input.\n- `data_out`: a 2-bit output.\n\nYou may assume that the input value will always be a valid 4-bit binary number.\n\n", "output": "module data_converter (\n    input [3:0] data_in,\n    output [1:0] data_out\n);\n\n    always @* begin\n        if (data_in <= 4) begin\n            data_out = 2'b00;\n        end else if (data_in <= 8) begin\n            data_out = 2'b01;\n        end else if (data_in <= 12) begin\n            data_out = 2'b10;\n        end else begin\n            data_out = 2'b11;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a circuit that utilizes a D flip-flop with a set and clear function. The module should take in a clock signal (`CLK`), a data input (`D`), a set input (`SET`), and a clear input (`CLR`). The output of the module should be the output of the D flip-flop (`Q`).\n\nThe circuit should operate as follows:\n- When `SET` is high, the output `Q` should be set to high, regardless of the value of `D`.\n- When `CLR` is high, the output `Q` should be set to low, regardless of the value of `D`.\n- When both `SET` and `CLR` are low, the output `Q` should follow the input `D` on the positive edge of the clock signal.\n\nYou should create a module that implements this circuit, using the provided code snippet as a reference. The module should be named `d_ff_set_clr` and should have the following inputs and outputs:\n- `CLK`: a single-bit input representing the clock signal.\n- `D`: a single-bit input representing the data input.\n- `SET`: a single-bit input representing the set input.\n- `CLR`: a single-bit input representing the clear input.\n- `Q`: a single-bit output representing the output of the D flip-flop.\n\nYour module should only use combinational logic and should not use any other modules.\n\n", "output": "module d_ff_set_clr (\n    input CLK,\n    input D,\n    input SET,\n    input CLR,\n    output reg Q\n);\n\n    always @(posedge CLK) begin\n        if (SET) begin\n            Q <= 1'b1;\n        end else if (CLR) begin\n            Q <= 1'b0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-to-2 priority encoder. The module should have four inputs (A, B, C, and D) and two outputs (Y1 and Y0). The output Y1 should be high if the input with the highest priority is active (D has the highest priority, followed by C, then B, then A). If multiple inputs are active, the output Y1 should be high for the input with the highest priority. The output Y0 should be high for the input with the next highest priority.", "output": "module priority_encoder (\n    input A, B, C, D,\n    output reg Y1,\n    output reg Y0\n);\n\nalways @(*) begin\n    case ({D, C, B, A})\n        4'b0001: begin\n            Y1 = 1;\n            Y0 = 0;\n        end\n        4'b0010: begin\n            Y1 = 0;\n            Y0 = 1;\n        end\n        4'b0100, 4'b1000, 4'b1100, 4'b1010, 4'b1001, 4'b0110, 4'b0101, 4'b0011: begin\n            Y1 = 0;\n            Y0 = 0;\n        end\n        default: begin\n            Y1 = 0;\n            Y0 = 0;\n        end\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-to-1 multiplexer using if-else statements. The module should have two 2-bit inputs 'a' and 'b', a 2-bit select input 'sel', and a 2-bit output 'out'. When 'sel' is 00, the value of 'out' is equal to the value of 'a' when 'sel' is 01, the value of 'out' is equal to the value of 'b' when 'sel' is 10, the value of 'out' is equal to the bitwise AND of 'a' and 'b', and when 'sel' is 11, the value of 'out' is equal to the bitwise OR of 'a' and 'b'.", "output": "module mux_4to1_if_else (\n  input [1:0] a,\n  input [1:0] b,\n  input [1:0] sel,\n  output reg [1:0] out\n);\n\n  always @(*) begin\n    if(sel == 2'b00) begin\n      out = a;\n    end\n    else if(sel == 2'b01) begin\n      out = b;\n    end\n    else if(sel == 2'b10) begin\n      out = a & b;\n    end\n    else begin // sel == 2'b11\n      out = a | b;\n    end\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit shift register with a parallel load input. The module should have three inputs (DATA, SHIFT, and LOAD) and one output (Q). The SHIFT input should determine the direction and amount of the shift (0 = no shift, 1 = shift left by 1). The LOAD input should load the data into the shift register when it is high. Hint: Use a case statement to implement the shift and load logic.", "output": "module shift_register (\n    input [3:0] DATA,\n    input SHIFT,\n    input LOAD,\n    output reg [3:0] Q\n);\n\n    always @ (posedge SHIFT or posedge LOAD)\n    begin\n        case (SHIFT)\n            1'b0: Q <= {Q[2:0], Q[3]};\n            1'b1: Q <= {Q[1:0], DATA[3:2]};\n        endcase\n        \n        if (LOAD)\n            Q <= DATA;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a D flip-flop with asynchronous reset and set. The module should have the following inputs and outputs:\n\n- `D`: input data signal\n- `CLK`: input clock signal\n- `RESET`: asynchronous reset signal\n- `SET`: asynchronous set signal\n- `Q`: output data signal\n- `Q_N`: output inverted data signal\n\nThe module should follow the following specifications:\n- The flip-flop should be implemented using a positive-edge triggered clock\n- The output should be updated on the rising edge of the clock signal\n- When the reset signal is asserted (`RESET=0`), the output should be set to 0\n- When the set signal is asserted (`SET=0`), the output should be set to 1\n- When both reset and set signals are asserted at the same time, the output should be set to 0\n\nYou should implement the module in Verilog within 200 lines of code.\n\n", "output": "module d_ff_async_reset_set (\n    input D,\n    input CLK,\n    input RESET,\n    input SET,\n    output Q,\n    output Q_N\n);\n\n    reg Q;\n    wire Q_N;\n\n    assign Q_N = ~Q;\n\n    always @(posedge CLK or negedge RESET or negedge SET) begin\n        if (!RESET) begin\n            Q <= 0;\n        end else if (!SET) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a NAND gate with four inputs. The module should take four inputs, A, B, C, and D, and output the result of the NAND operation on all four inputs, which will be denoted as Y. You have been given a code snippet to use as a starting point, which includes the necessary input and output declarations, as well as voltage supply signals.\n\nYour task is to complete the module by writing the Verilog code that implements the NAND operation. The NAND operation should be performed on all four inputs, and the result should be output through the Y port. Your implementation should be efficient and use the minimum number of gates possible.\n\nAssume that the inputs are valid and will always be either 0 or 1.\n\n", "output": "module nand4 (\n    Y  ,\n    A  ,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Perform NAND operation\n    wire nand1, nand2, nand3, nand4;\n    assign nand1 = ~(A & B);\n    assign nand2 = ~(nand1 & C);\n    assign nand3 = ~(nand2 & D);\n    assign nand4 = ~nand3;\n    assign Y = nand4;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a shift register with parallel load functionality using Verilog. The module should have the following ports:\n\n- `CLK`: input clock signal\n- `LOAD`: input signal that enables parallel loading of data\n- `DATA_IN`: input data signal to be loaded in parallel\n- `SER_IN`: input data signal to be shifted in\n- `SER_OUT`: output data signal shifted out\n- `Q`: output parallel data signal\n\nThe shift register should have a length of 8 bits and should shift data in on the rising edge of the clock. When the `LOAD` signal is high, the `DATA_IN` signal should be loaded in parallel to the shift register. The `Q` output should reflect the parallel data loaded into the shift register. The output `SER_OUT` should be the bit shifted out of the shift register.\n\nWrite a Verilog module that implements the above shift register with parallel load functionality.\n\n", "output": "module shift_register (\n    input CLK,\n    input LOAD,\n    input [7:0] DATA_IN,\n    input SER_IN,\n    output reg SER_OUT,\n    output reg [7:0] Q\n);\n\n    reg [7:0] register;\n\n    always @(posedge CLK) begin\n        if (LOAD) begin\n            register <= DATA_IN;\n            Q <= DATA_IN;\n        end\n        else begin\n            register <= {register[6:0], SER_IN};\n            Q <= register;\n        end\n        SER_OUT <= register[0];\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module to implement a Hamming Decoder with 4-bit data output. The decoder should take in a 7-bit Hamming code as input and output the corresponding 4-bit data. The Hamming code is represented by an input vector H, and the decoded data is represented by an output vector D.\n\nYou should implement the Hamming code decoding algorithm using the following equations:\n\nD[3] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0])  ? ~H[6] : H[6];\n\nD[2] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&!(H[6]^H[4]^H[3]^H[0]) ? ~H[5] : H[5];\n\nD[1] = (H[6]^H[5]^H[4]^H[2])&!(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[4] : H[4];\n\nD[0] = !(H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[3] : H[3];\n\nWrite a verilog module named \"HammingDecoder\" that implements the above algorithm and takes in a 7-bit input vector H and outputs a 4-bit output vector D.\n\n", "output": "module HammingDecoder(H, D);\n\tinput [6:0] H;\n\toutput [3:0] D;\n\t\n\tassign D[3] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0])  ? ~H[6] : H[6];\n\tassign D[2] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&!(H[6]^H[4]^H[3]^H[0]) ? ~H[5] : H[5];\n\tassign D[1] = (H[6]^H[5]^H[4]^H[2])&!(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[4] : H[4];\n\tassign D[0] = !(H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[3] : H[3];\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit up counter with asynchronous reset and load functionality. The counter should increment on the positive edge of the clock input and reset to 0 when the reset input is asserted. Additionally, the counter should be able to load a new value from a load input when it is asserted on the positive edge of the clock.", "output": "module up_counter (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] load_value,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      count <= 4'b0000;\n    end else if (load == 1) begin\n      count <= load_value;\n    end else begin\n      count <= count + 1;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou have been tasked with designing a module in Verilog that checks whether a given timeunit is equal to 10fs. The module should output a single bit signal that is high if the timeunit is 10fs and low otherwise. Your module should only be 200 lines or less in length.\n\nTo help you get started, the code snippet provided defines a module called `check_10fs` and sets the timeunit to 10fs.\n\nWrite a Verilog module that takes a single input parameter `timeunit` and outputs a single bit signal `is_10fs`. The `timeunit` parameter is a 64-bit unsigned integer representing time in femtoseconds. The `is_10fs` output should be high if `timeunit` is exactly equal to 10fs, and low otherwise.\n\nYour module should be named `check_10fs` and should be self-contained, i.e., it should not rely on any external modules or testbenches.\n\n", "output": "module check_10fs(\n  input logic [63:0] timeunit,\n  output logic is_10fs\n);\n\n  // Define a constant for 10fs\n  localparam TIMEUNIT_10FS = 64'h2710A3D70A3D70A4;\n\n  // Compare the input timeunit to 10fs\n  assign is_10fs = (timeunit == TIMEUNIT_10FS);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in a 4-bit input and outputs the same 4-bit value, but with the bits reversed. You must use only combinational logic and no sequential elements such as flip-flops or latches. You may use any standard logic gates such as AND, OR, NOT, XOR, and any other combinational logic gates available in Verilog.\n\nDesign a module named \"reverse4bits\" with the following ports:\n- input [3:0] in: the 4-bit input to be reversed\n- output [3:0] out: the 4-bit output with the bits reversed\n\nYour module should have the following behavior:\n- When the input is 4'b0000, the output should be 4'b0000\n- When the input is 4'b0001, the output should be 4'b1000\n- When the input is 4'b0010, the output should be 4'b0100\n- When the input is 4'b0100, the output should be 4'b0010\n- When the input is 4'b1000, the output should be 4'b0001\n- When the input is 4'b1010, the output should be 4'b0101\n- When the input is 4'b1111, the output should be 4'b1111\n\n", "output": "module reverse4bits(\n  input [3:0] in,\n  output [3:0] out\n);\n\n  assign out[0] = in[3];\n  assign out[1] = in[2];\n  assign out[2] = in[1];\n  assign out[3] = in[0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital circuit for a D flip-flop that has a synchronous reset input. The flip-flop should be able to store a single bit of information (0 or 1) and output both the stored value and its complement. The circuit should be implemented using Verilog.\n\nThe D flip-flop should have the following inputs:\n- D: the data input\n- clk: the clock input\n- reset: the synchronous reset input\n\nThe flip-flop should have the following outputs:\n- Q: the stored value\n- Q_n: the complement of the stored value\n\nDesign and implement the D flip-flop in Verilog using only one module. You are not allowed to use any other modules in the implementation. You should also write a testbench to verify the functionality of your design.\n\n", "output": "module dflipflop (\n    input D,\n    input clk,\n    input reset,\n    output reg Q,\n    output reg Q_n\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        Q <= 0;\n        Q_n <= 1;\n    end else begin\n        Q <= D;\n        Q_n <= ~D;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked to design a verilog module that implements a 2-to-1 multiplexer using a sky130_fd_sc_ms__ebufn_1 buffer. The module should have the following ports:\n\n- `input [1:0] A`\n- `input S`\n- `output Z`\n\nWhere `A` is the 2-bit input bus, `S` is the select signal, and `Z` is the output.\n\nUse the `sky130_fd_sc_ms__ebufn_1` buffer provided in the code snippet as the building block for your multiplexer.\n\nImplement the module and ensure that it meets the following requirements:\n\n- When `S` is 0, `Z` should be equal to `A[0]`\n- When `S` is 1, `Z` should be equal to `A[1]`\n\n", "output": "module mux_2to1 (\n    input [1:0] A,\n    input S,\n    output Z\n);\n\n    wire A0 = A[0];\n    wire A1 = A[1];\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ms__ebufn_1 buf (\n        .Z(Z),\n        .A(S ? A1 : A0),\n        .TE_B(1'b1)\n    );\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in several inputs and produces an output. The module should be named `output_module` and should have the following inputs and outputs:\n\nInputs:\n- `input_a`: a single bit input\n- `input_b`: a 4-bit input\n- `input_c`: an 8-bit input\n- `input_d`: a 16-bit input\n\nOutputs:\n- `output_x`: a single bit output\n- `output_y`: a 4-bit output\n- `output_z`: an 8-bit output\n\nThe module should perform the following operations:\n1. If `input_a` is 0, set `output_x` to 1. Otherwise, set `output_x` to 0.\n2. Set `output_y` to the 4 most significant bits of `input_b`.\n3. Set `output_z` to the bitwise OR of `input_c` and `input_d`.\n\nYour task is to implement the `output_module` module that satisfies the above requirements.\n\n", "output": "module output_module(input input_a, input [3:0] input_b, input [7:0] input_c, input [15:0] input_d, output reg output_x, output reg [3:0] output_y, output reg [7:0] output_z);\n\nalways @(*)\nbegin\n    if(input_a == 0)\n        output_x = 1;\n    else\n        output_x = 0;\n    output_y = input_b[3:0];\n    output_z = input_c | input_d[7:0];\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital circuit that implements a D flip-flop with asynchronous reset and set capabilities. The circuit should have the following inputs and outputs:\n\n- Inputs: \n  - `CLK`: clock signal\n  - `D`: data input\n  - `SET_B`: asynchronous set input (active low)\n  - `RESET_B`: asynchronous reset input (active low)\n- Outputs:\n  - `Q`: output\n  - `Q_N`: complement of output\n\nYou should implement this circuit as a single module in Verilog. The module should be named `d_ff_arst` and should have the following interface:\n\n```\nmodule d_ff_arst (\n    input CLK,\n    input D,\n    input SET_B,\n    input RESET_B,\n    output reg Q,\n    output reg Q_N\n);\n```\n\nThe circuit should behave as follows:\n\n- When `SET_B` is asserted (low), the output `Q` should be set to 1 and `Q_N` should be set to 0, regardless of the values of `CLK`, `D`, and `RESET_B`.\n- When `RESET_B` is asserted (low), the output `Q` should be set to 0 and `Q_N` should be set to 1, regardless of the values of `CLK`, `D`, and `SET_B`.\n- When neither `SET_B` nor `RESET_B` is asserted, the circuit should behave as a standard D flip-flop with positive-edge triggered clock. That is, on the rising edge of `CLK`, the output `Q` should be updated with the value of `D`, and `Q_N` should be updated with the complement of `D`.\n\nImplement a Verilog module that meets these specifications. Your solution should not use any other modules or external components. You may use any Verilog constructs or features that are available in the IEEE 1364-2005 standard.\n\n", "output": "module d_ff_arst (\n    input CLK,\n    input D,\n    input SET_B,\n    input RESET_B,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK or negedge SET_B or negedge RESET_B) begin\n        if (!SET_B) begin\n            Q <= 1;\n            Q_N <= 0;\n        end else if (!RESET_B) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary to gray code converter. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `reset`: a reset signal that sets the output to 0\n- `bin_in`: a 4-bit binary input\n\nOutputs:\n- `gray_out`: a 4-bit gray code output\n\nThe module should convert the binary input to its corresponding gray code output. The module should operate on the rising edge of the clock signal. When the reset signal is high, the module should set the output to 0.\n\n", "output": "module bin_to_gray(clk, reset, bin_in, gray_out);\n\nparameter DATA_WIDTH = 4;\n\ninput clk;\ninput reset;\ninput [DATA_WIDTH-1:0] bin_in;\n\noutput [DATA_WIDTH-1:0] gray_out;\n\nreg [DATA_WIDTH-1:0] gray_out;\n\nalways @(posedge clk)\nbegin\n    if(reset)\n    begin\n        gray_out <= 0;\n    end\n    else\n    begin\n        gray_out <= bin_in ^ (bin_in >> 1);\n    end\nend\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, it is common to use a tap point to measure the voltage of a node. A tap point is a connection to a node that allows a voltage measurement to be taken without disrupting the operation of the circuit. In this problem, you are tasked with designing a module that implements a tap point for a voltage source and ground.\n\nYou need to design a Verilog module named `tap_point` that has the following inputs and outputs:\n\n- `vin`: a 1-bit input that represents the voltage source\n- `gnd`: a 1-bit input that represents the ground\n- `tap`: a 1-bit output that represents the tap point voltage\n\nThe `tap_point` module should implement a tap point that measures the voltage between `vin` and `gnd`. The `tap` output should be equal to `vin` when `vin` is greater than `gnd`, and equal to `gnd` when `vin` is less than or equal to `gnd`.\n\nYour implementation should be contained within a single Verilog module that is no more than 200 lines of code.\n\n", "output": "module tap_point(\n    input vin,\n    input gnd,\n    output tap\n);\n    wire vin_gnd;\n    assign vin_gnd = vin - gnd;\n    assign tap = vin_gnd ? vin : gnd;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a 4-bit counter with a synchronous reset and an asynchronous enable input. The counter should increment on every rising edge of the clock signal and should reset to 0 when the reset input is asserted. The asynchronous enable input should allow the counter to be paused and resumed at any value.\n\nThe module should have the following inputs and outputs:\n\n- `clk`: a 1-bit input representing the clock signal\n- `rst`: a 1-bit input representing the synchronous reset signal\n- `en`: a 1-bit input representing the asynchronous enable signal\n- `out`: a 4-bit output representing the counter value\n\nYou should implement the module using behavioral Verilog code.\n\n", "output": "module counter_4bit(\n  input clk, rst, en,\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst)\n  begin\n    if (!rst) // synchronous reset\n      out <= 4'b0;\n    else if (en) // asynchronous enable\n      out <= out + 1;\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in a 4-bit input signal `in`, and outputs a 2-bit signal `out` based on the following conditions:\n- If the input signal is less than 5, output `00`.\n- If the input signal is between 5 and 9 (inclusive), output `01`.\n- If the input signal is greater than 9, output `10`.\n\nWrite a verilog module `signal_converter` that implements this functionality. \n\n", "output": "module signal_converter(\n    input [3:0] in,\n    output reg [1:0] out\n);\n\nalways @(*) begin\n    case (in)\n        4'd0: out = 2'b00;\n        4'd1: out = 2'b00;\n        4'd2: out = 2'b00;\n        4'd3: out = 2'b00;\n        4'd4: out = 2'b00;\n        4'd5: out = 2'b01;\n        4'd6: out = 2'b01;\n        4'd7: out = 2'b01;\n        4'd8: out = 2'b01;\n        4'd9: out = 2'b01;\n        default: out = 2'b10;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple circuit that implements a D-latch with a gated enable. The circuit should have one input, one output, and two control signals. The input signal, denoted D, is the data input to the latch, while the output signal, denoted Q, is the output of the latch. The two control signals are a clock enable signal, denoted G, and a clock signal, which is implied to be connected to the clock input of the latch.\n\nThe circuit should have the following behavior:\n- When the clock enable signal, G, is high, the latch should be transparent, meaning that the output, Q, should follow the input, D.\n- When the clock enable signal, G, is low, the latch should hold its previous state, regardless of the input, D.\n\nImplement the circuit as a verilog module named \"gated_d_latch\", and ensure that the module has the following ports:\n- D: the data input to the latch, a single bit\n- G: the clock enable input to the latch, a single bit\n- CLK: the clock input to the latch, a single bit\n- Q: the output of the latch, a single bit\n\nYour implementation should be contained within 200 lines of verilog code.\n\n", "output": "module gated_d_latch (\n  input D, G, CLK,\n  output Q\n);\n\n  reg Q_int;\n  \n  always @(posedge CLK) begin\n    if (G) begin\n      Q_int <= D;\n    end\n  end\n  \n  assign Q = Q_int;\n  \nendmodule"}
{"instruction": "Design a system that includes two 8-bit adders and a control logic module. The adders should have active high synchronous reset and should add two 8-bit inputs together. The control logic module should enable only one of the adders at a time based on a select input. The output should be the sum of the active adder.", "output": "module top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] a,\n    input [7:0] b,\n    input select, // Select input to choose between adder1 and adder2\n    output [7:0] out\n);\n\nreg [7:0] sum1, sum2;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        sum1 <= 8'b0;\n        sum2 <= 8'b0;\n    end else begin\n        if (select) begin\n            sum1 <= a + b;\n        end else begin\n            sum2 <= a + b;\n        end\n    end\nend\n\nassign out = select ? sum1 : sum2;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit binary adder. The module should have two 4-bit inputs, A and B, and one 4-bit output, S. The output should be the sum of A and B in binary form. If the sum is greater than 15 (binary 1111), the output should be truncated to 4 bits. \n\nCreate a verilog module that implements the above functionality. \n\n", "output": "module binary_adder (A, B, S);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] S;\n\nwire [4:0] temp_sum;\n\nassign temp_sum = A + B; //sum of A and B\n\nalways @(*) begin\n    if(temp_sum > 15) //truncate if sum is greater than 15\n        S = temp_sum[3:0];\n    else\n        S = temp_sum[3:0];\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a priority encoder that detects the highest priority input bit and sets the output to the corresponding bit position. If multiple input bits are high, the highest bit position will be selected as output. For example, if input \"in\" is a 4-bit vector, and bit 2 and bit 3 are high, the output \"pos\" should be set to 3. If bit 0 and bit 2 are high, the output should be set to 2. If no input bits are high, the output should be set to 0.", "output": "module priority_encoder (\n  input [3:0] in,\n  output reg [1:0] pos\n);\n\n  always @(*) begin\n    case(in)\n      4'b0001: pos = 2'b00;\n      4'b0010: pos = 2'b01;\n      4'b0100: pos = 2'b10;\n      4'b1000: pos = 2'b11;\n      4'b0011: pos = 2'b01;\n      4'b0101: pos = 2'b10;\n      4'b0110: pos = 2'b10;\n      4'b1001: pos = 2'b11;\n      4'b1010: pos = 2'b11;\n      4'b1100: pos = 2'b11;\n      default: pos = 2'b00;\n    endcase\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a parameterized Verilog module that adds two 26-bit numbers using registers. The module should have the following inputs and outputs:\n\nInputs:\n- `CLK`: a clock signal\n- `A`: a 26-bit input number\n- `B`: a 26-bit input number\n- `RESET`: a reset signal\n\nOutputs:\n- `SUM`: a 26-bit output representing the sum of `A` and `B`\n\nThe module should use registers to store the input values and the intermediate sum. The module should only output the sum when the `RESET` signal is low and the clock signal is rising edge.\n\nUse the following module declaration as a starting point:\n\n```\nmodule RegisterAdd #(parameter WIDTH=26) (\n    input CLK,\n    input RESET,\n    input [WIDTH-1:0] A,\n    input [WIDTH-1:0] B,\n    output reg [WIDTH-1:0] SUM\n    );\n\n    // Your code here\n\nendmodule\n```\n\n", "output": "module RegisterAdd #(parameter WIDTH=26) (\n    input CLK,\n    input RESET,\n    input [WIDTH-1:0] A,\n    input [WIDTH-1:0] B,\n    output reg [WIDTH-1:0] SUM\n    );\n\n    always @(posedge CLK) begin\n        if (RESET == 0) begin\n            SUM <= 0;\n        end else begin\n            SUM <= A + B;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a simple circuit to control a motor. The motor can be turned on or off using a single input signal, and its current state can be read using a single output signal. The module should also include a clock input and a reset input.\n\nThe module should have the following inputs and outputs:\n- clk: a clock input\n- rst: a reset input\n- motor_ctrl: a single bit input signal that controls the motor\n- motor_state: a single bit output signal that indicates the current state of the motor (1 for on, 0 for off)\n\nThe module should have the following behavior:\n- When the reset input is high, the motor should be turned off and the motor_state output should be 0.\n- When the motor_ctrl input is high, the motor should be turned on and the motor_state output should be 1.\n- When the motor_ctrl input is low, the motor should be turned off and the motor_state output should be 0.\n- The motor should only change state on the rising edge of the clock input.\n\nWrite the verilog code for the module described above. \n\n", "output": "module motor_controller(\n    input clk,\n    input rst,\n    input motor_ctrl,\n    output reg motor_state\n);\n\nalways @(posedge clk, posedge rst) begin\n    if (rst) begin\n        motor_state <= 0;\n    end else begin\n        if (motor_ctrl) begin\n            motor_state <= 1;\n        end else begin\n            motor_state <= 0;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in 5 input signals (A1, A2, A3, B1, B2) and outputs a single signal (Y). The module should be named \"five_to_one\" and should be implemented within 200 lines of Verilog code. The input signals can be either 0 or 1, and the output signal should also be either 0 or 1. The module should include voltage supply signals VPWR, VGND, VPB, and VNB. \n\nYour task is to implement the \"five_to_one\" module in Verilog and ensure that it meets the following requirements:\n1. If A1, A2, and A3 are all 0, Y should be 0.\n2. If B1 and B2 are both 1, Y should be 1.\n3. If A1 is 1 and A2 and A3 are both 0, Y should be 1.\n4. If A1 is 0 and A2 and A3 are both 1, Y should be 1.\n5. If none of the above conditions are met, Y should be 0.\n\n", "output": "module five_to_one (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Implementing the logic\n    assign Y = ((A1 & !A2 & !A3) | (B1 & B2) | (A1 & !A2 & A3) | (!A1 & A2 & A3)) ? 1 : 0;\n\nendmodule"}
{"instruction": "\n\nYou have been hired by a company to design a module that performs arithmetic subtraction of two 4-bit buses. The module should take two 4-bit buses as inputs and produce two 4-bit buses as outputs. Write a Verilog module that performs this subtraction operation and meets the following requirements:\n\n- The module should be named \"sub4\".\n- The module should have two 4-bit input buses named \"in1\" and \"in2\".\n- The module should have two 4-bit output buses named \"out1\" and \"out2\".\n- The module should perform the subtraction operation of in1 - in2 and store the result in out1. The subtraction operation of in2 - in1 should be stored in out2.\n- The module should be synthesizable.\n\nWrite the Verilog code for the \"sub4\" module that meets the above requirements.\n\n", "output": "module sub4 (\n   input [3:0] in1,\n   input [3:0] in2,\n   output [3:0] out1,\n   output [3:0] out2\n   );\n\n   assign out1 = in1 - in2;\n   assign out2 = in2 - in1;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a Verilog module for a simple digital circuit that takes in a 4-bit input and outputs a 3-bit value. The circuit should perform the following operation: \n- If the input is less than or equal to 7 (0b0111), output the input value as a 3-bit number (i.e. pad with leading zeros if necessary).\n- If the input is greater than 7, output the value 0b111.\n\nYour module should be named \"simple_circuit\" and should include the following inputs and outputs:\n- input [3:0] in_value: 4-bit input value\n- output [2:0] out_value: 3-bit output value\n\nYour module should be implemented using only combinational logic (no state elements such as flip-flops).\n\n", "output": "module simple_circuit(\n    input [3:0] in_value,\n    output [2:0] out_value\n);\n\n    assign out_value = (in_value <= 7) ? {3'b0, in_value} : 3'b111;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in a 4-bit binary input `in` and outputs a 2-bit binary value `out`. The output should be the two least significant bits of the input, i.e. `out = in[1:0]`.\n\nYour module should be named `bin2two` and should have the following inputs and outputs:\n- `input [3:0] in`: a 4-bit binary input\n- `output [1:0] out`: a 2-bit binary output\n\nYour module should be able to handle all possible input values.\n\nWrite a Verilog module that solves this problem within 200 lines of code.\n\n", "output": "module bin2two (\n    input [3:0] in,\n    output [1:0] out\n);\n\nassign out = in[1:0];\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that implements a 2-bit adder with carry-in and carry-out functionality. The module should take in two 2-bit inputs, a carry-in signal, and a clock signal, and output a 2-bit sum and a carry-out signal. \n\nThe module should be named \"two_bit_adder\" and should have the following inputs and outputs:\n- Inputs: \n  - `a`: a 2-bit input \n  - `b`: a 2-bit input \n  - `cin`: a carry-in signal \n  - `clk`: a clock signal \n- Outputs:\n  - `sum`: a 2-bit output representing the sum of `a` and `b`\n  - `cout`: a carry-out signal \n\nYour module should be implemented using only combinational logic and should not use any built-in arithmetic operators or functions. You may use any other logical operators or functions available in Verilog. \n\nYour implementation should be contained within 200 lines of Verilog code.\n\n", "output": "module two_bit_adder(\n  input [1:0] a,\n  input [1:0] b,\n  input cin,\n  input clk,\n  output reg [1:0] sum,\n  output reg cout\n);\n\n  always @(posedge clk) begin\n    // calculate the sum\n    sum[0] <= a[0] ^ b[0] ^ cin;\n    sum[1] <= a[1] ^ b[1] ^ (a[0] & b[0]) ^ (a[0] & cin) ^ (b[0] & cin);\n\n    // calculate the carry-out\n    cout <= (a[0] & b[0]) | (a[1] & b[0]) | (a[0] & cin) | (a[1] & cin) | (b[1] & cin);\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-bit binary adder with carry. The module should have two 4-bit inputs (A and B) and a 1-bit input (CIN) for carry-in. The module should output a 4-bit sum (S) and a 1-bit carry-out (COUT). The adder should use full-adder logic and be implemented using behavioral modeling.\n\nCreate a verilog module that meets the above requirements and name it \"binary_adder\". Ensure that the module includes the following:\n- Inputs: A (4-bit), B (4-bit), CIN (1-bit)\n- Outputs: S (4-bit), COUT (1-bit)\n- Use behavioral modeling to implement the full-adder logic\n- Use appropriate signal names and data types\n\n", "output": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output reg [3:0] S,\n    output reg COUT\n);\n\n    reg CARRY;\n    \n    always @(*) begin\n        S[0] = A[0] ^ B[0] ^ CIN;\n        CARRY = (A[0] & B[0]) | (A[0] & CIN) | (B[0] & CIN);\n        S[1] = A[1] ^ B[1] ^ CARRY;\n        CARRY = (A[1] & B[1]) | (A[1] & CARRY) | (B[1] & CARRY);\n        S[2] = A[2] ^ B[2] ^ CARRY;\n        CARRY = (A[2] & B[2]) | (A[2] & CARRY) | (B[2] & CARRY);\n        S[3] = A[3] ^ B[3] ^ CARRY;\n        COUT = (A[3] & B[3]) | (A[3] & CARRY) | (B[3] & CARRY);\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two 8-bit inputs and outputs the result of multiplying them together. The inputs are signed two's complement numbers. You must implement this using a combinational circuit. \n\nYour module should be named `signed_multiplier` and should have the following interface:\n\nInputs:\n- `clk`: a clock signal\n- `reset`: a synchronous reset signal\n- `in1`: an 8-bit signed two's complement input\n- `in2`: an 8-bit signed two's complement input\n\nOutputs:\n- `out`: a 16-bit signed two's complement output representing the product of the two inputs\n\nYou may assume that the inputs will always be valid signed two's complement numbers and that overflow will not occur.\n\n", "output": "module signed_multiplier(\n    input clk,\n    input reset,\n    input signed [7:0] in1,\n    input signed [7:0] in2,\n    output signed [15:0] out\n);\n\n    assign out = in1 * in2;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that generates a pulse of a specified width when a trigger signal is received. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a 50MHz clock signal\n- `trigger`: a 1-bit trigger signal that goes high for a single clock cycle when the pulse is to be generated\n- `pulse_width`: a 16-bit value that specifies the width of the pulse in clock cycles\n\nOutputs:\n- `pulse`: a 1-bit signal that goes high when the pulse is being generated\n\nDesign the module and write a testbench to verify its functionality. Use the following template for your testbench:\n\n```\nmodule pulse_gen_tb();\n\nreg clk = 0;\nreg trigger = 0;\nreg [15:0] pulse_width = 0;\nwire pulse;\n\npulse_gen dut(\n  .clk(clk),\n  .trigger(trigger),\n  .pulse_width(pulse_width),\n  .pulse(pulse)\n);\n\nalways #10 clk = ~clk;\n\ninitial begin\n  $dumpfile(\"pulse_gen_tb.vcd\");\n  $dumpvars(0, pulse_gen_tb);\n\n  //-- Test case 1: pulse_width = 10\n  pulse_width = 10;\n  #100 trigger = 1;\n  #10 trigger = 0;\n  #100 $display(\"Test case 1: pulse_width = %d, pulse = %d\", pulse_width, pulse);\n\n  //-- Test case 2: pulse_width = 20\n  pulse_width = 20;\n  #100 trigger = 1;\n  #10 trigger = 0;\n  #100 $display(\"Test case 2: pulse_width = %d, pulse = %d\", pulse_width, pulse);\n\n  //-- Test case 3: pulse_width = 30\n  pulse_width = 30;\n  #100 trigger = 1;\n  #10 trigger = 0;\n  #100 $display(\"Test case 3: pulse_width = %d, pulse = %d\", pulse_width, pulse);\n\n  $finish;\nend\n\nendmodule\n```\n\n", "output": "module pulse_gen(\n  input clk,\n  input trigger,\n  input [15:0] pulse_width,\n  output reg pulse\n);\n\nreg [15:0] counter = 0;\nreg pulse_gen = 0;\n\nalways @(posedge clk) begin\n  if (trigger) begin\n    pulse_gen <= 1;\n    counter <= 0;\n  end else begin\n    if (counter >= pulse_width) begin\n      pulse_gen <= 0;\n    end\n    counter <= counter + 1;\n  end\nend\n\nalways @(posedge clk) begin\n  pulse <= pulse_gen;\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit binary to Gray code converter. The module should have the following ports:\n\n- `in`: a 4-bit input representing the binary number\n- `out`: a 4-bit output representing the Gray code equivalent of the input\n\nThe module should use combinational logic to convert the binary input to Gray code output. The module should be named `bin2gray`.\n\nWrite the Verilog code for the `bin2gray` module and test it using a Verilog testbench.\n\n", "output": "module bin2gray(\n    input [3:0] in,\n    output [3:0] out\n);\n\nassign out[0] = in[0];\nassign out[1] = in[0] ^ in[1];\nassign out[2] = in[1] ^ in[2];\nassign out[3] = in[2] ^ in[3];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in 3 input signals and produces 2 output signals. The module should be sensitive to the rising edge of a clock signal. The inputs and outputs are all 4-bit signals. The module should perform the following operations:\n\n1. The first input signal should be multiplied by 2 and the result should be stored in the first output signal.\n2. The second input signal should be divided by 4 and the result should be stored in the second output signal.\n3. The third input signal should be added to the first output signal and the result should be stored in the first output signal.\n4. The third input signal should be subtracted from the second output signal and the result should be stored in the second output signal.\n\nThe module should be named \"multi_div_add_sub\" and should have the following inputs and outputs:\n\nInputs:\n- clk: a single bit clock signal\n- in0: a 4-bit input signal\n- in1: a 4-bit input signal\n- in2: a 4-bit input signal\n\nOutputs:\n- out0: a 4-bit output signal\n- out1: a 4-bit output signal\n\n", "output": "module multi_div_add_sub(\n    input clk,\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out0,\n    output [3:0] out1\n);\n\n    reg [3:0] reg_out0;\n    reg [3:0] reg_out1;\n\n    always @(posedge clk) begin\n        reg_out0 <= (in0 * 2) + in2;\n        reg_out1 <= (in1 / 4) - in2;\n    end\n\n    assign out0 = reg_out0;\n    assign out1 = reg_out1;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a digital circuit that implements a specific type of flip-flop. The circuit should be implemented using Verilog and should be contained within a single module. The input to the circuit consists of four signals: D, C, E, and R. The output of the circuit is a single signal Q.\n\nThe flip-flop to be implemented is a D-type flip-flop with asynchronous reset and enable, and with a positive-edge triggered clock. The behavior of the flip-flop is as follows:\n- When the enable signal E is low, the flip-flop should hold its current state.\n- When the enable signal E is high, the flip-flop should respond to the input signal D on the rising edge of the clock signal C.\n- When the reset signal R is high, the flip-flop should be cleared to 0 regardless of the state of the enable signal E.\n\nYour task is to implement this flip-flop using Verilog. You should use the provided code snippet as a starting point, but you may need to modify it to achieve the desired behavior.\n\n", "output": "module d_ff_ar_en_posedge (input D, C, E, R, output reg Q);\n    always @(posedge C) begin\n        if (R) begin\n            Q <= 1'b0;\n        end else if (E) begin\n            Q <= D;\n        end\n    end\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit adder with carry in and carry out. The module should have four inputs, A, B, Cin (carry in), and a clock signal, and two outputs, S (sum) and Cout (carry out). The module should be able to add two 4-bit numbers A and B along with the carry in Cin, and output the 4-bit sum S along with the carry out Cout. The module should be designed using only combinational logic and should not use any sequential logic elements such as flip-flops.\n\nThe module should be named \"four_bit_adder\" and should be written in only one module within 200 lines of Verilog code. The module should use the following interface:\n```\nmodule four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input clk,\n  output [3:0] S,\n  output Cout\n);\n```\nThe module should follow the following truth table:\n```\nCin | A | B | S | Cout\n---------------------\n 0  | 0 | 0 | 0 | 0\n 0  | 0 | 1 | 1 | 0\n 0  | 1 | 0 | 1 | 0\n 0  | 1 | 1 | 0 | 1\n 1  | 0 | 0 | 1 | 0\n 1  | 0 | 1 | 0 | 1\n 1  | 1 | 0 | 0 | 1\n 1  | 1 | 1 | 1 | 1\n```\nIn other words, the module should add the two 4-bit numbers A and B along with the carry in Cin, and output the 4-bit sum S along with the carry out Cout.\n\n", "output": "module four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input clk,\n  output [3:0] S,\n  output Cout\n);\n\n  assign S = A + B + Cin;\n  assign Cout = (A[3] & B[3]) | (A[3] & Cin) | (B[3] & Cin);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 8 input signals and produces 1 output signal based on the following logic:\n- The output signal is high (1) if both input signals A1 and A2 are high (1) AND either input signal B1 is low (0) OR the output of the AND gate is low (0).\n- The output signal is low (0) otherwise.\n\nThe module should be named `custom_module` and should have the following input and output ports:\n- `input A1, A2, B1, VPWR, VGND, VPB, VNB`\n- `output Y`\n\nYou should assume that all input signals are 1-bit wide and that VPWR, VGND, VPB, and VNB are power and ground signals that are not used in the module.\n\nDesign the `custom_module` using Verilog. Your solution should be contained within 200 lines of code.\n\n", "output": "module custom_module(\n    input A1,\n    input A2,\n    input B1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output Y\n);\n\n    wire and_out;\n    wire nor_out;\n\n    and and_gate(\n        .a(A1),\n        .b(A2),\n        .y(and_out)\n    );\n\n    nor nor_gate(\n        .a(B1),\n        .b(and_out),\n        .y(nor_out)\n    );\n\n    assign Y = ~nor_out;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock divider. A clock divider is a type of digital circuit that takes in an input clock signal and outputs a slower clock signal. The output clock signal is a fraction of the input clock signal, and the fraction is determined by a programmable value.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- clk_in: the input clock signal\n- rst_n: an active-low reset signal\n- divider: a programmable value that determines the output clock frequency\n\nOutputs: \n- clk_out: the output clock signal\n\nYour module should also have the following parameters:\n\n- WIDTH: the width of the counter used to divide the clock signal\n- DIV_MAX: the maximum value of the divider parameter\n\nYour module should implement the following functionality:\n\n- The circuit should have a counter that counts up on each input clock cycle.\n- The counter should have a width of WIDTH, which determines the maximum value of the counter.\n- The counter should be reset to 0 when the rst_n signal is low.\n- The counter output should be compared to the divider parameter.\n- When the counter output is equal to the divider parameter, the output clock signal should toggle and the counter should be reset to 0.\n\nTo implement the clock divider, you should use Verilog code to define the counter and the comparator. You should then use these to generate the output clock signal.", "output": "module clock_divider (\n  input clk_in,\n  input rst_n,\n  input [7:0] divider,\n  output reg clk_out\n);\n\nparameter WIDTH = 8; // width of the counter\nparameter DIV_MAX = 255; // maximum value of divider\n\nreg [WIDTH-1:0] counter;\n\nalways @(posedge clk_in or negedge rst_n) begin\n  if (~rst_n) begin\n    counter <= 0;\n    clk_out <= 0;\n  end\n  else begin\n    counter <= counter + 1;\n    if (counter == divider) begin\n      clk_out <= ~clk_out;\n      counter <= 0;\n    end\n  end\nend\n\nendmodule"}
{"instruction": "Implement a NOR gate using a combination of NAND gates. The NOR gate should have two inputs and one output. The output should be the logical negation of the OR function of the two inputs.", "output": "module nor_gate (\n    input a,\n    input b,\n    output out\n);\n\nwire nand1_out, nand2_out;\n\nnand nand1 (nand1_out, a, a);\nnand nand2 (nand2_out, b, b);\nnand nand3 (out, nand1_out, nand2_out);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 4 inputs and produces 1 output. The module should be named `four_to_one` and should be written in Verilog.\n\nThe inputs to the module are:\n- `in1` (1-bit)\n- `in2` (1-bit)\n- `in3` (1-bit)\n- `in4` (1-bit)\n\nThe output from the module is:\n- `out` (1-bit)\n\nThe output should be the result of the following logic:\n- If `in1` is 1, `out` should be 1\n- If `in1` is 0 and `in2` is 1, `out` should be 1\n- If `in1` and `in2` are 0 and `in3` is 1, `out` should be 1\n- If all inputs are 0, `out` should be 0\n\nYou may use any Verilog operators and constructs to implement this module.\n\n", "output": "module four_to_one(\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    output out\n);\n\n    assign out = (in1 || in2 || in3) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-to-1 multiplexer (mux). The module should have four input signals, one output signal, and two select signals. The output signal should be equal to one of the four input signals, depending on the values of the select signals. \n\nYour module should be named `mux4to1` and should have the following interface:\n\n```\nmodule mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n```\n\nThe `in` input is a 4-bit vector containing the four input signals. The `sel` input is a 2-bit vector containing the two select signals. The `out` output is a single bit that should be equal to one of the four input signals, depending on the values of the select signals.\n\nYou can assume that the select signals will always be valid, i.e., they will always be either `00`, `01`, `10`, or `11`.\n\nYour module should be designed using only combinational logic. You can use any gates or primitives from the `sky130_fd_sc_hd` library.\n\nWrite a Verilog module for the `mux4to1` module that meets the above requirements. Your solution should be contained within one module and should not exceed 200 lines of code.\n\n", "output": "module mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n\n    wire sel0_inv, sel1_inv;\n\n    assign sel0_inv = ~sel[0];\n    assign sel1_inv = ~sel[1];\n\n    always @(*) begin\n        if (sel == 2'b00) begin\n            out = in[0];\n        end else if (sel == 2'b01) begin\n            out = in[1];\n        end else if (sel == 2'b10) begin\n            out = in[2];\n        end else begin\n            out = in[3];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital circuit that counts the number of rising edges on a clock signal. The circuit should have a single input port for the clock signal and a single output port for the count value. The count value should be reset to zero whenever a reset signal is received.\n\nDesign a module in Verilog that implements this circuit. The module should have the following specifications:\n\n1. The module should be named \"rising_edge_counter\".\n2. The module should have two input ports: \"clk\" and \"reset\".\n3. The module should have one output port: \"count\".\n4. The \"clk\" input port should be a 1-bit wire.\n5. The \"reset\" input port should be a 1-bit wire.\n6. The \"count\" output port should be a 32-bit wire.\n7. The count value should be incremented by 1 on every rising edge of the \"clk\" signal.\n8. The count value should be reset to zero whenever the \"reset\" signal is high.\n\nYour solution should be contained within a single Verilog module with no more than 200 lines of code.\n\n", "output": "module rising_edge_counter(\n  input wire clk,\n  input wire reset,\n  output wire [31:0] count\n);\n\n  reg [31:0] count_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_reg <= 0;\n    end else begin\n      count_reg <= count_reg + 1;\n    end\n  end\n\n  assign count = count_reg;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a simple multiplier. The module should have the following inputs and outputs:\n\nInputs:\n- `clk` : a clock signal\n- `rst` : a synchronous reset signal\n- `A` : an 8-bit unsigned integer\n- `B` : an 8-bit unsigned integer\n\nOutputs:\n- `Z` : a 16-bit unsigned integer representing the product of `A` and `B`\n\nThe module should have the following behavior:\n- On reset (`rst` asserted), `Z` should be set to 0.\n- On each rising edge of the clock (`clk`), the module should multiply `A` and `B` and store the result in `Z`.\n\nYou are free to use any verilog constructs to implement the module.\n\n", "output": "module multiplier (\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output reg  [15:0] Z\n);\n\n    always @(posedge clk or posedge rst)\n        if (rst) Z <= 0;\n        else     Z <= A * B;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 3-bit up-counter with asynchronous reset. The circuit should have a clock input, a reset input, and a 3-bit output. When the reset input is high, the output should be reset to 000. When the clock input goes from low to high, the output should increment by one. The circuit should wrap around to 000 when it reaches 111.", "output": "module up_counter_3bit (\n    input clk,\n    input rst,\n    output reg [2:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (rst == 0) begin\n            count <= 3'b000;\n        end else if (count == 3'b111) begin\n            count <= 3'b000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit comparator. The module should have two inputs (in_a and in_b) and three outputs (eq, gt, and lt). The output eq should be asserted when in_a is equal to in_b. The output gt should be asserted when in_a is greater than in_b. The output lt should be asserted when in_a is less than in_b.", "output": "module comparator_4bit (\n    input [3:0] in_a,\n    input [3:0] in_b,\n    output eq,\n    output gt,\n    output lt\n);\n\n    assign eq = (in_a == in_b);\n    assign gt = (in_a > in_b);\n    assign lt = (in_a < in_b);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in a 4-bit input and outputs a 2-bit output. The output should be the highest two bits of the input. If the input is less than 2 bits, the output should be 0. If the input is greater than or equal to 2 bits, the output should be the highest two bits of the input. Write a verilog module that implements this behavior.\n\n", "output": "module highest_two_bits(input [3:0] in, output [1:0] out);\n\n    always @(*) begin\n        if(in < 4'b100) begin\n            out = 2'b00;\n        end else begin\n            out = in[3:2];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nIn this problem, you are tasked with designing a module that implements a half adder circuit using Verilog. The half adder circuit takes two inputs, A and B, and produces two outputs, SUM and CARRY. The SUM output is the result of adding A and B, while the CARRY output is the carry bit that is generated when adding A and B. \n\nYour module should have the following inputs and outputs:\n- input A: a single bit input representing the first input to the half adder circuit\n- input B: a single bit input representing the second input to the half adder circuit\n- output SUM: a single bit output representing the sum of A and B\n- output CARRY: a single bit output representing the carry generated when adding A and B\n\nYour module should be named `half_adder` and should be contained within 200 lines of Verilog code.\n\n", "output": "module half_adder (\n    input A,\n    input B,\n    output SUM,\n    output CARRY\n);\n\n    assign SUM = A ^ B;\n    assign CARRY = A & B;\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module `probe_async` that implements a multiplexer with 8 inputs and 1 output. The module has an Avalon memory-mapped slave interface for control signals and an Avalon clock interface. The multiplexer selects one of the eight inputs based on the value of a control signal, and outputs the selected input. The inputs are 31-bit wide, and the output is a single bit.\n\nThe module contains an asynchronous probe multiplexer with 8 probes, each of which is an instance of the `probe_mux4_async` module. Each probe mux selects one of four input bits and outputs the selected bit. The control signal is used to select the probe mux to be used for selecting the output.\n\nYour task is to implement the `probe_mux4_async` module that implements a multiplexer with 4 inputs and 1 output. The module should have the following interface:\n\n```\nmodule probe_mux4_async\n(\n\tinput clk,\n\tinput reset,\n\tinput [1:0]sel,\n\tinput [3:0]in,\n\toutput reg out\n);\n```\n\nwhere `clk` is the clock input, `reset` is the asynchronous reset input, `sel` is the 2-bit selection input, `in` is the 4-bit input vector, and `out` is the 1-bit output.\n\nYou need to implement the module within 200 lines of Verilog code.\n\n", "output": "module probe_mux4_async\n(\n\tinput clk,\n\tinput reset,\n\tinput [1:0]sel,\n\tinput [3:0]in,\n\toutput reg out\n);\n\n\treg [3:0]d;\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset) d <= 0;\n\t\telse\n\t\t\tcase (sel)\n\t\t\t\t2'b00: d <= {in[0], 3'b0};\n\t\t\t\t2'b01: d <= {in[1], 3'b0};\n\t\t\t\t2'b10: d <= {in[2], 3'b0};\n\t\t\t\t2'b11: d <= {in[3], 3'b0};\n\t\t\tendcase\n\tend\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset) out <= 0;\n\t\telse out <= d[0];\n\tend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder-subtractor. The module should have two input ports, one for the two 4-bit numbers to be added or subtracted, and another input port to select whether the numbers should be added or subtracted. The output port should be the result of the operation. You should use Verilog operators to implement the adder-subtractor.", "output": "module add_sub_4bit (\n  input [3:0] num1,\n  input [3:0] num2,\n  input sub,\n  output reg [3:0] result\n);\n\n  always @(*) begin\n    if (sub) begin\n      result <= num1 - num2;\n    end else begin\n      result <= num1 + num2;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 5 input signals and outputs a single signal. The module is required to have the following functionality:\n\n- The module should be named `my_module`.\n- The output signal should be named `out_signal`.\n- The input signals should be named `in_signal_1`, `in_signal_2`, `in_signal_3`, `in_signal_4`, and `in_signal_5`.\n- The module should have two internal signals named `sig1` and `sig2`.\n- `sig1` should be the result of an AND gate between `in_signal_1` and `in_signal_2`.\n- `sig2` should be the result of a NOR gate between `in_signal_3`, `in_signal_4`, `in_signal_5`, and `sig1`.\n- `out_signal` should be the result of a buffer with input `sig2`.\n\nDesign the `my_module` module with the above functionality.\n\n", "output": "module my_module (\n    out_signal,\n    in_signal_1,\n    in_signal_2,\n    in_signal_3,\n    in_signal_4,\n    in_signal_5\n);\n\n    // Module ports\n    output out_signal;\n    input  in_signal_1;\n    input  in_signal_2;\n    input  in_signal_3;\n    input  in_signal_4;\n    input  in_signal_5;\n\n    // Local signals\n    wire sig1;\n    wire sig2;\n\n    //  Name  Output      Other arguments\n    and and0 (sig1, in_signal_1, in_signal_2);\n    nor nor0 (sig2, in_signal_3, in_signal_4, in_signal_5, sig1);\n    buf buf0 (out_signal, sig2);\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that takes in three inputs: `in1`, `in2`, and `in3`. The output of the module should be the result of the following operation: `in1 & in2 | ~in3`. \n\nDesign a verilog module to implement this function. \n\nYour module should be named `bitwise_logic` and should have the following inputs and outputs:\n\nInputs:\n- `in1`: a 1-bit input\n- `in2`: a 1-bit input\n- `in3`: a 1-bit input\n\nOutputs:\n- `out1`: a 1-bit output that represents the result of the operation `in1 & in2 | ~in3`\n\nYou may not use any built-in verilog operators or functions to perform the bitwise logic operation. \n\n", "output": "module bitwise_logic(\n  input in1,\n  input in2,\n  input in3,\n  output out1\n);\n\n  wire not_in3;\n  wire and_in1_in2;\n  wire or_and_not;\n\n  assign not_in3 = ~in3;\n  assign and_in1_in2 = in1 & in2;\n  assign or_and_not = and_in1_in2 | not_in3;\n\n  assign out1 = or_and_not;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module for a flip-flop circuit. The module should have a single data input (D), a single output (Q), and a clock input (CLK) that triggers the flip-flop. Additionally, the module should have two power inputs (VPWR and VGND) for power supply.\n\nYour task is to write a Verilog module that implements this flip-flop circuit, following these specifications:\n\n1. When the clock input (CLK) transitions from low to high, the output (Q) should take on the value of the data input (D).\n2. When the clock input (CLK) transitions from high to low, the output (Q) should maintain its value until the next rising clock edge.\n3. The module should be designed to operate with a supply voltage of VPWR and a ground voltage of VGND.\n\nWrite a Verilog module that meets these specifications. Your module should be self-contained and not rely on any external modules. Your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module flip_flop (\n    input D,\n    output Q,\n    input CLK,\n    input VPWR,\n    input VGND\n);\n\nwire Q_bar;\nassign Q_bar = ~Q;\n\n// D flip-flop implementation\nalways @(posedge CLK) begin\n    Q <= D;\nend\n\n// Reset implementation\nalways @(posedge VPWR) begin\n    Q <= 1'b0;\nend\n\n// Power-on reset implementation\nalways @(negedge VGND) begin\n    Q <= 1'b0;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a control register block. \nA control register block is a type of digital circuit that is used to control the behavior of other circuits in a system. \nThe inputs to the circuit are connected to a set of control bits, and the outputs are connected to the circuits that need to be controlled. \nThe control register block contains a set of registers that can be loaded with control values, which are then used to control the behavior of the circuits.\n\nYour module should have the following inputs and outputs:\n\nInputs: a set of n control signals (ctrl1, ctrl2, ..., ctrln)\nOutputs: a set of m output signals (out1, out2, ..., outm)\n\nThe module should also have the following parameters:\n\nn: the number of control signals\nm: the number of output signals\nr: the number of registers in the control register block\n\nYour module should implement the following functionality:\n\nThe circuit should have r registers, each of which can be loaded with a value to control the behavior of the circuits.\nThe inputs to the circuit should be connected to the control bits of the registers.\nThe outputs of the circuit should be connected to the circuits that need to be controlled.\nThe control register block should be able to load the values of the registers with new control values.\nThe control register block should be able to output the current values of the registers to the circuits that need to be controlled.\n\nTo implement the control register block, you should use Verilog code to define the registers and the control logic that connects the inputs to the registers and the registers to the outputs. \nYou should also define the control logic that allows the registers to be loaded with new values.", "output": "module control_register_block (\n  input [n-1:0] ctrl,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of control signals\nparameter m = 2; // number of output signals\nparameter r = 4; // number of registers\n\nreg [r-1:0] reg_values; // register values\n\n// Control logic to load new values into the registers\nalways @ (posedge clk) begin\n  if (load) begin\n    reg_values <= new_values;\n  end\nend\n\n// Control logic to output the current register values to the output signals\nassign out = reg_values;\n\nendmodule"}
{"instruction": "Create an XOR gate using a non-clocked always block and a single always block. The output of the module should be a single bit that is the result of XORing two input bits.", "output": "module xor_gate(\n    input a,\n    input b,\n    output reg out\n);\n\nalways @(*)\nbegin\n    out = a ^ b;\nend\n\nendmodule\nmodule top_module(\n    input a,\n    input b,\n    output reg out_always_comb\n);\n\nxor_gate xor_gate_inst(\n    .a(a),\n    .b(b),\n    .out(out_always_comb)\n);\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit binary to gray code converter. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `rst`: a synchronous reset signal\n- `bin`: a 4-bit binary input\n\nOutputs:\n- `gray`: a 4-bit gray code output\n\nThe module should convert the 4-bit binary input to its corresponding 4-bit gray code output. The module should operate on the rising edge of the clock signal and should be reset to 0 on the rising edge of the reset signal.\n\n", "output": "module bin2gray (\n    input clk,\n    input rst,\n    input [3:0] bin,\n    output [3:0] gray\n);\n\nreg [3:0] gray_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        gray_reg <= 4'b0;\n    end else begin\n        gray_reg <= bin ^ (bin >> 1);\n    end\nend\n\nassign gray = gray_reg;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that performs a 4-bit barrel shift to the left or right. The module should take in a 4-bit input (DATA), a 2-bit input (SHIFT), and output a 4-bit value (RESULT) that is shifted left or right by the specified amount. If SHIFT is 00, no shift should be performed. If SHIFT is 01, the data should be shifted one bit to the right. If SHIFT is 10, the data should be shifted two bits to the right. If SHIFT is 11, the data should be shifted three bits to the right.", "output": "module barrel_shift (\n    input [3:0] DATA,\n    input [1:0] SHIFT,\n    output [3:0] RESULT\n);\n\n    assign RESULT = (SHIFT == 2'b00) ? DATA :\n                    (SHIFT == 2'b01) ? {DATA[0], DATA[3:1]} :\n                    (SHIFT == 2'b10) ? {DATA[1:0], DATA[3:2]} :\n                    {DATA[2:0], DATA[3]};\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a one-shot pulse generator, also known as a monostable multivibrator. \nA one-shot pulse generator produces a single output pulse of a specified width in response to a trigger signal. \nYour module should have the following inputs and outputs:\n\nInputs: \n1. trigger: a single-bit signal that triggers the one-shot pulse generator\n2. width: an integer that specifies the width of the output pulse in clock cycles\n\nOutputs: \n1. pulse_out: a single-bit signal that is high for the duration of the output pulse\n\nYour module should implement the following functionality:\n\n1. When the trigger input is high, the output pulse should be generated.\n2. The width of the output pulse should be specified by the width input.\n3. The width of the output pulse should be measured in clock cycles.\n4. The output pulse should be synchronized to the input clock signal.\n\nTo implement the one-shot pulse generator, you should use a Verilog code to define the output pulse as a function of the trigger signal and the width input. \nYou should then use this function to generate the output pulse, ensuring that it is synchronized with the input clock signal.", "output": "module one_shot_pulse_gen (\n  input clk, // clock signal\n  input trigger, // trigger signal\n  input [7:0] width, // width of the output pulse\n  output reg pulse_out // output pulse\n);\n\n  reg [7:0] count; // counter for pulse width\n\n  always @(posedge clk) begin\n    if (trigger) begin\n      pulse_out <= 1'b1;\n      count <= width;\n    end else if (count > 0) begin\n      pulse_out <= 1'b1;\n      count <= count - 1;\n    end else begin\n      pulse_out <= 1'b0;\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a simple 4-bit adder/subtractor circuit in Verilog. The circuit should have two 4-bit inputs, A and B, and a control input, C. If C is 0, the circuit should perform addition and output the result as a 4-bit sum, S. If C is 1, the circuit should perform subtraction and output the result as a 4-bit difference, D. You may use any Verilog syntax you find appropriate, but the circuit must be synthesizable.\n\n", "output": "module add_sub (\n  input [3:0] A,\n  input [3:0] B,\n  input C,\n  output [3:0] S,\n  output [3:0] D\n);\n\n  wire [4:0] temp;\n\n  assign temp = C ? (A - B) : (A + B);\n\n  assign S = temp[3:0];\n  assign D = temp[4] ? (temp[3:0] - 16) : temp[3:0];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4:1 multiplexer with an additional input that serves as a control signal. The module should have the following inputs and outputs:\n\n- Inputs: A, B, C, D, and S\n- Outputs: Y\n\nThe inputs A, B, C, and D are 1-bit signals, and S is a 2-bit signal that serves as the control input. The value of S determines which input is selected and passed through to the output Y. The truth table for the 4:1 multiplexer is as follows:\n\n| S | Y |\n|---|---|\n| 00| A |\n| 01| B |\n| 10| C |\n| 11| D |\n\nYou should implement the module using only one module within 200 lines of Verilog code.\n\n", "output": "module mux4to1 (\n    input  wire a,\n    input  wire b,\n    input  wire c,\n    input  wire d,\n    input  wire [1:0] s,\n    output reg y\n);\n\nalways @(*) begin\n    case (s)\n        2'b00: y = a;\n        2'b01: y = b;\n        2'b10: y = c;\n        2'b11: y = d;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit adder with carry-in and carry-out ports. The module should be named `ADD4` and should have the following ports:\n\n- `A`: a 4-bit input representing the first operand\n- `B`: a 4-bit input representing the second operand\n- `Cin`: a single-bit input representing the carry-in bit\n- `Sum`: a 4-bit output representing the sum of the two operands\n- `Cout`: a single-bit output representing the carry-out bit\n\nThe addition should be performed using full-adders. You may use the `FULL_ADDER` module, which has the following ports:\n\n- `A`: a single-bit input representing the first operand\n- `B`: a single-bit input representing the second operand\n- `Cin`: a single-bit input representing the carry-in bit\n- `Sum`: a single-bit output representing the sum of the two operands\n- `Cout`: a single-bit output representing the carry-out bit\n\nYou may also use any other verilog primitives or modules as necessary.\n\n", "output": "module FULL_ADDER(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nwire w1, w2, w3;\n\nxor(w1, A, B);\nxor(Sum, Cin, w1);\nand(w2, A, B);\nand(w3, w1, Cin);\nor(Cout, w2, w3);\n\nendmodule\n\nmodule ADD4(A, B, Cin, Sum, Cout);\ninput [3:0] A, B;\ninput Cin;\noutput [3:0] Sum;\noutput Cout;\n\nwire c1, c2, c3;\nFULL_ADDER fa1(A[0], B[0], Cin, Sum[0], c1);\nFULL_ADDER fa2(A[1], B[1], c1, Sum[1], c2);\nFULL_ADDER fa3(A[2], B[2], c2, Sum[2], c3);\nFULL_ADDER fa4(A[3], B[3], c3, Sum[3], Cout);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a clock gating circuit using a D flip-flop with enable. The circuit should take in a clock signal (CLK), an enable signal (EN), and a test enable signal (TE). The output of the circuit should be an enable clock signal (ENCLK).\n\nYour task is to complete the module `clock_gate` that takes in these three signals and outputs the enable clock signal. The circuit should follow the following specifications:\n\n1. When TE is high, the circuit should not gate the clock signal and ENCLK should be equal to the CLK signal.\n2. When TE is low, the circuit should gate the clock signal based on the EN signal. If EN is low, ENCLK should be low. If EN is high, ENCLK should be equal to CLK.\n\nYou can assume that all input signals are synchronous to the same clock domain.\n\n", "output": "module clock_gate (\n  input CLK, EN, TE,\n  output ENCLK\n);\n\n  wire gated_clk;\n\n  // Gating logic\n  assign gated_clk = (TE) ? CLK : (EN) ? CLK : 1'b0;\n\n  // D flip-flop with enable\n  always @(posedge CLK) begin\n    if (EN) begin\n      ENCLK <= gated_clk;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a 4-bit comparator module that takes two 4-bit inputs A and B and outputs a 2-bit signal indicating the relationship between A and B. The output should be 00 if A = B, 01 if A > B, and 10 if A < B. You can use any logic gates, but you are not allowed to use any behavioral Verilog constructs like if-else statements or loops.", "output": "module comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  output reg [1:0] result\n);\n\n  always @* begin\n    result = 2'b00; // Default output is 00\n    if (A > B) begin\n      result = 2'b01; // A is greater than B\n    end else if (A < B) begin\n      result = 2'b10; // A is less than B\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple encryption algorithm. The module should take in a 16-bit data input and output a 16-bit encrypted data. The encryption algorithm is as follows:\n- Split the 16-bit input into two 8-bit parts, A and B.\n- Rotate A to the left by 2 bits.\n- Add B to the rotated A.\n- Take the 8 least significant bits of the result and append them to the 8 most significant bits of B to form the encrypted data output.\n\nThe verilog module should have the following inputs and outputs:\n- `input aclk`: the clock signal\n- `input reset`: active high reset signal\n- `input [15:0] data_in`: the 16-bit data input\n- `output reg [15:0] data_out`: the 16-bit encrypted data output\n\nThe module should operate on the rising edge of the clock signal and should only output valid data when `reset` is low. The `data_out` output should be updated on the same clock cycle that `data_in` is valid.\n\n", "output": "module encryption_module(\n  input aclk,\n  input reset,\n  input [15:0] data_in,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] A;\n  reg [7:0] B;\n  reg [7:0] rotated_A;\n  reg [15:0] result;\n\n  always @(posedge aclk) begin\n    if (reset) begin\n      A <= 8'd0;\n      B <= 8'd0;\n      rotated_A <= 8'd0;\n      result <= 16'd0;\n      data_out <= 16'd0;\n    end else begin\n      A <= data_in[15:8];\n      B <= data_in[7:0];\n\n      rotated_A <= {A[5:0], A[7:6]};\n      result <= rotated_A + B;\n      data_out <= {result[15:8], result[7:0]};\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-input AND gate. The module should be named \"and4\" and should have four input ports named \"A\", \"B\", \"C\", and \"D\". The output port should be named \"Y\". The module should be implemented using only 2-input AND gates. \n\nDeclare the voltage supply signals as shown in the code snippet below. \n\n```\n// Voltage supply signals\nsupply1 VPWR;\nsupply0 VGND;\nsupply1 VPB ;\nsupply0 VNB ;\n```\n\nWrite the verilog code for the \"and4\" module and ensure that it compiles successfully. \n\n", "output": "module and4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A, B, C, D;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire w1, w2, w3;\n    \n    and2 u1 (.Y(w1), .A(A), .B(B));\n    and2 u2 (.Y(w2), .A(C), .B(D));\n    and2 u3 (.Y(w3), .A(w1), .B(w2));\n    \n    assign Y = w3;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 4-bit ripple carry adder using Verilog. The adder should have the following inputs and outputs:\n\nInputs:\n- A (4-bit input)\n- B (4-bit input)\n- CI (carry-in input)\n\nOutputs:\n- S (4-bit sum output)\n- CO (carry-out output)\n\nYou should use the following module as a building block for your design:\n\n```\nmodule sky130_fd_sc_ls__fah_2 (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CI\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CI  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ls__fah base (\n        .COUT(COUT),\n        .SUM(SUM),\n        .A(A),\n        .B(B),\n        .CI(CI)\n    );\n\nendmodule\n```\n\nWrite the Verilog code for the 4-bit ripple carry adder.\n\n", "output": "module ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input CI,\n    output [3:0] S,\n    output CO\n);\n\n    wire [3:0] C;\n    sky130_fd_sc_ls__fah_2 fa0(.COUT(C[0]), .SUM(S[0]), .A(A[0]), .B(B[0]), .CI(CI));\n    sky130_fd_sc_ls__fah_2 fa1(.COUT(C[1]), .SUM(S[1]), .A(A[1]), .B(B[1]), .CI(C[0]));\n    sky130_fd_sc_ls__fah_2 fa2(.COUT(C[2]), .SUM(S[2]), .A(A[2]), .B(B[2]), .CI(C[1]));\n    sky130_fd_sc_ls__fah_2 fa3(.COUT(CO), .SUM(S[3]), .A(A[3]), .B(B[3]), .CI(C[2]));\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a digital circuit that will output a signal based on the values of several input signals. The module should take in the following inputs:\n\n- A1: a single bit input signal\n- A2: a single bit input signal\n- B1_N: a single bit input signal\n- VPWR: a power supply voltage input signal\n- VGND: a ground voltage input signal\n- VPB: a voltage input signal\n- VNB: a voltage input signal\n\nThe module should output a single bit signal, Y.\n\nYour task is to write a Verilog module that implements this circuit. The module should be named \"my_module\" and should take the inputs and outputs described above.\n\nThe module should implement the following logic:\n\n- If A1 is 1, Y should be 1.\n- If A1 is 0 and A2 is 1, Y should be 1.\n- If A1 is 0, A2 is 0, and B1_N is 1, Y should be 1.\n- If none of the above conditions are met, Y should be 0.\n\nYou can assume that all input signals will be valid and stable.\n\n", "output": "module my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign Y = (A1 | (A2 & ~A1) | (B1_N & ~A1 & ~A2)) ? 1'b1 : 1'b0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that performs a bitwise XOR operation on three input bits and outputs the result. The module should be named `xor3` and have the following interface:\n\n```\nmodule xor3 (\n    input a,\n    input b,\n    input c,\n    output x\n);\n```\n\nThe module should use only 1-bit wide wires and logic gates (AND, OR, NOT, XOR, etc.). The module should not use any built-in Verilog operators or functions (e.g. `^`, `~`, `&`, etc.). The module should only be 200 lines or less.\n\nDesign the `xor3` module to be synthesizable and meet the following requirements:\n\n- The output `x` should be the result of a bitwise XOR operation on the input bits `a`, `b`, and `c`.\n- The module should have no latches or combinational loops.\n- The module should have no warnings or errors when synthesized using the `sky130_fd_sc_hdll__tt_025C_1v80` library.\n\n", "output": "module xor3 (\n    input a,\n    input b,\n    input c,\n    output x\n);\n\n    wire not_a;\n    wire not_b;\n    wire not_c;\n    wire a_and_b;\n    wire b_and_c;\n    wire c_and_a;\n    wire xor1;\n    wire xor2;\n\n    // Invert input bits\n    not not_a (not_a, a);\n    not not_b (not_b, b);\n    not not_c (not_c, c);\n\n    // Compute ANDs\n    and a_and_b (a_and_b, a, b);\n    and b_and_c (b_and_c, b, c);\n    and c_and_a (c_and_a, c, a);\n\n    // Compute XORs\n    xor xor1 (xor1, not_a, b_and_c);\n    xor xor2 (xor2, a_and_b, not_c);\n\n    // Compute final XOR\n    xor x (x, xor1, xor2);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that takes in two 8-bit binary numbers and outputs the sum of the two numbers. The output should be a 9-bit binary number to accommodate for any possible overflow.", "output": "module adder(\n    input [7:0] num1,\n    input [7:0] num2,\n    output reg [8:0] sum\n);\n\nalways @(*) begin\n    sum = num1 + num2;\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit binary counter with a synchronous reset and an enable input. The counter should increment on the positive edge of the clock only when the enable input is high. When the reset input is high, the counter should be cleared to 0000.", "output": "module binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module to implement a clock gating circuit for a data flip-flop. The circuit should have three inputs: CLK, EN, and TE, and one output: ENCLK. CLK is the clock signal, EN is the enable signal, and TE is the transparent enable signal. ENCLK is the gated clock signal that is fed to the data flip-flop.\n\nYour task is to design a verilog module named \"clock_gate\" that takes these inputs and generates the output ENCLK. The circuit should be implemented using only one module within 200 lines of verilog code.\n\nThe module should implement the following behavior:\n- When EN is high, the output ENCLK should be identical to CLK.\n- When EN is low and TE is high, the output ENCLK should be low.\n- When EN is low and TE is low, the output ENCLK should be high impedance.\n\nYou should assume that the data flip-flop is sensitive to both the rising and falling edges of the clock signal.\n\n", "output": "module clock_gate(\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\nalways @(*) begin\n  if (EN) begin\n    ENCLK <= CLK;\n  end else begin\n    if (TE) begin\n      ENCLK <= 1'b0;\n    end else begin\n      ENCLK <= 1'bz;\n    end\n  end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 4-bit input and outputs a 6-bit Gray code. The Gray code should be generated using an XOR gate. You can assume that the input is not a Gray code.", "output": "module gray_code (\n    input [3:0] in,\n    output reg [5:0] out\n);\n\nalways @ (in) begin\n    out[0] = in[0];\n    out[1] = in[0] ^ in[1];\n    out[2] = in[1] ^ in[2];\n    out[3] = in[2] ^ in[3];\n    out[4] = in[3] ^ out[3];\n    out[5] = in[3] ^ out[2];\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 8-bit input and outputs the parity bit. The parity bit should be 1 if there are an odd number of 1's in the input, and 0 if there are an even number of 1's in the input. Use a combinational always block to implement the module.", "output": "module parity_bit (\n    input [7:0] in,\n    output reg out\n);\n    \n    integer i;\n    reg [7:0] temp_in;\n    reg [3:0] temp_out;\n    \n    always @(*) begin\n        temp_in = in;\n        temp_out = {temp_in[0],temp_in[1],temp_in[2],temp_in[3]} ^ {temp_in[4],temp_in[5],temp_in[6],temp_in[7]};\n        temp_out = temp_out ^ {temp_out[0],temp_out[1],temp_out[2],temp_out[3]};\n        out = ~temp_out[0];\n    end\nendmodule\n"}
{"instruction": "\n\nYou are given a Verilog module `mux_16to1` that implements a 16-to-1 multiplexer. The module has the following inputs and outputs:\n- `s`: a 4-bit select signal that determines which input to output.\n- `i15`, `i14`, ..., `i0`: 16 inputs to the multiplexer.\n- `z`: the output of the multiplexer.\n\nThe `s` input selects one of the 16 inputs to output on `z`. The mapping between `s` and the corresponding input is as follows:\n```\ns | input\n--+------\n0 | i0\n1 | i1\n2 | i2\n3 | i3\n4 | i4\n5 | i5\n6 | i6\n7 | i7\n8 | i8\n9 | i9\n10| i10\n11| i11\n12| i12\n13| i13\n14| i14\n15| i15\n```\n\nYou are provided with a testbench that applies various inputs to the module and prints the values of the inputs and outputs at each time step. Your task is to write the Verilog code for the `mux_16to1` module.\n\n", "output": "module mux_16to1(\n  input [3:0] s,\n  input i15, i14, i13, i12, i11, i10, i9, i8, i7, i6, i5, i4, i3, i2, i1, i0,\n  output reg z\n);\n\nalways @(*) begin\n  case (s)\n    4'b0000: z = i0;\n    4'b0001: z = i1;\n    4'b0010: z = i2;\n    4'b0011: z = i3;\n    4'b0100: z = i4;\n    4'b0101: z = i5;\n    4'b0110: z = i6;\n    4'b0111: z = i7;\n    4'b1000: z = i8;\n    4'b1001: z = i9;\n    4'b1010: z = i10;\n    4'b1011: z = i11;\n    4'b1100: z = i12;\n    4'b1101: z = i13;\n    4'b1110: z = i14;\n    4'b1111: z = i15;\n  endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a digital-to-analog converter (DAC) module in Verilog. The module should have an 8-bit input `dac_in`, a clock input `clk`, a reset input `rst`, a conversion signal `conv`, and an 8-bit output `dac_out`. The DAC should have a resolution of 7 bits, meaning that the output voltage can take on 128 different levels. \n\nThe DAC should operate as follows: when `conv` is high, the input value `dac_in` should be converted to an analog voltage and output on `dac_out`. When `conv` is low, the DAC should hold its previous output voltage. The DAC should be resettable using the `rst` input. When `rst` is high, the output voltage should be set to zero.\n\nYou are given a Verilog code snippet that instantiates the `dac` module and sets up some initial conditions. Your task is to complete the `dac` module and ensure that it meets the requirements described above.\n\n", "output": "module dac (\n    input [7:0] dac_in,\n    input clk,\n    input rst,\n    input conv,\n    output reg [6:0] dac_out\n);\n\n    parameter RES = 7;\n    parameter MAX_DAC_VAL = (2**RES)-1;\n    parameter V_REF = 3.3;\n    parameter V_STEP = V_REF/MAX_DAC_VAL;\n    \n    reg [7:0] dac_reg;\n    \n    always @(posedge clk, posedge rst) begin\n        if (rst) begin\n            dac_reg <= 8'b0;\n        end else if (conv) begin\n            dac_reg <= dac_in;\n        end\n    end\n    \n    always @(posedge clk) begin\n        dac_out <= dac_reg[V_REF/V_STEP:RES];\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit synchronous up-counter. The counter should be resettable with an active high asynchronous reset signal. The counter should increment on the positive edge of the clock signal. The output of the counter should be displayed on 4 output pins.", "output": "module sync_up_counter(\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end\n    else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a register file. \nA register file is a type of digital circuit that can store and retrieve data. \nThe inputs to the circuit are the write enable signal, the write data signal, the read enable signal and the read address signal. \nThe outputs are the read data signals corresponding to the read address.\nYour module should have the following inputs and outputs:\n\nInputs: \n- a write enable signal (we)\n- a write data signal (wd)\n- a read enable signal (re)\n- a read address signal (ra)\n\nOutputs: \n- a set of n read data signals (rd1, rd2, ..., rdn)\n\nThe module should also have the following parameters:\n- n: the number of registers\n\nYour module should implement the following functionality:\n- The circuit should have n registers, each of them storing a single data value.\n- When the write enable signal is high, the write data signal should be written to the register specified by the read address signal.\n- When the read enable signal is high, the data value stored in the register specified by the read address signal should be output to the corresponding read data signal.\n\nTo implement the register file, you should use Verilog code to define the n registers and connect them to the input and output signals. \nYou should also use conditional statements and logical operations in your code to implement the write and read enable signals.", "output": "module register_file (\n  input we,\n  input [n-1:0] wd,\n  input re,\n  input [n-1:0] ra,\n  output [n-1:0] rd\n);\n\nparameter n = 8; // number of registers\n\nreg [n-1:0] registers; // define n registers\n\nalways @ (posedge clk) begin\n  if (we) // write enable signal is high\n    registers[ra] <= wd; // write data to the specified register\nend\n\nassign rd = (re) ? registers[ra] : 0; // read data from the specified register\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in three inputs and outputs a NOR3 gate. The module should be named `nor3_module` and should have the following inputs and outputs:\n\n- `input a`: a single bit input\n- `input b`: a single bit input\n- `input c`: a single bit input\n- `output y`: a single bit output\n\nThe module should be implemented using only basic logic gates (AND, OR, NOT), and should not use any pre-built NOR gates.\n\nIn addition, you should ensure that the module is designed to be synthesizable, meaning that it can be converted into hardware.\n\nWrite a Verilog module that implements the `nor3_module` described above. Your solution should be contained in a single module with no more than 200 lines of Verilog code.\n\n", "output": "module nor3_module(\n    input a,\n    input b,\n    input c,\n    output y\n);\n\n    wire not_a, not_b, not_c, and1, and2, or1;\n\n    // Invert inputs\n    not(not_a, a);\n    not(not_b, b);\n    not(not_c, c);\n\n    // AND gates\n    and(and1, not_a, not_b);\n    and(and2, not_c, and1);\n\n    // OR gate\n    or(or1, and2, and2, and2);\n\n    // Invert output\n    not(y, or1);\n\nendmodule"}
{"instruction": "Create an XOR gate using a non-clocked always block and an assign statement. The module must have two inputs and one output. The output should be assigned to the result of the XOR operation between the two inputs.", "output": "module xor_gate(input a, b, output out_assign);\n    assign out_assign = a ^ b;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a 3-input logic gate. The module should have the following ports:\n- `A`, `B`, and `C`: the three input signals\n- `Y`: the output signal\n\nThe module should implement the following logic function:\n```\nY = (A AND B) OR (A AND C) OR (B AND C)\n```\nwhere `AND` is the logical AND operator and `OR` is the logical OR operator.\n\nDesign a module that implements this logic function and has the specified input and output ports. Your module should only use basic logic gates (AND, OR, NOT), and should not use any other modules or subcircuits.\n\nYour module should be named `three_input_gate` and should be written in Verilog.\n\n", "output": "module three_input_gate (\n    A,\n    B,\n    C,\n    Y\n);\n\n    input A, B, C;\n    output Y;\n\n    wire and1, and2, and3;\n    wire or1, or2;\n\n    assign and1 = A & B;\n    assign and2 = A & C;\n    assign and3 = B & C;\n    assign or1 = and1 | and2;\n    assign or2 = or1 | and3;\n    assign Y = or2;\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module that implements a 4-input XNOR gate. The module should have the following inputs:\n- A, B, C, D: 4-bit binary inputs\n- VPWR, VGND: power and ground supply voltages\n- VPB, VNB: positive and negative bias voltages\n\nThe module should have a single output, Y, which will be high (1) if all four inputs are either 0 or 1, and low (0) otherwise.\n\nDesign a verilog module that implements the 4-input XNOR gate. Your solution should be self-contained and should not rely on any external modules or libraries. Additionally, your solution should be no longer than 200 lines of verilog code.\n\n", "output": "module xnor4 (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output reg Y\n);\n\n    wire [3:0] AB, CD, ABCD;\n    assign AB = A ^ B;\n    assign CD = C ^ D;\n    assign ABCD = AB ^ CD;\n    assign Y = ~(ABCD[0] | ABCD[1] | ABCD[2] | ABCD[3]);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit counter that counts up from 0 to 15 and then resets to 0. The module should have a clock input and a reset input. When the reset input is high, the counter should reset to 0. When the clock input goes from low to high, the counter should increment by 1. The module should have a 4-bit output that represents the current count value.", "output": "module counter (\n    input clk,\n    input reset,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            if (out == 4'b1111) begin\n                out <= 4'b0000;\n            end else begin\n                out <= out + 1;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that performs a binary multiplication operation. The module should have two inputs, each 8 bits wide, and one output that is 16 bits wide. The output should be the result of multiplying the two input values together. You may assume that the input values will always be positive integers.\n\nYour module should be named `binary_multiplier` and should include the following inputs and outputs:\n- `input [7:0] a`: the first input value\n- `input [7:0] b`: the second input value\n- `output [15:0] result`: the result of multiplying `a` and `b`\n\nYour module should be designed to be synthesizable and should use only basic Verilog constructs, such as wires, registers, and basic arithmetic operations.\n\n", "output": "module binary_multiplier (\n  input [7:0] a,\n  input [7:0] b,\n  output [15:0] result\n);\n\n  reg [15:0] temp;\n\n  always @(*) begin\n    temp = a * b;\n  end\n\n  assign result = temp;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module to implement the Fibonacci sequence in Verilog. The module should have two inputs, `reset` and `clk`, and one output, `fib_num`. The `reset` input is asynchronous and active-high, and should reset the `fib_num` output to 0. The `clk` input is synchronous and should be used to generate the Fibonacci sequence. The `fib_num` output should output the current Fibonacci number in the sequence.\n\nThe Fibonacci sequence is defined as follows:\n- The first two numbers in the sequence are 0 and 1.\n- Each subsequent number is the sum of the two preceding numbers.\n\nYou should implement the module `fibonacci` with the following ports:\n- `clk`: input clock signal\n- `reset`: asynchronous input reset signal\n- `fib_num`: output Fibonacci number\n\nAssume that the clock signal has a period of 2 units and the reset signal is active-high.\n\n", "output": "module fibonacci(\n  input clk,\n  input reset,\n  output reg [31:0] fib_num\n);\n\n  always @ (posedge clk or posedge reset) begin\n    if (reset) begin\n      fib_num <= 0;\n    end else if (fib_num == 0) begin\n      fib_num <= 1;\n    end else begin\n      fib_num <= fib_num + (fib_num - 1);\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module that takes in a 4-bit input and outputs the number of 1's in the input. For example, if the input is 4'b0101, the output should be 2.\n\nYou are given the following template to start with:\n\n```\nmodule count_ones (\n    input [3:0] in,\n    output reg count\n);\n\n// your code here\n\nendmodule\n```\n\nYour task is to fill in the code to implement the desired functionality. You may use any combinational logic gates or other modules as necessary. The output `count` should be a single bit.\n\n", "output": "module count_ones (\n    input [3:0] in,\n    output reg count\n);\n\n    wire [1:0] sum;\n    assign sum[0] = in[0] ^ in[1];\n    assign sum[1] = sum[0] ^ in[2];\n    assign count = sum[1] ^ in[3];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2-to-4 decoder with active-low outputs. The module should have two 1-bit inputs (A and B) and four 1-bit outputs (Y0, Y1, Y2, Y3). When A and B are both low, Y0 should be low and the other outputs should be high. When A is low and B is high, Y1 should be low and the other outputs should be high. When A is high and B is low, Y2 should be low and the other outputs should be high. When A and B are both high, Y3 should be low and the other outputs should be high.", "output": "module decoder_2to4 (\n    input A,\n    input B,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3\n);\n\n    always @ (A, B) begin\n        Y0 = ~(A | B);\n        Y1 = ~(A & B);\n        Y2 = ~((~A) & B);\n        Y3 = ~(~A | ~B);\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module in Verilog that will implement a flip-flop with a preset and clear function. The module should have the following inputs and outputs:\n\n- Input `CLK`: the clock signal\n- Input `D`: the data input\n- Input `PRE`: the preset input\n- Input `CLR`: the clear input\n- Output `Q`: the output\n- Output `Q_bar`: the complement of the output\n\nThe flip-flop should operate as follows:\n- When `PRE` is asserted, the output `Q` should be set to 1, regardless of the values of `CLK`, `D`, and `CLR`.\n- When `CLR` is asserted, the output `Q` should be set to 0, regardless of the values of `CLK`, `D`, and `PRE`.\n- When neither `PRE` nor `CLR` is asserted, the output `Q` should follow the value of `D` on the rising edge of `CLK`.\n- The complement output `Q_bar` should be the inverse of `Q`.\n\nYou should implement the module within 200 lines of Verilog code.\n\n", "output": "module flipflop_preset_clear(\n    input CLK,\n    input D,\n    input PRE,\n    input CLR,\n    output reg Q,\n    output reg Q_bar\n);\n\nalways @ (posedge CLK) begin\n    if (PRE) begin\n        Q <= 1'b1;\n    end else if (CLR) begin\n        Q <= 1'b0;\n    end else begin\n        Q <= D;\n    end\nend\n\nassign Q_bar = ~Q;\n\nendmodule"}
{"instruction": "\n\nYou are tasked to design a verilog module for a 4-bit multiplier. The module should have two input ports, A and B, and one output port, C. The module should perform the multiplication of A and B and output the result in C. You should use structural verilog for the design.\n\nYou can assume that the inputs A and B are 4-bit unsigned integers and the output C is an 8-bit unsigned integer. You can use any verilog primitive gates and modules available.\n\nDesign the module and provide the verilog code for it.\n\n", "output": "module Multiplier(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] C\n);\n\n    wire [3:0] B0, B1, B2, B3;\n    wire [7:0] P0, P1, P2, P3;\n\n    // Splitting B into 4 bits\n    assign {B3, B2, B1, B0} = B;\n\n    // Multiplying A with each bit of B\n    assign P0 = A * B0;\n    assign P1 = A * B1;\n    assign P2 = A * B2;\n    assign P3 = A * B3;\n\n    // Combining the results to get the final output\n    always @(*) begin\n        C = {P3[7:4], P2[7:4], P1[7:4], P0[7:4]};\n    end\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module named `testMUX4_UDP` which instantiates a 4-to-1 Multiplexer (MUX4) module named `MUX4`. The `MUX4` module takes four inputs `in[3:0]` and two select inputs `sel[1:0]` and generates one output `out`. The `testMUX4_UDP` module initializes the inputs and select signals and then changes them after a delay of `5` time units. The `testMUX4_UDP` module also monitors the values of `in`, `sel`, and `out` after every change in the signals.\n\nYour task is to implement the `MUX4` module. The `MUX4` module should take four inputs `in[3:0]` and two select inputs `sel[1:0]` and generate one output `out`. The output `out` should be equal to the input corresponding to the select signal. The select signal should be interpreted as a binary number, with the most significant bit `sel[1]` being the most significant bit of the binary number. If `sel[1:0]` is `00`, then output `out` should be equal to `in[0]`. If `sel[1:0]` is `01`, then output `out` should be equal to `in[1]`. If `sel[1:0]` is `10`, then output `out` should be equal to `in[2]`. If `sel[1:0]` is `11`, then output `out` should be equal to `in[3]`.\n\nImplement the `MUX4` module within 200 lines of Verilog code.\n\n", "output": "module MUX4 (\n\tinput [3:0] in,\n\tinput [1:0] sel,\n\toutput reg out\n);\n\n\talways @(*) begin\n\t\tcase(sel)\n\t\t\t2'b00: out = in[0];\n\t\t\t2'b01: out = in[1];\n\t\t\t2'b10: out = in[2];\n\t\t\t2'b11: out = in[3];\n\t\t\tdefault: out = 1'b0;\n\t\tendcase\n\tend\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that takes in a binary input of 4 bits and outputs the same 4 bits but with the leftmost bit shifted to the rightmost position. For example, if the input is 1101, the output should be 1011.\n\nDesign a Verilog module called `left_shift` that takes in a 4-bit input called `in` and outputs a 4-bit value called `out`. The module should include the following:\n\n1. Module ports:\n   - `in`: a 4-bit input\n   - `out`: a 4-bit output\n\n2. The module should include the following internal signals:\n   - `temp`: a 4-bit wire\n   - `shifted`: a 4-bit wire\n\n3. The module should perform the following operations:\n   - Assign the value of `in` to `temp`.\n   - Shift the bits in `temp` to the left by one position and assign the result to `shifted`.\n   - Assign the value of `shifted` to `out`.\n\nEnsure that the module includes proper supply voltage and ground connections.\n\n", "output": "module left_shift (\n    input [3:0] in,\n    output [3:0] out\n);\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n\n    // Local signals\n    wire [3:0] temp;\n    wire [3:0] shifted;\n\n    // Assign the input to temp\n    assign temp = in;\n\n    // Shift the bits in temp to the left by one position and assign the result to shifted\n    assign shifted = {temp[2:0], temp[3]};\n\n    // Assign shifted to the output\n    assign out = shifted;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will generate an output signal `clk_out` that will be high for one clock cycle when the input clock signal `clk_ena` transitions from low to high and when the counter reaches a specific value `M2` within a given period. The counter should count from 0 to `BAUDRATE-1` and then reset to 0. The module should also have a reset signal `rstn` which should reset the counter to 0 when it goes low.\n\nWrite a Verilog module that implements the above functionality. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: The clock signal\n- `clk_ena`: The enable signal for the counter\n- `rstn`: The asynchronous reset signal\n\nOutputs:\n- `clk_out`: The output signal that goes high for one clock cycle when the counter reaches `M2` within a given period\n\nAssume that `BAUDRATE` and `M2` are constants that are already defined.\n\n", "output": "module clk_generator(\n    input clk,\n    input clk_ena,\n    input rstn,\n    output reg clk_out\n);\n\nparameter BAUDRATE = 8;\nparameter M2 = 4;\n\nreg [log2(BAUDRATE)-1:0] divcounter = 0;\n\n// Counter\nalways @(posedge clk or negedge rstn) begin\n    if (!rstn) begin\n        divcounter <= 0;\n    end\n    else if (clk_ena) begin\n        divcounter <= (divcounter == BAUDRATE - 1) ? 0 : divcounter + 1;\n    end\n    else begin\n        divcounter <= BAUDRATE - 1;\n    end\nend\n\n// Output\nalways @(posedge clk) begin\n    clk_out <= (divcounter == M2) ? clk_ena : 0;\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a module that performs a 4-bit unsigned multiplication using a combinational circuit. The module should have two inputs, A and B, each 4 bits wide. The output should be a 8-bit value that represents the product of A and B. You may not use any built-in multiplication operators or functions.", "output": "module unsigned_multiplier (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] product\n);\n\nreg [3:0] partial_products [0:3];\n\nalways @(*) begin\n    partial_products[0] = A * B[0];\n    partial_products[1] = A * B[1];\n    partial_products[2] = A * B[2];\n    partial_products[3] = A * B[3];\n    product = {partial_products[0], partial_products[1][3:0], partial_products[2][3:0], partial_products[3][3:0]};\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that can generate a PWM signal with a given frequency and duty cycle. The module should have two inputs: a clock signal and a duty cycle value. The clock signal should be used to generate the PWM signal, and the duty cycle value should be used to set the percentage of time that the PWM signal is high.\n\nThe module should have one output, which is the PWM signal. The frequency of the PWM signal should be equal to the frequency of the clock signal, and the duty cycle of the PWM signal should be equal to the duty cycle value.\n\nWrite a Verilog module that meets the above requirements. You may assume that the duty cycle value will be a 8-bit unsigned integer.\n\n", "output": "module pwm_generator (\n    input clock,\n    input [7:0] duty_cycle,\n    output reg pwm\n);\n\nreg [7:0] counter;\n\nalways @(posedge clock) begin\n    if (counter == 0) begin\n        pwm <= 1;\n    end else if (counter == duty_cycle) begin\n        pwm <= 0;\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as professional verilog designer. Here is a Karnaugh map for a 4-bit input function F(A,B,C,D).\n\nCD\\ AB | 00 | 01 | 11 | 10 |\n-------|----|----|----|----|\n  00   |  1 |  0 |  0 |  1 |\n  01   |  0 |  1 |  1 |  0 |\n  11   |  0 |  1 |  1 |  0 |\n  10   |  1 |  0 |  0 |  1 |\n\nImplement this function using a Verilog module named \"karnaugh_map\". The module should have 4 inputs (A, B, C, and D) and one output (F). Use the Karnaugh map to simplify the function and then write the Verilog code to implement the simplified function. You may use any gates (AND, OR, NOT, XOR, etc.) to implement the function. Keep your code as simple as possible.", "output": "module karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @* begin\n    case ({A, B, C, D})\n      4'b0000: F = 1;\n      4'b0001: F = 0;\n      4'b0010: F = 0;\n      4'b0011: F = 1;\n      4'b0100: F = 0;\n      4'b0101: F = 1;\n      4'b0110: F = 1;\n      4'b0111: F = 0;\n      4'b1000: F = 1;\n      4'b1001: F = 0;\n      4'b1010: F = 0;\n      4'b1011: F = 1;\n      4'b1100: F = 0;\n      4'b1101: F = 1;\n      4'b1110: F = 1;\n      4'b1111: F = 0;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that performs sign extension on a 16-bit input signal. Sign extension is a process that extends the most significant bit (MSB) of a signed binary number to all the additional bits to the left, creating a larger binary number with the same sign. For example, if the input signal is 0b1010 (decimal 10), and we want to extend it to 32 bits, the output signal should be 0xFFFFFFFA (decimal -6).\n\nDesign a Verilog module called `sign_extend` that takes a 16-bit input signal `reg_in` and outputs a 32-bit signal `reg_out`. The module should have a clock input `clk` and a reset input `reset`. The module should perform sign extension on the input signal and output the result on `reg_out`. The module should also be able to handle the following cases:\n- If the input signal is positive, the output signal should be extended with zeros.\n- If the input signal is negative, the output signal should be extended with ones.\n- If the input signal is 0, the output signal should be 0.\n\nTest your `sign_extend` module by instantiating it in a testbench module called `sig_extend_tb`. The testbench should apply the following input signals to the `reg_in` signal:\n- 10\n- 15\n- -20\n- 50\n- -32768\n- 32767\n- 0\n- 1\n- -1\n\nThe testbench should verify that the output signals `reg_out` are correct for each input signal.\n\n", "output": "module sign_extend(\n    input [15:0] reg_in,\n    output reg [31:0] reg_out,\n    input clk,\n    input reset\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            reg_out <= 0;\n        end\n        else begin\n            if (reg_in[15] == 1) begin\n                reg_out <= {16'b1111111111111111, reg_in};\n            end\n            else begin\n                reg_out <= {16'b0000000000000000, reg_in};\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module for a 4-bit adder that takes two 4-bit inputs (A and B) and produces a 4-bit output (S). The module should also have a carry-out output (COUT) that indicates whether the addition resulted in a carry-out.\n\nThe module should have the following interface:\n\n```\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output COUT\n);\n```\n\nYou should use full adders to implement the 4-bit adder.\n\n", "output": "module full_adder (\n    input A,\n    input B,\n    input CIN,\n    output S,\n    output COUT\n);\n\n    assign S = A ^ B ^ CIN;\n    assign COUT = (A & B) | (A & CIN) | (B & CIN);\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output COUT\n);\n\n    wire [3:0] C;\n\n    full_adder fa0(A[0], B[0], 0, S[0], C[0]);\n    full_adder fa1(A[1], B[1], C[0], S[1], C[1]);\n    full_adder fa2(A[2], B[2], C[1], S[2], C[2]);\n    full_adder fa3(A[3], B[3], C[2], S[3], COUT);\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that implements a 4-bit barrel shifter. The module should have two inputs (A and B) and one output (result). A is the 4-bit number to be shifted, and B is the number of bits to shift it by. If B is positive, the module should shift A to the left by B bits. If B is negative, the module should shift A to the right by abs(B) bits. The module should use combinational logic to implement the shift operation.", "output": "module barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        if (B >= 0) begin\n            result = A << B;\n        end else begin\n            result = A >> abs(B);\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been hired by a company that designs and manufactures digital circuits. Your first task is to design a Verilog module that implements a D flip-flop with asynchronous set and clock enable. The module should have the following inputs and outputs:\n\n- `CLK`: a clock input\n- `D`: a data input\n- `SET`: an asynchronous set input\n- `SLEEP_B`: a clock enable input\n- `NOTIFIER`: an output that should be set high whenever the flip-flop is set by the `SET` input\n\nThe module should behave as follows:\n\n- When `SET` is high, the output `Q` should be set to 1, regardless of the value of `D`.\n- When `SET` is low and `SLEEP_B` is high, the output `Q` should follow the input `D` on the rising edge of `CLK`.\n- When `SLEEP_B` is low, the output `Q` should remain constant, regardless of the values of `D`, `SET`, and `CLK`.\n- Whenever the flip-flop is set by the `SET` input, the `NOTIFIER` output should be set high for one clock cycle.\n\nWrite a Verilog module that implements the D flip-flop with asynchronous set and clock enable, as described above. Your module should be self-contained, i.e., it should not reference any external modules. Your code should be no longer than 200 lines of Verilog.\n\n", "output": "module dff_asynchronous_set_clock_enable (\n  output Q,\n  input D,\n  input CLK,\n  input SET,\n  input SLEEP_B,\n  output NOTIFIER\n);\n\n  reg Q_;\n  wire SET_;\n\n  assign SET_ = ~SET;\n\n  always @(posedge CLK) begin\n    if (SLEEP_B) begin\n      Q_ <= SET_ ? 1'b1 : D;\n    end\n  end\n\n  always @(SET) begin\n    if (SET) begin\n      Q_ <= 1'b1;\n      NOTIFIER <= 1'b1;\n    end else begin\n      NOTIFIER <= 1'b0;\n    end\n  end\n\n  assign Q = SLEEP_B ? Q_ : Q_;\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 4-bit synchronous up-counter with asynchronous reset functionality. The module should have the following inputs and outputs:\n\n- Inputs: \n  - `clk`: A clock signal with a 50% duty cycle\n  - `rst`: An asynchronous active-low reset signal\n  - `en`: An enable signal that allows the counter to increment when high\n\n- Outputs:\n  - `count`: A 4-bit binary value representing the current count value\n\nThe counter should increment on the positive edge of the clock signal when the enable signal is high. When the reset signal is low, the counter should immediately reset to 0.\n\nYou should implement this module using only combinational logic and D flip-flops.\n\n", "output": "module up_counter(\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      count <= 4'b0000;\n    end else if(en) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a module in Verilog to perform a simple arithmetic operation. The module should have two input ports, `a` and `b`, and one output port, `c`. The module should take in two 32-bit signed integers, `a` and `b`, and output their sum, `c`, as a 32-bit signed integer. \n\nYour module should also include a control input port, `op`, which is a 2-bit signal that determines the operation to be performed. If `op` is `00`, the module should output the sum of `a` and `b`. If `op` is `01`, the module should output the difference between `a` and `b`. If `op` is `10`, the module should output the product of `a` and `b`. If `op` is `11`, the module should output the quotient of `a` and `b`.\n\nYour module should be named `arithmetic_module` and should be written within 200 lines of Verilog code.\n\n", "output": "module arithmetic_module(\n    input signed [31:0] a,\n    input signed [31:0] b,\n    input [1:0] op,\n    output signed [31:0] c\n);\n\n// Declare internal signals\nreg signed [31:0] sum;\nreg signed [31:0] diff;\nreg signed [31:0] prod;\nreg signed [31:0] quotient;\n\n// Perform arithmetic operations\nalways @* begin\n    sum = a + b;\n    diff = a - b;\n    prod = a * b;\n    quotient = a / b;\nend\n\n// Select output based on op\nalways @* begin\n    case (op)\n        2'b00: c = sum;\n        2'b01: c = diff;\n        2'b10: c = prod;\n        2'b11: c = quotient;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 2-to-4 decoder with an enable input. The circuit should have two inputs, EN and SEL[0], and four outputs, Y[3:0]. When EN is high, the circuit should output a 1 on the selected output line based on the value of SEL[0]. When EN is low, all output lines should be 0.", "output": "module decoder (\n    input EN,\n    input SEL,\n    output reg [3:0] Y\n);\n\nalways @ (EN, SEL)\nbegin\n    if (EN)\n    begin\n        case (SEL)\n            1'b0: Y = 4'b0001;\n            1'b1: Y = 4'b0010;\n        endcase\n    end\n    else\n    begin\n        Y = 4'b0000;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit Gray code to binary converter. The module should take in a 4-bit Gray code input and output the corresponding 4-bit binary value. Use a procedural always block to implement the module.", "output": "module gray_to_binary (\n    input [3:0] gray,\n    output reg [3:0] binary\n);\n\n    always @ (gray) begin\n        binary[3] = gray[3];\n        binary[2] = binary[3] ^ gray[2];\n        binary[1] = binary[2] ^ gray[1];\n        binary[0] = binary[1] ^ gray[0];\n    end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 4-bit adder with a carry-in and a carry-out signal. The module should have the following inputs and outputs:\n\nInputs:\n- `a` (4-bit): the first input to the adder\n- `b` (4-bit): the second input to the adder\n- `cin` (1-bit): the carry-in signal\n\nOutputs:\n- `sum` (4-bit): the sum of `a` and `b`\n- `cout` (1-bit): the carry-out signal\n\nWrite a verilog module that implements this 4-bit adder and meets the following requirements:\n- The module should be named `four_bit_adder`.\n- The module should use only combinational logic.\n- The module should be synthesizable.\n- The module should be tested with a testbench that verifies the correctness of the adder for all possible inputs.\n\n", "output": "module four_bit_adder (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] sum_temp;\n\n  assign sum_temp = a + b + cin;\n\n  assign sum = sum_temp[3:0];\n  assign cout = sum_temp[4];\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will act as a 8-bit adder with carry-in and carry-out functionality. The module should take in two 8-bit inputs, A and B, and a carry-in bit, Cin. It should output the sum of A and B, along with a carry-out bit, Cout. \n\nThe module should be designed using Verilog and should be self-contained within 200 lines of code. You should assume that the inputs A and B will always be valid 8-bit inputs. The carry-in bit, Cin, will be either 0 or 1. The outputs, Sum and Cout, should also be valid 8-bit values.\n\nYour module should be named \"adder_8bit\" and should be able to handle any combination of inputs and carry-in values. Your design should be optimized for speed and area, and should not use any pre-built adder modules.\n\n", "output": "module adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    wire [7:0] temp_sum;\n    wire temp_carry;\n    \n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[7:0];\n    assign Cout = temp_sum[8];\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes 5 inputs and produces 1 output. The module should be named `multiplier` and should be implemented in Verilog. The inputs are:\n\n- `a` (8-bit signed integer)\n- `b` (8-bit signed integer)\n- `sel` (1-bit unsigned integer)\n- `reset` (1-bit unsigned integer)\n- `clk` (1-bit unsigned integer)\n\nThe `reset` signal is active-high and should reset the output to 0 when it is asserted. The `clk` signal should be used to synchronize the module. The `sel` signal should be used to select between two modes of operation: \n\n- When `sel` is 0, the output should be the product of `a` and `b`.\n- When `sel` is 1, the output should be the sum of `a` and `b`.\n\nThe module should be designed to minimize the number of logic gates used.\n\n", "output": "module multiplier(\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input sel,\n    input reset,\n    input clk,\n    output signed [15:0] out\n);\n\nreg signed [15:0] product;\nreg signed [15:0] sum;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        product <= 0;\n        sum <= 0;\n    end else begin\n        if (sel) begin\n            sum <= a + b;\n        end else begin\n            product <= a * b;\n        end\n    end\nend\n\nassign out = sel ? sum : product;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in several inputs and outputs a 32-bit sum. The module should be named `Adder` and have the following inputs and outputs:\n\n- `input [31:0] a`: a 32-bit input signal\n- `input [31:0] b`: a 32-bit input signal\n- `input [1:0] op`: a 2-bit input signal that determines the operation to be performed. If `op` is `2'b00`, the module should output the sum of `a` and `b`. If `op` is `2'b01`, the module should output the difference between `a` and `b`. If `op` is `2'b10`, the module should output the bitwise AND of `a` and `b`. If `op` is `2'b11`, the module should output the bitwise OR of `a` and `b`.\n- `output [31:0] out`: a 32-bit output signal that holds the result of the operation\n\nYou should implement the `Adder` module using behavioral verilog.\n\n", "output": "module Adder(\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op,\n    output [31:0] out\n);\n\nalways @(*) begin\n    case (op)\n        2'b00: out = a + b;\n        2'b01: out = a - b;\n        2'b10: out = a & b;\n        2'b11: out = a | b;\n        default: out = 0;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in three inputs and outputs a logical OR of these inputs. The module should be named `custom_or` and should have the following interface:\n\n```\nmodule custom_or (\n    input a,\n    input b,\n    input c,\n    output x\n);\n```\n\nThe module should use only basic logic gates (AND, OR, NOT) to implement the OR function. You should not use any pre-existing modules or functions that implement the OR function.\n\nYour module should be able to handle all possible input combinations of a, b, and c. Your implementation should be as efficient as possible, with minimal usage of logic gates.\n\n", "output": "module custom_or (\n    input a,\n    input b,\n    input c,\n    output x\n);\n\n    wire ab, abc;\n\n    assign ab = a | b;\n    assign abc = ab | c;\n    assign x = abc;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in three inputs, `a`, `b`, and `op`, and produces one output, `out`, according to the following truth table:\n\n| op | a | b | out |\n|----|---|---|-----|\n| 0  | 0 | 0 | 0   |\n| 0  | 0 | 1 | 1   |\n| 0  | 1 | 0 | 1   |\n| 0  | 1 | 1 | 0   |\n| 1  | 0 | X | 1   |\n| 1  | 1 | X | 0   |\n\nIn the truth table, `X` represents any value.\n\nYou should implement the module `two_input_logic` that takes in `a`, `b`, and `op` as inputs and produces `out` as output.\n\n", "output": "module two_input_logic (\n  input a,\n  input b,\n  input op,\n  output out\n);\n\n  assign out = op ? ~a : (a ^ b);\n\nendmodule"}
{"instruction": "Design a 2-input XOR gate using only NAND gates. The module should have two input ports and one output port. The output should be the XOR of the two input values.", "output": "module xor_nand (\n    input a,\n    input b,\n    output reg out\n);\n\n    assign nand1 = ~(a & b);\n    assign nand2 = ~(nand1 & nand1);\n    assign out = nand2;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that implements a 4-bit synchronous counter. The counter should have an input `clk` which is a 50 MHz clock signal. The counter should have an output `q` which is a 4-bit binary value representing the count. The counter should have an asynchronous reset input `reset` which, when asserted, should set the count to 0. The counter should count up to 15 and then wrap around to 0.\n\nUsing the given code snippet as inspiration, create a verilog module that implements this counter.\n\n", "output": "module synchronous_counter (\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or negedge reset) begin\n    if(reset == 0) begin\n        q <= 4'b0000;\n    end else if(q == 4'b1111) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nIn digital logic, a NAND gate is a logic gate that produces a low output when both of its inputs are high. The NAND gate is a fundamental building block for many digital circuits, and is often used as a universal gate, which means that any other logic gate can be created using only NAND gates.\n\nIn this problem, you are asked to implement a 3-input NAND gate using Verilog. The module should have three input ports, i0, i1, and i2, and one output port, o. The output should be low if all three inputs are high, and high otherwise.\n\nWrite a Verilog module that implements a 3-input NAND gate using the provided code snippet as a starting point. Your module should be named \"my_nand3\" and should be self-contained, meaning that it should not rely on any other modules to function.\n\n", "output": "module my_nand3 (output o, input i0, i1, i2);\n    wire nand1, nand2;\n    \n    assign nand1 = ~(i0 & i1);\n    assign nand2 = ~(nand1 & i2);\n    \n    assign o = nand2;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a 4-bit binary counter with asynchronous reset functionality. The module should have an input signal `clk` that is used to synchronize the counter operation, an input signal `reset` that is used to reset the counter asynchronously, and an output signal `count` that represents the current count value of the counter.\n\nThe counter should count up from 0 to 15 and then wrap around to 0 again. The counter should increment on the rising edge of the `clk` signal. When the `reset` signal is asserted, the counter should be immediately reset to 0.\n\nWrite a Verilog module that implements the above functionality. Your module should be named `counter` and should have the following inputs and outputs:\n\nInputs:\n- `clk`: a 1-bit input signal that is used to synchronize the counter operation.\n- `reset`: a 1-bit input signal that is used to reset the counter asynchronously.\n\nOutputs:\n- `count`: a 4-bit output signal that represents the current count value of the counter.\n\n", "output": "module counter (clk, reset, count);\n\ninput clk;\ninput reset;\noutput reg [3:0] count;\n\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset == 1'b1) // Asynchronous reset\n    count <= 4'b0000;\n  else if (count == 4'b1111) // Wrap around\n    count <= 4'b0000;\n  else\n    count <= count + 1; // Increment count\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a 4-to-1 multiplexer module using only basic logic gates such as AND, OR, and NOT gates. The module should select between four inputs, a, b, c, and d, based on the value of two select inputs, sel_1 and sel_0. If sel_1 and sel_0 are both false, the output should be a. If sel_1 is false and sel_0 is true, the output should be b. If sel_1 is true and sel_0 is false, the output should be c. If sel_1 and sel_0 are both true, the output should be d.", "output": "module mux_4to1(\n    input a,\n    input b,\n    input c,\n    input d,\n    input sel_1,\n    input sel_0,\n    output reg out_always\n);\n\nalways @(*) begin\n    if(sel_1 == 0 && sel_0 == 0) begin\n        out_always = a;\n    end\n    else if(sel_1 == 0 && sel_0 == 1) begin\n        out_always = b;\n    end\n    else if(sel_1 == 1 && sel_0 == 0) begin\n        out_always = c;\n    end\n    else begin\n        out_always = d;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nImplement a Verilog module that performs a 4-bit to 16-bit sign extension. The input to the module is a 4-bit signed integer, and the output is a 16-bit signed integer. The input is represented in two's complement format, and the sign bit is the most significant bit. The module should extend the sign bit to fill the remaining 12 bits of the output.\n\nYour task is to implement the module that performs the sign extension. The module should be named `sign_extender` and should have the following ports:\n\n- `input [3:0] in`: the 4-bit input signed integer.\n- `output [15:0] out`: the 16-bit output signed integer.\n\nYou are not allowed to use any Verilog operators or functions that perform sign extension. You should only use bitwise operators and conditional statements.\n\nYou should assume that the input is always in the range of -8 to 7, inclusive.\n\n", "output": "module sign_extender (\n    input [3:0] in,\n    output [15:0] out\n);\n\n    wire [3:0] abs_in = (in < 0) ? -in : in;\n    wire [15:0] extended = { {12{in[3]}}, in };\n    \n    assign out = (in < 0) ? -extended : extended;\n    \nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module called `CountOnes` that takes in a 8-bit input vector `in` and outputs a 4-bit value `out`. The output value should represent the number of ones in the input vector.\n\nYour module should have the following ports:\n- `in`: an 8-bit input vector\n- `out`: a 4-bit output value representing the number of ones in `in`\n\nYou should implement this module using behavioral verilog.\n\n", "output": "module CountOnes (\n    /* Input ports */\n    in,\n    /* Output ports */\n    out\n);\n\ninput [7:0] in;\noutput [3:0] out;\n\ninteger i;\nreg [3:0] count;\n\nalways @ (*) begin\n    count = 0;\n    for (i = 0; i < 8; i = i + 1) begin\n        if (in[i] == 1) begin\n            count = count + 1;\n        end\n    end\n    out = count;\nend\n\nendmodule"}
{"instruction": "\n\nIn digital circuit design, it is common to use pre-designed modules to simplify the design process. In this problem, you are given a Verilog code snippet for a module called \"sky130_fd_sc_hd__fill_1\". This module has four input ports: VPWR, VGND, VPB, and VNB. The module also instantiates another module called \"sky130_fd_sc_hd__fill\" and connects its input ports to the input ports of the top-level module.\n\nYour task is to implement the \"sky130_fd_sc_hd__fill\" module. This module has four input ports and no output ports. The input ports are:\n- VPWR: power supply voltage\n- VGND: ground voltage\n- VPB: voltage at the positive terminal of a bipolar junction transistor (BJT)\n- VNB: voltage at the negative terminal of a BJT\n\nThe module should implement the following behavior:\n- If VPB is greater than VNB, set the output of the module to VPWR\n- If VPB is less than VNB, set the output of the module to VGND\n- If VPB is equal to VNB, set the output of the module to an intermediate voltage between VPWR and VGND. The exact value of this voltage is not important, as long as it is between VPWR and VGND.\n\nYou can assume that the input voltages are valid and within the operating range of the circuit.\n\nImplement the \"sky130_fd_sc_hd__fill\" module within 200 lines of Verilog code.\n\n", "output": "module sky130_fd_sc_hd__fill (\n    VPWR,\n    VGND,\n    VPB,\n    VNB\n);\n\n    input VPWR;\n    input VGND;\n    input VPB;\n    input VNB;\n\n    reg out;\n\n    always @(*) begin\n        if (VPB > VNB) begin\n            out = VPWR;\n        end else if (VPB < VNB) begin\n            out = VGND;\n        end else begin\n            out = (VPWR + VGND) / 2;\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a full adder module using Verilog. A full adder is a combinational logic circuit that takes three inputs: A, B, and a carry-in (CIN), and produces two outputs: a sum (SUM) and a carry-out (COUT). The full adder module should have the following ports:\n- A (input): a single-bit input representing the first operand\n- B (input): a single-bit input representing the second operand\n- CIN (input): a single-bit input representing the carry-in\n- SUM (output): a single-bit output representing the sum of A, B, and CIN\n- COUT (output): a single-bit output representing the carry-out of the addition\n\nYour module should be named \"full_adder\" and should be implemented using basic gates (AND, OR, NOT, XOR, etc.) and/or other basic modules. You are not allowed to use any pre-built full adder modules or higher-level constructs (such as \"+\" operators). Your module should be synthesizable and should meet the following requirements:\n- The module should have a maximum delay of 10 nanoseconds\n- The module should have a maximum area of 1000 square microns\n\n", "output": "module full_adder(\n    input A,\n    input B,\n    input CIN,\n    output reg SUM,\n    output reg COUT\n);\n\n    always @(*) begin\n        SUM = A ^ B ^ CIN;\n        COUT = (A & B) | (CIN & A) | (CIN & B);\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a simple calculator that can perform addition, subtraction, multiplication, and division. The calculator should have two input registers, A and B, which can hold 8-bit values. The calculator should also have an output register, C, which can hold a 16-bit value. The calculator should have four control inputs: add, subtract, multiply, and divide. The calculator should perform the appropriate operation on the values in registers A and B based on the control inputs and store the result in register C.\n\nDesign a verilog module that implements this calculator. Your module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal\n- `reset`: a reset signal\n- `a`: an 8-bit input register for value A\n- `b`: an 8-bit input register for value B\n- `add`: a control input for addition\n- `sub`: a control input for subtraction\n- `mul`: a control input for multiplication\n- `div`: a control input for division\n\nOutputs:\n- `c`: a 16-bit output register for the result of the operation\n\nAssume that the inputs will be stable when the clock signal rises. The output should be updated on the falling edge of the clock signal.\n\n", "output": "module calculator(\n  input clk,\n  input reset,\n  input [7:0] a,\n  input [7:0] b,\n  input add,\n  input sub,\n  input mul,\n  input div,\n  output reg [15:0] c\n);\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      c <= 0;\n    end else begin\n      if (add) begin\n        c <= a + b;\n      end else if (sub) begin\n        c <= a - b;\n      end else if (mul) begin\n        c <= a * b;\n      end else if (div) begin\n        c <= a / b;\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that implements a D flip-flop with asynchronous reset and synchronous set. The module should have four inputs and one output. The inputs are D, C, R, and E, and the output is Q. The D input is the data input, C is the clock input, R is the asynchronous reset input, and E is an active-high enable input. The output Q is the flip-flop output.\n\nThe module should operate as follows:\n- When E is high, the flip-flop should operate normally. On the rising edge of the clock, the output Q should be updated with the value of the D input. If R is high, the output Q should be reset to 0 asynchronously.\n- When E is low, the flip-flop should hold its current state, regardless of the values of D, C, and R.\n\nYour task is to implement this module in Verilog. The module should be self-contained and should not rely on any external modules or libraries. The module should be no more than 200 lines of Verilog code.\n\n", "output": "module d_ff_async_reset_sync_set (\n  input D,\n  input C,\n  input R,\n  input E,\n  output Q\n);\n\n  reg Q_next;\n\n  always @ (posedge C) begin\n    if (E) begin\n      if (R) begin\n        Q_next <= 1'b0;\n      end else begin\n        Q_next <= D;\n      end\n    end\n  end\n\n  always @ (posedge C) begin\n    if (!E) begin\n      Q_next <= Q_next;\n    end\n  end\n\n  assign Q = Q_next;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. In this task, you are required to implement a combinational function F(A,B,C) using the given Karnaugh map with 3 variables. The Karnaugh map table has four rows and four columns, with the variables A and B on the left and the variable C on the top. Each cell in the table represents the output value of the function F for a specific combination of input values. Your task is to implement a module named karnaugh_map that takes in the input variables A, B, and C, and outputs the value of the function F. You must use the given Karnaugh map to simplify the function F and write the corresponding Verilog code. You may use any logic gates and operators in your code.", "output": "module karnaugh_map(\n  input wire A, B, C,\n  output reg F\n);\n\n  always @*\n  begin\n    case ({A,B,C})\n      3'b000: F = 0;\n      3'b001: F = 1;\n      3'b010: F = 0;\n      3'b011: F = 1;\n      3'b100: F = 0;\n      3'b101: F = 1;\n      3'b110: F = 1;\n      3'b111: F = 0;\n    endcase\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a simple counter. The counter should be able to count from 0 to a specified maximum value and then reset to 0. The maximum value should be configurable via a parameter. The counter should be synchronous to a clock signal and should increment on each clock cycle. The output of the counter should be a binary value representing the current count.\n\nDesign a Verilog module that implements this counter with the following interface:\n\n```\nmodule counter (\n  input clk,\n  input rst,\n  output reg [7:0] count\n);\n```\n\nThe `clk` input is the clock signal, `rst` is a synchronous reset signal, and `count` is the output of the counter. The counter should be able to count up to 255 (8 bits).\n\nEnsure that your Verilog module is self-contained and can be simulated without any additional testbench code. Your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module counter (\n  input clk,\n  input rst,\n  output reg [7:0] count\n);\n\n  parameter MAX_COUNT = 255; // Maximum count value\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n    end else if (count == MAX_COUNT) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-bit adder/subtractor. The module should have four input ports: A, B, Cin, and mode. A and B are 4-bit input ports that are used to store the operands. Cin is a 1-bit input port that is used to store the carry-in value. Mode is a 1-bit input port that is used to select the operation mode: 0 for addition and 1 for subtraction. The module should also have two output ports: S and Cout. S is a 4-bit output port that is used to output the sum/difference. Cout is a 1-bit output port that is used to output the carry-out value.", "output": "module addsub_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input mode,\n  output reg [3:0] S,\n  output reg Cout\n);\n  \n  always @(*) begin\n    if(mode == 0) begin //addition\n      S = A + B + Cin;\n      Cout = (S >= 16) ? 1 : 0;\n    end\n    else begin //subtraction\n      S = A - B - Cin;\n      Cout = (S < 0) ? 0 : 1;\n    end\n  end\n  \nendmodule\n"}
{"instruction": "\n\nYou are tasked with designing a counter that counts from 0 to 999 and then resets back to 0. The counter should be implemented using a Verilog module and should have a single input `clk` which is a clock signal. The counter should output a 10-bit binary number `count` which represents the current count value. \n\nCreate a Verilog module that implements the counter and outputs the `count` value. \n\n", "output": "module counter (/*AUTOARG*/\n   // Inputs\n   clk,\n   // Outputs\n   count\n   );\n\n   input clk;\n   output reg [9:0] count;\n\n   always @ (posedge clk) begin\n      if (count == 999) begin\n         count <= 0;\n      end\n      else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module named \"parity_check\" that checks the parity of an 8-bit input data. The module should have two inputs: an 8-bit input data and a control signal, and one output: a parity bit. The output should be set to 1 if the number of 1's in the input data is odd, and 0 if the number of 1's in the input data is even. If the control signal is 0, the module should output 0, regardless of the input data.", "output": "module parity_check (\n  input [7:0] data_in,\n  input control,\n  output reg parity\n);\n\n  integer i;\n  reg [7:0] data_temp;\n  \n  always @ (data_in, control) begin\n    if (control == 0) begin\n      parity <= 0;\n    end else begin\n      data_temp = data_in;\n      parity = 0;\n      for (i = 0; i < 8; i = i + 1) begin\n        parity = parity ^ data_temp[i];\n      end\n    end\n  end\n\nendmodule\n"}
{"instruction": "Design a module that implements an XOR gate using a non-clocked always block. The module should take two input signals and generate one output signal. The XOR gate must be implemented using only combinational logic.", "output": "module xor_gate(\n    input a,\n    input b,\n    output out_comb\n);\n\nassign out_comb = a ^ b;\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output reg out_comb\n);\n\nxor_gate xor_inst(\n    .a(a),\n    .b(b),\n    .out_comb(out_comb)\n);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Implement a module that takes in a 16-bit input and outputs the number of set bits (bits with value 1) in the input. The module should have one input, a 16-bit binary number (D[15:0]), and one output, a 4-bit binary number (count[3:0]). The module should count the number of set bits in the input using a parallel prefix adder.", "output": "module bit_counter (\n    input [15:0] D,\n    output reg [3:0] count\n);\n\n// Create a 4-bit parallel prefix adder\nwire [3:0] P[0:3];\nassign P[0] = D[0:3];\nassign P[1] = P[0] + D[4:7];\nassign P[2] = P[1] + D[8:11];\nassign P[3] = P[2] + D[12:15];\n\n// Output the count\nassign count = P[3];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a memory module for a system that uses a VGA display. The memory module must be able to store and retrieve 2-bit color values for each pixel on the display. The VGA display has a resolution of 640x480 pixels and a refresh rate of 60 Hz. The memory module must be able to keep up with this refresh rate and provide the correct color values for each pixel.\n\nDesign a Verilog module that can accomplish this task. The module should have the following inputs and outputs:\n\nInputs:\n- `clk`: a clock signal with a frequency of 25 MHz\n- `reset`: a reset signal that sets the memory to its initial state\n- `address`: a 19-bit input that specifies the memory location to read or write\n- `data_in`: a 2-bit input that specifies the color value to write to the specified memory location\n- `write_enable`: a 1-bit input that enables writing to the memory\n\nOutputs:\n- `data_out`: a 2-bit output that provides the color value stored at the specified memory location\n\nAssume that the memory module is implemented using block RAM.\n\n", "output": "module vga_memory(\n  input clk,\n  input reset,\n  input [18:0] address,\n  input [1:0] data_in,\n  input write_enable,\n  output reg [1:0] data_out\n);\n\n  reg [1:0] memory [0:307199]; // 640x480 pixels = 307200, but we index from 0\n  integer i;\n\n  always @(posedge clk) begin\n    if(reset) begin\n      for(i = 0; i < 307200; i = i + 1) begin\n        memory[i] <= 2'b00;\n      end\n    end\n    else if(write_enable) begin\n      memory[address] <= data_in;\n    end\n    data_out <= memory[address];\n  end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing an FPGA module that counts up or down based on input signals. The module should have the following inputs:\n- `clk`: a clock signal\n- `n_rst`: a reset signal\n- `up`: a signal that determines whether the counter should count up or not (1 = count up, 0 = count down)\n- `dn`: a signal that determines whether the counter should count down or not (1 = count down, 0 = count up)\n- `in1` and `in2`: two input signals that should be ignored by the module\nAnd the following outputs:\n- `cnt`: a 32-bit signal that represents the current count value\n- `cnt_1k`: a 4-bit signal that represents the count value divided by 1000, rounded down (e.g. if the count is 12345678, `cnt_1k` should be 12)\n- `out1` and `out2`: two output signals that should always be 0\n\nThe counter should start at 0 when `n_rst` is high, and should count up or down by 1 on each rising edge of `clk`, depending on the values of `up` and `dn`. If both `up` and `dn` are high, the counter should not change. If neither `up` nor `dn` are high, the counter should hold its current value.\n\nYour task is to implement this module in Verilog, and write a testbench to verify its functionality.\n\n", "output": "module counter (\n    input clk,\n    input n_rst,\n    input up,\n    input dn,\n    input in1,\n    input in2,\n    output reg [31:0] cnt,\n    output reg [3:0] cnt_1k,\n    output reg out1,\n    output reg out2\n);\n\nalways @(posedge clk) begin\n    if (n_rst) begin\n        cnt <= 0;\n        cnt_1k <= 0;\n    end else if (up && !dn) begin\n        cnt <= cnt + 1;\n    end else if (!up && dn) begin\n        cnt <= cnt - 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (cnt >= 1000) begin\n        cnt_1k <= cnt_1k + 1;\n        cnt <= cnt - 1000;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a Verilog module that implements a 4-bit binary counter. The module should have two inputs: a clock signal (clk) and a reset signal (rst). When the reset signal is high, the counter should be reset to 0. When the clock signal transitions from low to high (positive edge), the counter should increment by 1. The module should have one output, which is the current value of the counter.\n\nYou should create a Verilog module that implements this functionality. Your module should be named \"binary_counter\" and should have the following ports:\n\n- clk (input): the clock signal\n- rst (input): the reset signal\n- count (output): the current value of the counter (4 bits)\n\nYour module should be no more than 200 lines of Verilog code.\n\n", "output": "module binary_counter(clk, rst, count);\n\n  input clk, rst;\n  output reg [3:0] count;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 2-bit comparator. The module should have two 2-bit input signals and one 2-bit output signal. If the first input signal is greater than the second input signal, the output signal should be 01. If the first input signal is equal to the second input signal, the output signal should be 10. If the first input signal is less than the second input signal, the output signal should be 00.", "output": "module comparator (\n    input [1:0] in_0,\n    input [1:0] in_1,\n    output reg [1:0] out\n);\n\nalways @(*) begin\n    if (in_0 > in_1) begin\n        out <= 2'b01;\n    end else if (in_0 == in_1) begin\n        out <= 2'b10;\n    end else begin\n        out <= 2'b00;\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a reset synchronizer. \nA reset synchronizer is a digital circuit that synchronizes an asynchronous reset signal with the clock signal of the system. \nThe purpose of the reset synchronizer is to ensure that the reset signal is stable and glitch-free before it is used to reset the circuit.\n\nYour module should have the following inputs and outputs:\n\nInputs:\n  - rst : asynchronous reset signal\n  - clk : clock signal of the system\n\nOutputs:\n  - rst_sync : synchronized reset signal\n\nYour module should implement the following functionality:\n\n  - The asynchronous reset signal should be synchronized with the clock signal of the system.\n  - The synchronized reset signal should be active low.\n  - The reset synchronizer should have a delay of at least one clock cycle to ensure that the reset signal is stable and glitch-free before it is used.\n  \nTo implement the reset synchronizer, you should use Verilog code to define a flip-flop that is triggered by the clock signal. \nThe asynchronous reset signal should be connected to the input of the flip-flop through a series of two or more delay elements. \nThis will ensure that the reset signal is stable and glitch-free before it is used to reset the circuit. \nThe output of the flip-flop should be the synchronized reset signal.", "output": "module reset_synchronizer (\n  input rst,\n  input clk,\n  output reg rst_sync\n);\n\nparameter DELAY = 2; // number of delay elements\n\nalways @(posedge clk) begin\n  rst_sync <= #DELAY (rst);\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a clock divider. \nA clock divider is a digital circuit that takes an input clock signal and outputs a slower clock signal. \nThe slower clock signal is generated by dividing the frequency of the input clock signal by a specified integer value.\nYour module should have the following inputs and outputs:\n\nInputs: \n- clk_in: the input clock signal\n- rst: a reset signal that resets the divider to its initial state\n\nOutputs: \n- clk_out: the output clock signal, which is a slower version of the input clock signal\n\nYour module should also have the following parameter:\n\n- div_factor: the integer value by which the input clock signal will be divided\n\nTo implement the clock divider, you should use Verilog code to create a counter that counts up to the div_factor and then resets to zero. \nYou should use the counter to generate the slower clock signal by toggling the clk_out signal every time the counter reaches its maximum value.\nThe rst input signal should be used to reset the counter to zero.", "output": "module clock_divider (\n  input clk_in, rst,\n  output reg clk_out\n);\n\nparameter div_factor = 2; // divide by 2\n\nreg [31:0] counter;\n\nalways @(posedge clk_in or posedge rst) begin\n  if (rst) begin\n    counter <= 0;\n    clk_out <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter == div_factor - 1) begin\n      counter <= 0;\n      clk_out <= ~clk_out;\n    end\n  end\nend\n\nendmodule"}
{"instruction": "\nYou have been given a Verilog code snippet for a full adder module named `sky130_fd_sc_hd__fa`. The module takes in 8 inputs and produces 2 outputs. The inputs `A`, `B`, `CIN`, `VPWR`, `VGND`, `VPB`, and `VNB` are of the `reg` data type and are registered. The output `COUT` and `SUM` are of the `wire` data type. The initial state of all inputs is `x`. After 20 time units, `A` is set to `0`, after 40 time units, `B` is set to `0`, and so on. The module is instantiated in the `top` module.\n\nYour task is to complete the implementation of the `sky130_fd_sc_hd__fa` module. The module should implement a full adder, which takes in two bits `A` and `B` and a carry-in bit `CIN`, and produces a sum bit `SUM` and a carry-out bit `COUT`. The full adder should be implemented using only combinational logic.\n\n", "output": "module sky130_fd_sc_hd__fa(\n    input A,\n    input B,\n    input CIN,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output COUT,\n    output SUM\n);\n\n    wire W1;\n    wire W2;\n    wire W3;\n\n    // XOR gates\n    assign W1 = A ^ B;\n    assign SUM = W1 ^ CIN;\n\n    // AND gates\n    assign W2 = A & B;\n    assign W3 = CIN & W1;\n\n    // OR gate\n    assign COUT = W2 | W3;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module for a 4-to-1 multiplexer using behavioral modeling. The module should have four input ports, one output port, and two control ports. The output port should be connected to one of the four input ports based on the values of the control ports as follows:\n\n- If Sel1 and Sel2 are both 0, the output should be connected to In0\n- If Sel1 is 0 and Sel2 is 1, the output should be connected to In1\n- If Sel1 is 1 and Sel2 is 0, the output should be connected to In2\n- If Sel1 and Sel2 are both 1, the output should be connected to In3\n\nDesign the verilog module for the 4-to-1 multiplexer and name it \"mux4to1\". Ensure that the inputs and outputs are named as follows:\n\n- Four input ports: In0, In1, In2, In3\n- Two control ports: Sel1, Sel2\n- One output port: Out\n\n", "output": "module mux4to1 (\n    In0,\n    In1,\n    In2,\n    In3,\n    Sel1,\n    Sel2,\n    Out\n);\n\n    input In0, In1, In2, In3, Sel1, Sel2;\n    output Out;\n\n    reg Out;\n\n    always @(*) begin\n        case ({Sel1, Sel2})\n            2'b00: Out = In0;\n            2'b01: Out = In1;\n            2'b10: Out = In2;\n            2'b11: Out = In3;\n        endcase\n    end\n\nendmodule"}
{"instruction": "Design a system that combines a shift register and a NOR gate. The shift register should have a length of 3 and use three D flip-flops with asynchronous reset. The system should also include an additional functional module that takes in the output of the shift register and the two input signals of the NOR gate to generate the final output signal. The NOR gate should be implemented using only NAND gates, which can be constructed using basic logic gates like AND, OR, and NOT gates. The output signal should be the negation of the OR function of the two input signals.", "output": "module shift_reg_nor (\n    input clk,\n    input reset,\n    input a,\n    input b,\n    input d,\n    output out\n);\n\n    reg [2:0] shift_reg;\n    wire nor_out;\n\n    // Shift register\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            shift_reg <= 3'b0;\n        end else begin\n            shift_reg <= {shift_reg[1:0], d};\n        end\n    end\n\n    // NOR gate\n    nand n1 (nor_out, a, b);\n    nand n2 (nor_out, nor_out, nor_out);\n\n    // Output\n    assign out = ~nor_out | shift_reg[2];\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit shift register with serial in and parallel out. The module should have two inputs: a 1-bit serial input signal (SER_IN) and a 1-bit shift enable signal (SH_EN). The module should have a 4-bit parallel output (PAR_OUT). When SH_EN is high, the module should shift the data in PAR_OUT to the left on each clock cycle. When SH_EN is low, the module should hold the data in PAR_OUT. The module should always load the data from SER_IN into the least significant bit of PAR_OUT on each clock cycle.", "output": "module shift_register (\n    input clk,\n    input SER_IN,\n    input SH_EN,\n    output [3:0] PAR_OUT\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (SH_EN) begin\n        shift_reg <= {shift_reg[2:0], SER_IN};\n    end else begin\n        shift_reg <= shift_reg;\n    end\nend\n\nassign PAR_OUT = shift_reg;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 3-bit up-down counter with a control input. The counter should count up or down depending on the value of the control input. If the control input is high, the counter should count up. If the control input is low, the counter should count down. The module should have a reset input that sets the counter to zero and a 3-bit output that represents the current count value.", "output": "module up_down_counter (\n    input clk,\n    input reset,\n    input control,\n    output reg [2:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 3'b0;\n        end else if (control) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}
{"instruction": "Design an XOR gate that takes two input ports and produces one output port. However, this time, you are not allowed to use any clocked always block in your design. Instead, you should use a combination of AND, OR, and NOT gates to achieve the same functionality.", "output": "module xor_gate(\n    input a,\n    input b,\n    output out_comb\n);\n\n    assign out_comb = (a & ~b) | (~a & b);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module that takes in four inputs and produces one output. The module should be named \"my_module\". The inputs are as follows:\n\n- \"clk\": a clock input.\n- \"rst\": a reset input.\n- \"data_in\": a 4-bit input.\n- \"enable\": an enable input.\n\nThe output of the module is:\n\n- \"data_out\": a 4-bit output.\n\nThe module should operate as follows:\n\n- When \"enable\" is high, the module should output \"data_in\" on \"data_out\".\n- When \"enable\" is low, the module should output the value of \"data_out\" from the previous clock cycle.\n\nYou should use flip-flops to store the output from the previous clock cycle. \n\n", "output": "module my_module (\n    clk,\n    rst,\n    data_in,\n    enable,\n    data_out\n);\n\n    input clk, rst, enable;\n    input [3:0] data_in;\n    output reg [3:0] data_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 4'b0;\n        end\n        else if (enable) begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in two 4-bit inputs, `A` and `B`, and outputs the bitwise AND of `A` and `B`. You should implement this using only bitwise operators and assign statements. \n\nYour module should be named `bitwise_and_4bit` and should have the following inputs and outputs:\n- `input [3:0] A`: a 4-bit input\n- `input [3:0] B`: a 4-bit input\n- `output [3:0] M`: a 4-bit output representing the bitwise AND of `A` and `B`\n\nYou should implement this by using the `&` operator to perform the bitwise AND operation on each bit of `A` and `B`. You should then assign the result to the output `M`.\n\n", "output": "module bitwise_and_4bit (A, B, M);\n  input [3:0] A, B;\n  output [3:0] M;\n\n  assign M = A & B;\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that implements a D flip-flop with synchronous set and reset. The module should have the following inputs and outputs:\n\n- `D`: Data input\n- `C`: Clock input\n- `S`: Synchronous set input\n- `R`: Synchronous reset input\n- `Q`: Output\n\nThe module should behave as follows:\n\n- On the rising edge of the clock (`C`), if the reset input (`R`) is asserted, the output (`Q`) should be set to 0.\n- On the rising edge of the clock (`C`), if the set input (`S`) is asserted, the output (`Q`) should be set to 1.\n- On the rising edge of the clock (`C`), if neither the set nor the reset inputs are asserted, the output (`Q`) should be set to the value of the data input (`D`).\n\nYour task is to write a Verilog module that implements this behavior. Your module should be self-contained and should not rely on any external modules or libraries. Your module should be no more than 200 lines of Verilog code.\n\n", "output": "module DFFSR (output Q, input C, S, R, D);\n\n    reg Q;\n\n    always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end else if (S) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit comparator. The module should take in two 4-bit inputs and output a 2-bit result indicating whether the first input is greater than, less than, or equal to the second input.", "output": "module comparator (\n    input [3:0] in0,\n    input [3:0] in1,\n    output reg [1:0] result\n);\n\nalways @(*) begin\n    if (in0 > in1) begin\n        result = 2'b01; // in0 is greater than in1\n    end else if (in0 < in1) begin\n        result = 2'b10; // in0 is less than in1\n    end else begin\n        result = 2'b00; // in0 is equal to in1\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in a 2-bit input signal, `A`, and outputs a 2-bit signal, `Q`. The `Q` output should be the same as the `A` input, but with the bits swapped. For example, if `A` is `01`, then `Q` should be `10`. \n\nYour task is to create a Verilog module, `swap_bits`, that implements this functionality. The module should be self-contained and should not rely on any other modules or external libraries. Additionally, the module should be no more than 200 lines of Verilog code.\n\nPlease write the Verilog code for the `swap_bits` module that implements the functionality described above.\n\n", "output": "module swap_bits ( input [1:0] A, output [1:0] Q );\n\n    assign Q = { A[0], A[1] };\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that will perform a simple arithmetic operation on two input numbers. The module should have two input ports, A and B, each of which is 8 bits wide. The module should also have an output port, C, which is 16 bits wide. \n\nThe module should take the two input numbers, add them together, and output the result on port C. If the result of the addition is greater than 16 bits, the module should truncate the result to 16 bits by dropping the least significant bits. \n\nWrite a Verilog module that performs the above operation. \n\n", "output": "module arithmetic_module(\n    input [7:0] A,\n    input [7:0] B,\n    output reg [15:0] C\n);\n\n    always @ (A, B) begin\n        C = A + B;\n        if (C > 16'hFFFF) begin\n            C = C[15:0];\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module to implement a 2-input AND gate with an enable input. The module should have the following inputs and outputs:\n\n- `input a`: a single bit input\n- `input b`: a single bit input\n- `input enable`: a single bit input\n- `output out`: a single bit output\n\nThe output should be the result of the AND operation between `a` and `b`, but only when `enable` is high. If `enable` is low, the output should be 0.\n\nYour Verilog module should be named `and_enable` and should be contained within a single file that is no more than 200 lines long.\n\n", "output": "module and_enable (\n  input a,\n  input b,\n  input enable,\n  output out\n);\n\n  wire and_result;\n\n  and_gate and_inst (\n    .a(a),\n    .b(b),\n    .out(and_result)\n  );\n\n  assign out = enable ? and_result : 1'b0;\n\nendmodule\n\nmodule and_gate (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = a & b;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that can be used to interface with the sky130_fd_sc_ls__a21bo_2 module. The module should have three inputs and one output. The inputs are A, B, and C, and the output is X. The module should perform the following logic:\n\n- If A and B are both high, X should be high.\n- If A and C are both high, X should be high.\n- If B and C are both high, X should be high.\n- If none of the above conditions are met, X should be low.\n\nYour module should be named `interface_module` and should be written in Verilog. The module should be no more than 200 lines of code.\n\n", "output": "module interface_module (\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    wire AB;\n    wire AC;\n    wire BC;\n\n    and AB_and (AB, A, B);\n    and AC_and (AC, A, C);\n    and BC_and (BC, B, C);\n\n    or or_gate (X, AB, AC, BC);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that will perform a binary to Gray code conversion. The module should take in a binary input of n bits and output the corresponding Gray code. The input and output should be of the same width.\n\nGray code is a binary numeral system where two successive values differ in only one bit. For example, the binary representation of 3 is 011 and its corresponding Gray code is 010. The conversion from binary to Gray code is done by XORing the input with a right-shifted version of itself.\n\nYour task is to design a module that will take in a binary input and output its corresponding Gray code.\n\nThe module should have the following interface:\n\n```\nmodule binary_to_gray (\n    input  [n-1:0] binary_in,\n    output [n-1:0] gray_out\n);\n```\nwhere `n` is the number of bits in the input and output.\n\n", "output": "module binary_to_gray (\n    input  [n-1:0] binary_in,\n    output [n-1:0] gray_out\n);\n    assign gray_out = binary_in ^ ({1'b0, binary_in[n-1:1]});\nendmodule"}
{"instruction": "\nYou are tasked with designing a Verilog module that implements a 4-to-1 multiplexer. The module should have four data inputs, one output, and two control inputs. The control inputs should select which data input is routed to the output. The module should be named \"mux4to1\".\n\nThe module should have the following inputs and outputs:\n- Four data inputs, named \"data0\", \"data1\", \"data2\", and \"data3\"\n- Two control inputs, named \"sel0\" and \"sel1\"\n- One output, named \"out\"\n\nWhen \"sel0\" and \"sel1\" are both zero, \"data0\" should be routed to \"out\". When \"sel0\" is zero and \"sel1\" is one, \"data1\" should be routed to \"out\". When \"sel0\" is one and \"sel1\" is zero, \"data2\" should be routed to \"out\". When \"sel0\" and \"sel1\" are both one, \"data3\" should be routed to \"out\".\n\nYou should write a Verilog module that implements this functionality. Your module should be self-contained, and should not require any external modules or libraries. Your module should be no longer than 200 lines of code.\n\n", "output": "module mux4to1 (\n  input [7:0] data0,\n  input [7:0] data1,\n  input [7:0] data2,\n  input [7:0] data3,\n  input sel0,\n  input sel1,\n  output reg [7:0] out\n);\n\n  always @(*) begin\n    case ({sel1, sel0})\n      2'b00: out = data0;\n      2'b01: out = data1;\n      2'b10: out = data2;\n      2'b11: out = data3;\n    endcase\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Implement a 4-to-1 multiplexer with an enable input. When the enable input is low, the output should be 0. When the enable input is high, the output should be the selected data input. The data inputs and outputs are all 8 bits wide.", "output": "module mux_4to1_enable (\n  input [7:0] data0,\n  input [7:0] data1,\n  input [7:0] data2,\n  input [7:0] data3,\n  input enable,\n  input [1:0] sel,\n  output reg [7:0] out\n);\n\n  always @ (sel or enable or data0 or data1 or data2 or data3) begin\n    if (enable == 1'b0) begin\n      out <= 8'b0;\n    end else begin\n      case (sel)\n        2'b00: out <= data0;\n        2'b01: out <= data1;\n        2'b10: out <= data2;\n        2'b11: out <= data3;\n      endcase\n    end\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are hired by a company to design a verilog module for a 4:1 multiplexer. The module should have 4 inputs, one output, and a select input. The select input should determine which of the 4 inputs will be passed to the output. The select input should be a 2-bit input, and the output should be a single bit. The company requires that you use a case statement in your design.\n\nDesign a verilog module that meets the company's requirements. \n\n", "output": "module mux4to1 (in0, in1, in2, in3, sel, out);\ninput [3:0] in0, in1, in2, in3;\ninput [1:0] sel;\noutput out;\n\nreg out;\n\nalways @ (sel, in0, in1, in2, in3)\nbegin\n    case (sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a power-on reset generator. \nA power-on reset generator is a circuit that generates a reset signal when the power is turned on.\nYour module should have the following inputs and outputs:\n\nInputs: \n    - power: a signal indicating that power has been turned on\n    - clk: a clock signal\nOutputs: \n    - reset: a signal indicating that the system is in reset state\nThe module should also have the following parameters:\n\n    - rst_time: the length of time that the reset signal should be asserted after the power signal is received.\nYour module should implement the following functionality:\n    - When the power signal is received, the reset signal should be asserted for the length of time specified by the rst_time parameter.\n    - After the reset signal is de-asserted, it should not be asserted again unless the power signal is received again.\n    - The reset signal should be synchronized to the clock signal.\nTo implement the power-on reset generator, you should use Verilog code to define the behavior of the module based on the input signals and parameters. \nYou should then use this behavior to generate the reset signal and synchronize it to the clock signal.", "output": "module POR (\n  input power,\n  input clk,\n  output reset\n);\n\nparameter rst_time = 10; // length of time the reset signal should be asserted\n\nreg [31:0] rst_counter;\nreg reset_reg;\n\nalways @(posedge clk) begin\n  if (power) begin\n    rst_counter <= rst_counter + 1;\n    if (rst_counter >= rst_time) begin\n      reset_reg <= 1'b1;\n      rst_counter <= 0;\n    end\n  end else begin\n    reset_reg <= 1'b0;\n    rst_counter <= 0;\n  end\nend\n\nassign reset = reset_reg;\n\nendmodule"}
{"instruction": "\nYou have been hired by a company to design a 4-bit adder circuit using Verilog. The circuit should take two 4-bit input numbers and produce a 5-bit output, where the first bit represents the carry-out bit. The company has specified that the circuit should be designed using only one module within 200 lines of Verilog code.\n\nYou should design a module named \"four_bit_adder\" that takes the following inputs and outputs:\n\nInputs:\n- A (4-bit input)\n- B (4-bit input)\n- Cin (1-bit input)\n\nOutputs:\n- Sum (4-bit output)\n- Cout (1-bit output)\n\nThe module should perform the addition of A and B, and add the value of Cin to the result. The output should be the Sum of the addition and the Cout (carry-out) bit.\n\nYou should also ensure that your module follows the following guidelines:\n- The module should use only combinational logic.\n- The module should be synthesizable and meet timing requirements for a 50 MHz clock.\n- The module should be designed in such a way that it can be easily modified for adding more bits in the future.\n\n", "output": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] temp_sum;\n    wire [3:0] temp_carry;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[3:0];\n    assign Cout = temp_sum[4] | (temp_sum[3] & (temp_sum[2] | temp_sum[1] | temp_sum[0]));\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a register file. \nA register file is a type of digital circuit that contains a set of registers that can be read from or written to. \nThe inputs to the circuit are the read and write addresses, as well as the data to be written. \nThe outputs are the data read from the specified register.\n\nYour module should have the following inputs and outputs:\n\nInputs: \n- clk: a clock signal\n- wr_en: a write enable signal\n- rd_en: a read enable signal\n- addr1: the address of the first register to be read or written to\n- addr2: the address of the second register to be read or written to\n- data_in: the data to be written to the register specified by addr1\nOutputs: \n- data1: the data read from the register specified by addr1\n- data2: the data read from the register specified by addr2\n\nThe module should also have the following parameters:\n\n- n: the number of registers in the register file\n- w: the width of each register (in bits)\n\nYour module should implement the following functionality:\n\n- The register file should have n registers, each of which is w bits wide.\n- The circuit should be able to read from and write to any of the registers in the register file.\n- When the write enable signal is high, the data specified by data_in should be written to the register specified by addr1.\n- When the read enable signal is high, the data read from the register specified by addr1 should be output on the data1 port, and the data read from the register specified by addr2 should be output on the data2 port.\n- The circuit should only write to the register file on the rising edge of the clock signal.\n\nTo implement the register file, you should use Verilog code to define the registers and the read and write logic. \nYou should then use these components to connect the inputs and outputs as specified above.", "output": "module reg_file(\n  input clk,\n  input wr_en,\n  input rd_en,\n  input [log2(n)-1:0] addr1,\n  input [log2(n)-1:0] addr2,\n  input [w-1:0] data_in,\n  output [w-1:0] data1,\n  output [w-1:0] data2\n);\n\nparameter n = 8; // number of registers\nparameter w = 8; // width of each register\n\nreg [w-1:0] registers [0:n-1];\n\nalways @(posedge clk) begin\n  if (wr_en) begin\n    registers[addr1] <= data_in;\n  end\nend\n\nassign data1 = rd_en ? registers[addr1] : 0;\nassign data2 = rd_en ? registers[addr2] : 0;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that performs a bitwise OR operation between two input bits A and B. The module should have two input ports, A and B, each of which is a single bit. The module should also have one output port, P, which is the result of the bitwise OR operation between A and B. \n\nYour module should be named \"bitwise_or\" and should be contained within 200 lines of Verilog code. \n\nDesign the module such that it is synthesizable and can be implemented on an FPGA. \n\n", "output": "module bitwise_or(\n    input A,\n    input B,\n    output reg P\n);\n\n    always @ (A or B) begin\n        P = A | B;\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes two inputs A and B_N, and outputs X. The module should implement the logical OR operation between A and the negated B_N. The module should also have the following inputs and outputs:\n\n- VPWR: Positive power supply voltage\n- VGND: Ground voltage\n- VPB: Positive voltage for input signals\n- VNB: Negative voltage for input signals\n\nImplement the module using the following code snippet as a reference:\n\n```\nmodule sky130_fd_sc_lp__or2b_2 (\n    X   ,\n    A   ,\n    B_N ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A   ;\n    input  B_N ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_lp__or2b base (\n        .X(X),\n        .A(A),\n        .B_N(B_N),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n```\n\nYour task is to complete the module by implementing the logical OR operation between A and the negated B_N. Ensure that the module meets the following requirements:\n\n- The module should be synthesizable\n- The module should be technology independent\n- The module should be able to handle different voltage levels for VPWR, VGND, VPB, and VNB\n\n", "output": "module or2 (\n    output X,\n    input A,\n    input B_N\n);\n\n    assign X = A | ~B_N;\n\nendmodule\n\nmodule sky130_fd_sc_lp__or2b_2 (\n    X   ,\n    A   ,\n    B_N ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A   ;\n    input  B_N ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    wire X_internal;\n    \n    or2 or2_inst (\n        .X(X_internal),\n        .A(A),\n        .B_N(B_N)\n    );\n    \n    assign X = X_internal;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module to control the speed of a motor. The module should take in a clock signal, a direction signal, and a speed signal, and output a PWM signal to control the motor. The speed signal is a 4-bit value ranging from 0 to 15, where 0 corresponds to a stopped motor and 15 corresponds to maximum speed. The direction signal is a single bit, where 0 corresponds to clockwise rotation and 1 corresponds to counterclockwise rotation. The PWM signal should have a frequency of 10 kHz and a duty cycle corresponding to the speed signal. \n\nDesign a Verilog module that takes in the clock, direction, and speed signals and outputs the PWM signal to control the motor. The module should be named \"motor_control\" and have the following ports:\n\n- input clk: the clock signal with a frequency of 50 MHz\n- input direction: the direction signal\n- input [3:0] speed: the speed signal\n- output pwm: the PWM signal to control the motor\n\nAssume that the motor is already connected to the output signal \"pwm\". \n\n", "output": "module motor_control(\n    input clk,\n    input direction,\n    input [3:0] speed,\n    output pwm\n);\n\n    reg [15:0] counter;\n    reg pwm_out;\n\n    always @(posedge clk) begin\n        if (counter == 16'd999) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n        \n        if (counter < speed) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n    \n    assign pwm = (direction == 1'b0) ? pwm_out : ~pwm_out;\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a Verilog module that implements a 4-bit binary to gray code converter. In this module, there are two input ports (in1 and in0) and one output port (out). The input ports represent the binary number in 2's complement representation, and the output port represents the gray code of the input number. The module should use combinational logic to convert the binary input to gray code output. \nHint: The gray code of a binary number can be obtained by XORing the most significant bit (MSB) with the second most significant bit, then XORing the result with the third most significant bit, and so on.", "output": "module binary_to_gray (\n  input [1:0] in,\n  output [1:0] out\n);\n\n  assign out[1] = in[1] ^ in[0];\n  assign out[0] = in[1];\n\nendmodule\n"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 4-bit barrel shifter. The module should have two inputs, a 4-bit data input (data_in) and a 2-bit shift input (shift). The module should output the shifted data (data_out) based on the shift input. If shift=00, data_out should be the same as data_in. If shift=01, data_out should be data_in shifted left by one bit. If shift=10, data_out should be data_in shifted right by one bit. If shift=11, data_out should be data_in shifted right by two bits.", "output": "module barrel_shifter (\n    input [3:0] data_in,\n    input [1:0] shift,\n    output [3:0] data_out\n);\n\n    assign data_out = (shift == 2'b00) ? data_in :\n                      (shift == 2'b01) ? {data_in[2:0], 1'b0} :\n                      (shift == 2'b10) ? {1'b0, data_in[3:1]} :\n                      {2'b00, data_in[3:2]};\n                      \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4-bit binary to Gray code converter. The module should have a 4-bit binary input (B) and a 4-bit Gray code output (G). The Gray code output should be generated based on the following rules:\n- The most significant bit (MSB) of the Gray code output should be the same as the MSB of the binary input.\n- Each subsequent bit of the Gray code output should be the XOR of the corresponding bit of the binary input and the previous bit of the Gray code output.\n\nDesign the module and write the verilog code for it. \n\n", "output": "module bin2gray(input [3:0] B, output reg [3:0] G);\n\nalways @ (B) begin\n    G[3] = B[3];\n    G[2] = B[3] ^ B[2];\n    G[1] = B[2] ^ B[1];\n    G[0] = B[1] ^ B[0];\nend\n\nendmodule"}
{"instruction": "\nYou have been tasked with designing a new module in Verilog that will take in five input signals and output a single signal. The module should be named `my_module` and the output signal should be named `out_signal`. The five input signals should be named `in_signal_1`, `in_signal_2`, `in_signal_3`, `in_signal_4`, and `in_signal_5`. \n\nThe `out_signal` should be equal to the bitwise AND operation of all five input signals. Additionally, the module should include voltage supply signals `VPWR`, `VGND`, `VPB`, and `VNB`. \n\nWrite a Verilog module that meets the above requirements. Your module should be self-contained and should not rely on any external modules or libraries. Your module should be no longer than 200 lines of code.\n\n", "output": "module my_module (\n    out_signal,\n    in_signal_1,\n    in_signal_2,\n    in_signal_3,\n    in_signal_4,\n    in_signal_5\n);\n\n    output out_signal;\n    input  in_signal_1;\n    input  in_signal_2;\n    input  in_signal_3;\n    input  in_signal_4;\n    input  in_signal_5;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign out_signal = in_signal_1 & in_signal_2 & in_signal_3 & in_signal_4 & in_signal_5;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that takes in a clock signal, a single-bit data input, and a reset signal, and outputs the data input after it has been passed through a level-sensitive latch. The module should be named `latch_module` and should have the following ports:\n\n- `clk`: a 1-bit input representing the clock signal\n- `din`: a 1-bit input representing the data input\n- `dout`: a 1-bit output representing the data output\n- `reset_n`: a 1-bit input representing the active-low reset signal\n\nThe level-sensitive latch should be implemented using a D flip-flop, and the output of the flip-flop should be connected to the `dout` output port. The module should be designed to be synthesizable and should not use any non-synthesizable constructs.\n\nWrite a Verilog module named `latch_module` that satisfies the above requirements and is no longer than 200 lines.\n\n", "output": "module latch_module(\n    input clk,\n    input din,\n    input reset_n,\n    output dout\n);\n\n    reg dff_input;\n    wire dff_output;\n\n    always @ (posedge clk or negedge reset_n) begin\n        if (~reset_n) begin\n            dff_input <= 1'b0;\n        end else begin\n            dff_input <= din;\n        end\n    end\n\n    assign dout = dff_output;\n\n    usb_system_clocks_dffpipe_l2c dff_inst(\n        .clock(clk),\n        .clrn(reset_n),\n        .d(dff_input),\n        .q(dff_output)\n    );\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module for a digital circuit that implements a logical buffer with high-voltage level shifting. The module should have one input, A, and one output, X. The circuit should work with a voltage supply of 1V for VPWR and 0V for VGND. Additionally, the module should be able to handle high voltage levels, which are supplied through LOWHVPWR, VPB, and VNB. \n\nYour task is to implement the module sky130_fd_sc_hvl__lsbufhv2hv_lh, which should satisfy the following requirements:\n1. The module should have the correct input and output ports, as defined in the code snippet.\n2. The module should be able to handle high voltage levels, as defined in the code snippet.\n3. The module should implement a logical buffer, which means that the output X should be the same as the input A.\n4. The module should implement high-voltage level shifting, which means that the output X should be shifted to the high voltage level.\n\nWrite the code for the module sky130_fd_sc_hvl__lsbufhv2hv_lh that satisfies the above requirements.\n\n", "output": "module sky130_fd_sc_hvl__lsbufhv2hv_lh (\n    X,\n    A\n);\n\n    output X;\n    input  A;\n\n    // Voltage supply signals\n    supply1 VPWR    ;\n    supply0 VGND    ;\n    supply1 LOWHVPWR;\n    supply1 VPB     ;\n    supply0 VNB     ;\n\n    assign X = A ? VPB : VNB;\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module, `sky130_fd_sc_hd__and4bb`, that implements a 4-input AND gate using a NOR gate and an AND gate. The module has five input/output ports and four power/ground ports. Your task is to implement a 4-input AND gate using only NAND gates. \n\nYou should create a new Verilog module, `my_and4`, that implements the 4-input AND gate using only NAND gates. Your module should have the same input/output ports as `sky130_fd_sc_hd__and4bb`: `X` (output) and `A_N`, `B_N`, `C`, and `D` (inputs). Your module should also have the same power/ground ports as `sky130_fd_sc_hd__and4bb`: `VPWR`, `VGND`, `VPB`, and `VNB`.\n\nYour module should be self-contained and should not rely on any other modules or external libraries. Your module should be no longer than 200 lines of Verilog code.\n\n", "output": "module my_and4 (\n    X  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    // Module ports\n    output X  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire nand0_out;\n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n\n    // Implement 4-input AND gate using only NAND gates\n    nand nand0 (nand0_out, A_N, B_N);\n    nand nand1 (nand1_out, C, D);\n    nand nand2 (nand2_out, nand0_out, nand1_out);\n    nand nand3 (X, nand2_out, nand2_out);\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Develop a module that implements a 4-bit parity generator. The module should have a 4-bit input and a single output representing the parity bit. The parity bit should be 1 if the number of 1's in the input is odd, and 0 otherwise.", "output": "module parity_generator (\n    input [3:0] in,\n    output parity\n);\n\nassign parity = ^in;\n\nendmodule"}
{"instruction": "\n\nIn this problem, you are given a Verilog module called `register16`. This module is a 16-bit register that can store an input value and output it on the next clock cycle. The module has four inputs: `clk` (the clock signal), `in` (the input value to be stored), `write` (a control signal that determines whether the input value should be stored), and `reset` (a control signal that resets the register to 0). The module has one output: `out` (the output value of the register).\n\nYour task is to create a new Verilog module called `register16_with_enable` that is similar to `register16`, but with an additional control input called `enable`. When `enable` is 1, the register should behave exactly like `register16`, storing the input value on the next clock cycle if `write` is also 1. However, when `enable` is 0, the register should not store any new input values, and instead should simply output the current stored value on every clock cycle.\n\nWrite a Verilog module `register16_with_enable` that takes in the same inputs as `register16`, plus an additional input `enable`, and produces the same output as `register16`.\n\n", "output": "module register16_with_enable(\n    input clk,\n    input [15:0] in,\n    input write,\n    input reset,\n    input enable,\n    output reg [15:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 16'b0;\n        end else if (enable) begin\n            if (write) begin\n                out <= in;\n            end\n        end\n    end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Design a module that implements a 4-bit ripple carry adder. The module should have two inputs, A and B, each representing a 4-bit binary number. The module should have two outputs: S (sum) and C (carry-out). S should represent the 4-bit sum of A and B, and C should represent the carry-out bit. Hint: Use a for loop to implement the ripple carry adder.", "output": "module ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] S,\n    output reg C\n);\n\nreg carry;\n\nalways @* begin\n    S[0] = A[0] ^ B[0] ^ carry;\n    carry = (A[0] & B[0]) | (A[0] & carry) | (B[0] & carry);\n    S[1] = A[1] ^ B[1] ^ carry;\n    carry = (A[1] & B[1]) | (A[1] & carry) | (B[1] & carry);\n    S[2] = A[2] ^ B[2] ^ carry;\n    carry = (A[2] & B[2]) | (A[2] & carry) | (B[2] & carry);\n    S[3] = A[3] ^ B[3] ^ carry;\n    C = carry;\nend\n\nendmodule\n"}
{"instruction": "\nYou are tasked with designing a Verilog module for a simple calculator that can handle addition, subtraction, multiplication, and division of two 16-bit signed integers. The module should have two inputs for the operands and one input for selecting the operation to be performed. The output should be the result of the selected operation.\n\nThe module should have the following interface:\n- `input [15:0] operand_a`: the first operand\n- `input [15:0] operand_b`: the second operand\n- `input [1:0] operation`: a 2-bit input that selects the operation to be performed:\n  - `2'b00`: addition\n  - `2'b01`: subtraction (operand_a - operand_b)\n  - `2'b10`: multiplication\n  - `2'b11`: division (operand_a / operand_b)\n- `output reg [15:0] result`: the result of the selected operation\n\nAssume that the inputs will always be valid and that the division operation will not result in a divide-by-zero error.\n\n", "output": "module simple_calculator(\n    input [15:0] operand_a,\n    input [15:0] operand_b,\n    input [1:0] operation,\n    output reg [15:0] result\n);\n\nalways @* begin\n    case(operation)\n        2'b00: result = operand_a + operand_b; // addition\n        2'b01: result = operand_a - operand_b; // subtraction\n        2'b10: result = operand_a * operand_b; // multiplication\n        2'b11: result = operand_a / operand_b; // division\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with creating a verilog module that takes in two input signals, `a` and `b`, and an enable signal `en`. The module should output the result of `a` XOR `b` if `en` is high, and the value of `a` if `en` is low`. \n\nCreate a verilog module with the following specifications:\n\n- Module name: `xor_en`\n- Inputs:\n  - `a` (1-bit)\n  - `b` (1-bit)\n  - `en` (1-bit)\n- Outputs:\n  - `out` (1-bit)\n\nYour solution should implement the functionality described above and should be synthesizable.\n\n", "output": "module xor_en(\n    input a,\n    input b,\n    input en,\n    output out\n);\n\nwire a_xor_b;\nassign a_xor_b = a ^ b;\n\nassign out = en ? a_xor_b : a;\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module that takes in 9 inputs and produces 1 output. The module should be named `multi_input_module` and should have the following input and output ports:\n\n- `input a, b, c, d, e, f, g, h, i`\n- `output out`\n\nThe module should perform the following operations:\n\n1. If `a` and `b` are both high (`1`), set `out` to `1`. Otherwise, set `out` to `0`.\n2. If `c` or `d` are high (`1`), set `out` to `1`. Otherwise, leave `out` as is.\n3. If `e` and `f` are both low (`0`), set `out` to `0`. Otherwise, leave `out` as is.\n4. If `g` is high (`1`), set `out` to `1`. Otherwise, leave `out` as is.\n5. If `h` is low (`0`), set `out` to `0`. Otherwise, leave `out` as is.\n6. If `i` is high (`1`), set `out` to `1`. Otherwise, leave `out` as is.\n\nDesign and implement the `multi_input_module` module using Verilog.\n\n", "output": "module multi_input_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    input f,\n    input g,\n    input h,\n    input i,\n    output out\n);\n\n    wire ab_high;\n    wire cd_high;\n    wire ef_low;\n    wire g_high;\n    wire h_low;\n    wire i_high;\n\n    assign ab_high = a & b;\n    assign cd_high = c | d;\n    assign ef_low = ~(e | f);\n    assign g_high = g;\n    assign h_low = ~h;\n    assign i_high = i;\n\n    assign out = ab_high | cd_high | ef_low | g_high | h_low | i_high;\n\nendmodule"}
{"instruction": "\n\nIn this problem, you are tasked with creating a module that implements a simple counter. The counter should be able to count up or down, and the direction should be controlled by an input signal. The counter should have a maximum value of 255 and a minimum value of 0. When the counter reaches its maximum or minimum value, it should wrap around to the other end of the range.\n\nThe module should have the following inputs and outputs:\n\n- `clk`: a clock signal\n- `rst`: a reset signal (active high)\n- `up_down`: a control signal that determines the direction of the counter. If `up_down` is high, the counter should count up. If `up_down` is low, the counter should count down.\n- `out`: the current value of the counter\n\nYour module should be self-contained and should not rely on any external modules or packages. You may use any Verilog constructs or operators that you deem necessary.\n\nYour module should not exceed 200 lines of Verilog code.\n\n", "output": "module counter(\n  input clk,\n  input rst,\n  input up_down,\n  output reg [7:0] out\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      out <= 8'd0;\n    end else begin\n      if (up_down) begin\n        if (out == 8'd255) begin\n          out <= 8'd0;\n        end else begin\n          out <= out + 1;\n        end\n      end else begin\n        if (out == 8'd0) begin\n          out <= 8'd255;\n        end else begin\n          out <= out - 1;\n        end\n      end\n    end\n  end\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a 4-to-1 multiplexer using Verilog. Write a module called `MUX4X1` that has four inputs, `A`, `B`, `C`, and `D`, and two inputs, `S0` and `S1`. The output of the multiplexer should be `Z`. The multiplexer should follow the truth table below:\n\n| S1 | S0 | Z  |\n|----|----|----|\n| 0  | 0  | A  |\n| 0  | 1  | B  |\n| 1  | 0  | C  |\n| 1  | 1  | D  |\n\nYour module should have the following interface:\n```\nmodule MUX4X1 (A, B, C, D, S0, S1, Z);\ninput  A ;\ninput  B ;\ninput  C ;\ninput  D ;\ninput  S0 ;\ninput  S1 ;\noutput Z ;\n```\nYou can use any combinational logic gates and Verilog constructs to implement the multiplexer. Ensure that your implementation follows the truth table above.\n\n", "output": "module MUX4X1 (A, B, C, D, S0, S1, Z);\ninput  A ;\ninput  B ;\ninput  C ;\ninput  D ;\ninput  S0 ;\ninput  S1 ;\noutput Z ;\n\nwire  notS0, notS1, and1, and2, and3, and4;\n\nnot (notS0, S0);\nnot (notS1, S1);\n\nand (and1, A, notS1, notS0);\nand (and2, B, notS1, S0);\nand (and3, C, S1, notS0);\nand (and4, D, S1, S0);\n\nor (Z, and1, and2, and3, and4);\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a verilog module for a 4:1 multiplexer with an enable signal. The module should have the following ports:\n\n- `input [3:0] data_in`: a 4-bit input bus\n- `input [1:0] select`: a 2-bit select bus\n- `input enable`: an enable signal\n- `output reg [3:0] data_out`: a 4-bit output bus\n\nThe module should select the input data based on the select signal when the enable signal is high. When the enable signal is low, the output should hold its previous value.\n\nWrite the verilog code for this module.\n\n", "output": "module mux4to1_enable(\n    input [3:0] data_in,\n    input [1:0] select,\n    input enable,\n    output reg [3:0] data_out\n);\n\nalways @(*) begin\n    case (select)\n        2'b00: data_out = enable ? data_in[0] : data_out;\n        2'b01: data_out = enable ? data_in[1] : data_out;\n        2'b10: data_out = enable ? data_in[2] : data_out;\n        2'b11: data_out = enable ? data_in[3] : data_out;\n    endcase\nend\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit register with a single clock input and asynchronous reset input. The register should be able to store a 4-bit input value on the rising edge of the clock signal and output the stored value on its output whenever the clock signal is high. Additionally, the register should be able to reset to a default value of 0 when the asynchronous reset input is asserted.\n\nTo implement this register, you will use a D flip-flop (DFF) and a few logic gates. The DFF should be instantiated within the module and connected to the clock signal, reset signal, and input and output ports of the module. You should also use logic gates to implement the reset functionality.\n\nYour module should be named \"four_bit_register\" and should have the following ports:\n\n- clk (input): the clock signal\n- rst (input): the asynchronous reset signal\n- din (input): the 4-bit input value to be stored in the register\n- dout (output): the 4-bit value stored in the register, to be output on the rising edge of the clock signal\n\nYour module should be designed to be synthesizable and should not use any non-synthesizable constructs.\n\n", "output": "module four_bit_register (input clk, input rst, input [3:0] din, output reg [3:0] dout);\n  reg [3:0] reg_out;\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      reg_out <= 4'b0;\n    end else begin\n      reg_out <= din;\n    end\n  end\n  assign dout = reg_out;\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-input AND gate with an additional inverter. The module should have the following inputs and outputs:\n\nInputs:\n- A1: 1-bit input\n- A2: 1-bit input\n- B1: 1-bit input\n- C1: 1-bit input\n\nOutputs:\n- X: 1-bit output\n\nIn addition, the module should have the following inputs and outputs for power and ground connections:\n- VPWR: 1-bit input for power connection\n- VGND: 1-bit input for ground connection\n\nThe module should be named \"and_inv\" and should be contained in a file named \"and_inv.v\".\n\nYour task is to write the Verilog code for the \"and_inv\" module that implements the 4-input AND gate with an additional inverter, using only one module within 200 lines of code.\n\n", "output": "module and_inv (\n    X,\n    A1,\n    A2,\n    B1,\n    C1,\n    VPWR,\n    VGND\n);\n\n    output X;\n    input A1;\n    input A2;\n    input B1;\n    input C1;\n    input VPWR;\n    input VGND;\n\n    wire w1, w2, w3, w4, w5;\n\n    and gate1(w1, A1, A2);\n    and gate2(w2, B1, C1);\n    and gate3(w3, w1, w2);\n    not inv1(w4, w3);\n    and gate4(w5, w4, VPWR);\n\n    assign X = w5;\n\nendmodule\n\nmodule and (\n    output out,\n    input in1,\n    input in2,\n    input in3,\n    input in4\n);\n\n    assign out = in1 & in2 & in3 & in4;\n\nendmodule\n\nmodule not (\n    output out,\n    input in\n);\n\n    assign out = ~in;\n\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Create a module that implements a 4-bit shift register with parallel load and serial output. The module should have two inputs, a 4-bit data input and a shift input. If the shift input is high, the module should shift the contents of the shift register right by one position, with the least significant bit being shifted out as the serial output. If the shift input is low, the module should load the contents of the shift register with the data input.", "output": "module shift_reg (\n    input [3:0] data,\n    input shift,\n    output reg serial_out,\n    output reg [3:0] q\n);\n\n    always @ (posedge shift) begin\n        if (shift) begin\n            q[0] <= q[1];\n            q[1] <= q[2];\n            q[2] <= q[3];\n            q[3] <= data;\n            serial_out <= q[0];\n        end\n        else begin\n            q <= data;\n            serial_out <= q[0];\n        end\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a module that checks for X values in a given input data stream. The module should be named \"xChecker\" and have the following inputs and outputs:\n\nInputs:\n- `i_clk`: The clock signal\n- `i_reset`: The reset signal\n- `i_data`: The input data stream\n\nOutputs:\n- `o_error`: A flag that is set to 1 if an X value is detected in the input data stream\n\nThe xChecker module should have the following behavior:\n- On the rising edge of the clock signal, the module checks the input data stream for any X values.\n- If an X value is detected, the module sets the `o_error` flag to 1.\n- The `o_error` flag should remain high until the reset signal is asserted.\n\nYou should implement the xChecker module using Verilog and ensure that it is solvable by only one module within 200 lines of code.\n\n", "output": "module xChecker (\n  input i_clk,\n  input i_reset,\n  input [31:0] i_data,\n  output reg o_error\n);\n\nreg [31:0] prev_data;\n\nalways @(posedge i_clk) begin\n  // Reset error flag\n  o_error <= 0;\n\n  // Check for X values\n  if (i_data === 32'hxxxxxxxx) begin\n    o_error <= 1;\n  end\n\n  // Store previous data\n  prev_data <= i_data;\nend\n\n// Reset error flag on reset signal\nalways @(posedge i_clk) begin\n  if (i_reset) begin\n    o_error <= 0;\n  end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been given the task of designing a verilog module for a 4-bit adder with carry-in and carry-out. The module should have the following inputs and outputs:\n- A: a 4-bit input\n- B: a 4-bit input\n- Cin: a single bit input for carry-in\n- Sum: a 4-bit output for the sum of A and B\n- Cout: a single bit output for carry-out\n\nYou should create a verilog module that implements the 4-bit adder with carry-in and carry-out. You can assume that the inputs A and B are valid and do not need to be checked for correctness. The output Sum should be the 4-bit sum of A and B, and Cout should be the carry-out bit.\n\n", "output": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] temp;\n    wire carry;\n\n    assign temp = A + B + Cin;\n    assign Sum = temp[3:0];\n    assign Cout = temp[4];\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a verilog module that implements a 2-to-1 multiplexer using behavioral modeling. The module should have the following ports:\n\n- `input a` (1-bit): the first input to the multiplexer\n- `input b` (1-bit): the second input to the multiplexer\n- `input sel` (1-bit): the select signal that chooses between `a` and `b`. If `sel` is 0, `a` is selected; if `sel` is 1, `b` is selected.\n- `output out` (1-bit): the output of the multiplexer, which is equal to `a` if `sel` is 0, and `b` if `sel` is 1.\n\nImplement the module using behavioral modeling, and ensure that it synthesizes correctly.\n\n", "output": "module mux2to1_behav (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"instruction": "Design a module that implements a 3-bit shift register using only combinational logic. The module should take a clock input, a data input, and provide a 3-bit output. The output should be the shifted version of the input data, with the most significant bit being the output of the first flip-flop. The module should not use any D flip-flops or any other sequential elements.", "output": "module shift_register ( input clk, input d, output [2:0] q );\n    wire [2:0] q_temp;\n    \n    assign q_temp[0] = d;\n    assign q_temp[1] = q[0];\n    assign q_temp[2] = q[1];\n    \n    assign q = q_temp;\nendmodule"}
{"instruction": "Please act as a professional verilog designer. Design a module that implements a 3-bit gray code counter. The module should have a synchronous reset input and one output (count). The counter should count in gray code sequence on every positive edge of the clock. When reset is high, the counter should be reset to zero.", "output": "module gray_code_counter (\n    input clk,\n    input reset,\n    output reg [2:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'b000;\n        end\n        else begin\n            count <= count ^ (count >> 1);\n        end\n    end\n\nendmodule"}
{"instruction": "\n\nYou are tasked with designing a module in Verilog that implements a 4-bit synchronous counter. The counter should have three inputs: a clock signal (`CLK`), a reset signal (`RST`), and an enable signal (`EN`). When `EN` is high, the counter should increment on every rising edge of `CLK`. When `RST` is high, the counter should reset to 0. The counter should output a 4-bit value (`Q`) representing the current count.\n\nYour module should be named `sync_counter` and should be designed such that it can be easily integrated into larger Verilog designs. Your implementation should be contained within 200 lines of code.\n\n", "output": "module sync_counter (\n    input CLK,\n    input RST,\n    input EN,\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        Q <= 4'b0000;\n    end else if (EN) begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module for a digital circuit. The module should have one output, X, and seven inputs: A1, A2, B1, VPWR, VGND, VPB, and VNB. The module should be named sky130_fd_sc_lp__o21a.\n\nThe module should be designed to meet the following requirements:\n\n1. When A1 is high, X should be high.\n2. When A1 is low and A2 is high, X should be high.\n3. When A1 and A2 are both low and B1 is high, X should be high.\n4. When none of the above conditions are met, X should be low.\n\nIn addition to meeting the above requirements, the module should also be designed to operate with the following voltages:\n\n1. VPWR: 3.3V\n2. VGND: 0V\n3. VPB: 1.8V\n4. VNB: -1.8V\n\nYou should write a verilog module that meets these requirements. Your module should be no more than 200 lines of code.\n\n", "output": "module sky130_fd_sc_lp__o21a (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    wire a1_high, a1_low_a2_high, a1_a2_low_b1_high;\n    \n    assign a1_high = (A1 == 1'b1);\n    assign a1_low_a2_high = (A1 == 1'b0) && (A2 == 1'b1);\n    assign a1_a2_low_b1_high = (A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1);\n    \n    assign X = a1_high || a1_low_a2_high || a1_a2_low_b1_high;\n    \nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a Verilog module that takes in 10 inputs and produces a single output. The module should be named `my_module` and should have the following input and output ports:\n\n- `input [2:0] A`\n- `input [1:0] B`\n- `input C`\n- `input D`\n- `input E`\n- `input F`\n- `input G`\n- `input H`\n- `input I`\n- `output J`\n\nThe module should implement the following behavior:\n\n- If `A` is equal to `3'b111` (binary `111`), set the output `J` to `1`.\n- If `A` is equal to `3'b000` (binary `000`), set the output `J` to `0`.\n- If `A` is equal to any other value, set the output `J` to `1` if and only if the following conditions are met:\n  - `B` is equal to `2'b00` (binary `00`).\n  - `C` is equal to `1'b1` (binary `1`).\n  - `D` is equal to `1'b0` (binary `0`).\n  - `E` is equal to `1'b1` (binary `1`).\n  - `F` is equal to `1'b0` (binary `0`).\n  - `G` is equal to `1'b1` (binary `1`).\n  - `H` is equal to `1'b0` (binary `0`).\n  - `I` is equal to `1'b1` (binary `1`).\n\nWrite a Verilog module that implements this behavior. The module should be contained within 200 lines of code.\n\n", "output": "module my_module(\n    input [2:0] A,\n    input [1:0] B,\n    input C,\n    input D,\n    input E,\n    input F,\n    input G,\n    input H,\n    input I,\n    output J\n);\n\n    wire is_111 = (A == 3'b111);\n    wire is_000 = (A == 3'b000);\n    wire is_other = !is_111 && !is_000;\n\n    assign J = (is_111) ? 1 :\n               (is_000) ? 0 :\n               ((B == 2'b00) && (C == 1'b1) && (D == 1'b0) && (E == 1'b1) && (F == 1'b0) && (G == 1'b1) && (H == 1'b0) && (I == 1'b1)) ? 1 :\n               0;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in a 5-bit input signal, performs some operations on it, and outputs a 5-bit signal. The module should be written in Verilog and should not exceed 200 lines of code. \n\nThe module should have the following inputs: \n- `clk`: a clock signal\n- `reset`: a reset signal\n- `input_signal`: a 5-bit input signal\n\nThe module should have the following outputs: \n- `output_signal`: a 5-bit output signal\n\nThe module should perform the following operations on the `input_signal`: \n- If the `input_signal` is even, add 1 to it.\n- If the `input_signal` is odd, subtract 1 from it.\n- If the `input_signal` is 0, output 0.\n\n", "output": "module five_bit_module(\n    input clk,\n    input reset,\n    input [4:0] input_signal,\n    output reg [4:0] output_signal\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        output_signal <= 0;\n    end else begin\n        if (input_signal == 0) begin\n            output_signal <= 0;\n        end else if (input_signal % 2 == 0) begin\n            output_signal <= input_signal + 1;\n        end else begin\n            output_signal <= input_signal - 1;\n        end\n    end\nend\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Your task is to create a Verilog module that implements a watchdog timer (WDT). \nA WDT is a timer circuit that is used to detect and recover from software or hardware malfunctions. \nThe WDT is a counter that is periodically reset by the software. If the software fails to reset the counter within a certain time period, the WDT triggers a system reset or other corrective action.\nYour module should have the following inputs and outputs:\n\nInputs: a clock signal (clk) and a reset signal (rst)\nOutputs: a watchdog timer output signal (wdt)\nThe module should also have the following parameters:\n\nt: the time period for the watchdog timer\nYour module should implement the following functionality:\n\nThe WDT should be a counter that counts up on each clock cycle.\nThe WDT should be reset to zero by the software by setting the rst input to '1'.\nIf the WDT reaches the timeout period of t, the wdt output signal should go high.\nIf the software fails to reset the WDT within the timeout period t, the wdt output signal should stay high and trigger a system reset or other corrective action.\nTo implement the WDT, you should use Verilog code to define a counter that counts up on each clock cycle. \nYou should then use the rst input to reset the counter to zero. \nFinally, you should compare the counter value to the timeout period t to determine whether the wdt output signal should go high or stay low and trigger a system reset.", "output": "module WDT (\n  input clk, rst,\n  output wdt\n);\n\n  parameter t = 10; // timeout period in clock cycles\n  \n  reg [31:0] counter;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      counter <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n    end\n  end\n  \n  assign wdt = (counter >= t) ? 1'b1 : 1'b0;\n  \nendmodule"}
{"instruction": "\n\nYou are tasked with designing a Verilog module that implements a 4-bit shift register with a parallel load function. The shift register should have four inputs and one output. The inputs are:\n- `clk`: a clock input\n- `reset`: a reset input\n- `load`: a parallel load input\n- `data_in`: a 4-bit input\n\nThe output is:\n- `data_out`: a 4-bit output\n\nWhen `reset` is high, the shift register should be cleared. When `load` is high, the value of `data_in` should be loaded into the shift register. When `load` is low, the shift register should shift its contents to the left on every rising edge of `clk`. The most significant bit should be shifted out and lost, and the least significant bit should be shifted in from `data_in`.\n\nYour module should be named `shift_register` and should be implemented within 200 lines of Verilog code.\n\n", "output": "module shift_register (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 4'b0;\n    end else if (load) begin\n        shift_reg <= data_in;\n    end else begin\n        shift_reg <= {shift_reg[2:0], data_in};\n    end\nend\n\nassign data_out = shift_reg;\n\nendmodule"}
{"instruction": "\n\nYou have been tasked with designing a module that takes in three signed 23-bit inputs, `a`, `b`, and `c`. Your goal is to create a module that checks if the sum of `a` and `b` is equal to `c`. If the sum is not equal to `c`, the module should output an error message and terminate the simulation.\n\nDesign a Verilog module that implements the above functionality, and name it `check`. \n\nYou should use the following inputs and outputs:\n- Inputs: \n    - `a`: a signed 23-bit input\n    - `b`: a signed 23-bit input\n    - `c`: a signed 23-bit input\n\n- Outputs: None\n\nYour module should contain the following:\n- A wire named `int_AB` that is the sum of `a` and `b`.\n- A combinational always block that checks if `int_AB` is equal to `c`. If `int_AB` is not equal to `c`, the module should output an error message using the `$display` function and terminate the simulation using the `$finish` function.\n\nYou should assume that the inputs are valid signed 23-bit numbers.\n\n", "output": "module check (input signed [22:0] a, b, c);\n\n  wire signed [22:0] int_AB;\n\n  assign int_AB = a + b;\n\n  always @(*) begin\n    if (int_AB !== c) begin\n      $display(\"ERROR\");\n      $finish;\n    end\n  end\n\nendmodule"}
{"instruction": "Please act as a professional Verilog designer. Create a module that implements a 4-to-1 multiplexer using behavioral modeling. The module should have four input ports (A, B, C, D), two select lines (sel0 and sel1), and one output port (Y). The select lines are used to select one of the four input signals to be output on the Y port. The module should be declared with the keyword \"module\" followed by the name of the module (\"mux4to1\") and the list of ports (inputs and outputs). Inside the module body, you should use an if-else statement to implement the multiplexer logic. When sel0 and sel1 are both 0, the output Y should be equal to input A. When sel0 is 0 and sel1 is 1, the output Y should be equal to input B. When sel0 is 1 and sel1 is 0, the output Y should be equal to input C. When sel0 and sel1 are both 1, the output Y should be equal to input D.", "output": "module mux4to1 (\n  input A,\n  input B,\n  input C,\n  input D,\n  input sel0,\n  input sel1,\n  output reg Y\n);\n\n  always @(*)\n  begin\n    if(sel0 == 0 && sel1 == 0)\n      Y = A;\n    else if(sel0 == 0 && sel1 == 1)\n      Y = B;\n    else if(sel0 == 1 && sel1 == 0)\n      Y = C;\n    else if(sel0 == 1 && sel1 == 1)\n      Y = D;\n  end\n\nendmodule\n"}
{"instruction": "\n\nYou are tasked with creating a module that implements a simple 16-bit Arithmetic Logic Unit (ALU) in Verilog. The module should take in three 16-bit inputs: A, B, and C. Additionally, it should take in a 2-bit input op that determines the operation to be performed on the inputs. The module should output a 16-bit value, Z, which is the result of the operation.\n\nThe following table shows the possible values of op and their corresponding operations:\n\n| op | Operation |\n|----|-----------|\n| 00 | A + B     |\n| 01 | A - B     |\n| 10 | A & B     |\n| 11 | A \\| B     |\n\nYou are required to implement the module using only combinational logic, without using any sequential elements.\n\nYour task is to implement the Verilog module alu_16 to perform the above operations.\n\n", "output": "module alu_16(output reg [15:0] Z, input [1:0] op, input [15:0] A, B, C);\n\n    always @(*) begin\n        case (op)\n            2'b00: Z = A + B;\n            2'b01: Z = A - B;\n            2'b10: Z = A & B;\n            2'b11: Z = A | B;\n        endcase\n    end\n\nendmodule"}
{"instruction": "\nYou are tasked with designing a verilog module that can perform a simple mathematical operation on two input numbers. The module should have two input ports, \"a\" and \"b\", and one output port, \"result\". The module should be able to perform either addition or subtraction based on a control signal \"operation\". If the control signal is high, the module should perform addition and if the control signal is low, the module should perform subtraction. \n\nDesign a verilog module that meets the above requirements and name it \"mathOpModule\".\n\n", "output": "module mathOpModule(\n  input [7:0] a,\n  input [7:0] b,\n  input operation,\n  output reg [8:0] result\n);\n\nalways @*\nbegin\n  if(operation)\n    result = a + b;\n  else\n    result = a - b;\nend\n\nendmodule"}
{"instruction": "\n\nYou are given a Verilog module named `SNPS_CLOCK_GATE_HIGH_RegisterAdd_W26_0_4` which has four input and output ports. The input ports are `CLK`, `EN`, and `TE`, and the output port is `ENCLK`. The module also instantiates a `TLATNTSCAX2TS` latch module. \n\nYour task is to implement the `TLATNTSCAX2TS` latch module. The `TLATNTSCAX2TS` module should have four input and output ports. The input ports are `E`, `SE`, `CK`, and `ECK`, and the output port is `Q`. The `E` and `SE` ports are the enable and set inputs, respectively. The `CK` port is the clock input, and the `ECK` port is the enable clock input. \n\nThe `TLATNTSCAX2TS` latch module should be implemented using the following logic:\n- When the `E` input is high and the `SE` input is low, the `Q` output should follow the `CK` input.\n- When the `E` input is low, the `Q` output should be latched at the value of the `CK` input at the rising edge of the `ECK` input.\n- When the `SE` input is high, the `Q` output should be set to high at the rising edge of the `ECK` input.\n\nImplement the `TLATNTSCAX2TS` module in Verilog within 200 lines of code.\n\n", "output": "module TLATNTSCAX2TS (E, SE, CK, ECK, Q);\n    input E, SE, CK, ECK;\n    output Q;\n    reg Q;\n\n    always @(posedge ECK) begin\n        if (E == 1'b1 && SE == 1'b0) begin\n            Q <= CK;\n        end\n        else if (E == 1'b0) begin\n            Q <= Q;\n            if (ECK == 1'b1) begin\n                Q <= CK;\n            end\n        end\n        else if (SE == 1'b1) begin\n            if (ECK == 1'b1) begin\n                Q <= 1'b1;\n            end\n        end\n    end\nendmodule"}
{"instruction": "Design a system that uses the half adder module from the given prompt to create a full adder module. The full adder should take in three inputs: a, b, and c_in, and produce two outputs: sum and c_out. The module should be named \"full_adder\" and should use the previously designed half adder module to implement the functionality.", "output": "module full_adder(\n    input a, b, c_in,\n    output c_out, sum\n);\n\nwire ha1_carry, ha2_carry;\nhalf_adder ha1(a, b, ha1_sum, ha1_carry);\nhalf_adder ha2(ha1_sum, c_in, sum, ha2_carry);\nor gate1(c_out, ha1_carry, ha2_carry);\n\nendmodule"}
